package com.sony.scea.pipeline.plugins.v1_0_0;

import java.util.*;

import us.temerity.pipeline.*;
import us.temerity.pipeline.NodeTreeComp.State;

/**
 * Makes sure that all the new clean up scripts are linked to the render
 * pass mel scripts that need them.<p>
 * This tool exists solely to clean up render passes generated by older
 * versions of the {@link BuildRenderTreeTool}. 
 * 
 * @author Jesse Clemens
 */
public class FixRenderScriptsTool extends BaseTool
{
  public FixRenderScriptsTool()
  {
    super("FixRenderScripts", new VersionID("1.0.0"), "SCEA",
      "Links in the right mel scripts to passes.");

    underDevelopment();
    addSupport(OsType.MacOS);
    addSupport(OsType.Windows);
  }
  
  public synchronized String 
  collectPhaseInput() 
  throws PipelineException
  {
    if (pSelected.size() != 1 || pPrimary == null)
      throw new PipelineException("Only select one node, you damn kid");
    
    if (!pPrimary.matches(lgtPattern))
	throw new PipelineException("Only run this on a lighting node");
    
    NodeStatus status = pSelected.get(pPrimary);
    NodeID id = status.getNodeID();
    
    pUser = id.getAuthor();
    pView = id.getView();

    NodeMod mod = status.getDetails().getWorkingVersion();
    FileSeq fseq = mod.getPrimarySequence();
    Path script = new Path(PackageInfo.sProdPath,
      id.getWorkingParent() + "/" + fseq.getPath(0));
    
    Path nPath = new Path(pPrimary);
    String lgtNodeName = nPath.getName();

    imgDir = nPath.getParentPath().getParent() + "/img/";

    filePrefix = lgtNodeName.replaceAll("seq","s");
    filePrefix = filePrefix.replaceAll("lgt","");
    
    return "Eat, eat, you fucking jackals!";
  }
  
  public synchronized boolean executePhase(MasterMgrClient mclient, QueueMgrClient qclient)
  throws PipelineException
  {
    jcheckOut(mclient, pUser, pView, cleanAllMEL, null, over, froz);
    for (String pass : passes)
    {
      String name = imgDir + pass + "/" + filePrefix + pass;
      if ( !doesNodeExists(mclient, name) )
	continue;
      
      String renderMel = name+"-rndr";
      if ( !doesNodeExists(mclient, renderMel) )
	continue;
      
      
      NodeMod renderMelMod = null;
      try
      {
	renderMelMod = mclient.getWorkingVersion(pUser, pView, renderMel);
      } catch ( PipelineException ex )
      {
	ex.printStackTrace();
	continue;
      }
      
      
      if (renderMel == null)
	continue;
      Set<String> sources = renderMelMod.getSourceNames();
      if (!sources.contains(cleanAllMEL))
      {
	mclient.link(pUser, pView, renderMel, cleanAllMEL, LinkPolicy.Dependency, LinkRelationship.All, null);
	BaseAction act = renderMelMod.getAction();
	act.initSourceParams(cleanAllMEL);
	act.setSourceParamValue(cleanAllMEL, "Order", 200);
	renderMelMod.setAction(act);
	mclient.modifyProperties(pUser, pView, renderMelMod);
      }
    }
    return false;
  }
  
  private String pUser;
  private String pView;
  
  /**
   * the image directory for the node.
   */
  private String imgDir;
  
  /**
   * prefix name for the shot
   */
  private String filePrefix; 
  
  private final String lgtPattern = ".*/production/.*/lgt/.*_lgt";

  private final String cleanAllMEL = "/projects/lr/assets/tools/render/sceaCleanAll";
  
  private static ArrayList<String> passes = new ArrayList<String>();
  {
    passes.add("mv");
    passes.add("chOcc");
    passes.add("envOcc");
    passes.add("z");
  }

  public static final CheckOutMode over = CheckOutMode.OverwriteAll;
  public static final CheckOutMethod froz = CheckOutMethod.AllFrozen;
  
  public boolean doesNodeExists(MasterMgrClient mclient, String name) throws PipelineException
  {
    TreeMap<String, Boolean> comps = new TreeMap<String, Boolean>();
    comps.put(name, false);
    NodeTreeComp treeComps = mclient.updatePaths(pUser, pView, comps);
    State state = getState(treeComps, name);
    if ( state == null || state.equals(State.Branch) )
      return false;
    return true;
  }

  private static State getState(NodeTreeComp treeComps, String scene)
  {
    State toReturn = null;
    Path p = new Path(scene);
    NodeTreeComp dest = null;
    for (String s : p.getComponents())
    {
      if ( dest == null )
	dest = treeComps.get(s);
      else
	dest = dest.get(s);

      if ( dest == null )
	break;
    }
    if ( dest != null )
      toReturn = dest.getState();
    return toReturn;
  }
  private void jcheckOut(MasterMgrClient mclient, String user, String view, String name,
      VersionID id, CheckOutMode mode, CheckOutMethod method) throws PipelineException
  {
    if (id == null)
      id = mclient.getCheckedInVersionIDs(name).last();
    if (id == null)
      throw new PipelineException("BAD BAD BAD");
    mclient.checkOut(user, view, name, id, mode, method);
  }
}
