// $Id: QueueJobGroupsTableModel.java,v 1.16 2010/01/21 01:36:56 jim Exp $

package us.temerity.pipeline.ui.core;

import us.temerity.pipeline.*;
import us.temerity.pipeline.math.*;
import us.temerity.pipeline.ui.*;

import java.text.*;
import java.util.*;
import javax.swing.*;
import javax.swing.table.*;

/*------------------------------------------------------------------------------------------*/
/*   Q U E U E   J O B   G R O U P S   T A B L E   M O D E L                                */
/*------------------------------------------------------------------------------------------*/

/**
 * A {@link SortableTableModel SortableTableModel} which contains a set of 
 * {@link QueueJobGroup QueueJobGroup} instances.
 */ 
public
class QueueJobGroupsTableModel
  extends AbstractSortableTableModel
{
  /*----------------------------------------------------------------------------------------*/
  /*   C O N S T R U C T O R                                                                */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Construct a table model.
   */
  public 
  QueueJobGroupsTableModel() 
  {
    super();

    /* initialize the columns */ 
    { 
      pNumColumns = 8;

      {
	Class classes[] = { 
	  Long.class, double[].class, String.class, String.class, String.class, String.class,
	  String.class, String.class
	}; 
	pColumnClasses = classes;
      }

      {
	String names[] = {
	  "Group ID", "Status", "Target Files", "Submitted", "Completed", "Key State", 
	  "Target Node", "Owner|View", 
	};
	pColumnNames = names;
      }

      {
	String desc[] = {
	  "The unique job group identifier.", 
	  "The status breakdown of member jobs.", 
	  "The file pattern of the files generated by the root member jobs.", 
	  "When the jobs where submitted for execution.", 
	  "When the all member jobs have completed.",
	  "The status of the key choosers in the jobs in the job group.",
	  "The name of the node associated with the root member jobs.", 
	  "The working area where the target files are created."
	};
	pColumnDescriptions = desc;
      }

      {
        Vector3i ranges[] = {
          new Vector3i(80), 
          new Vector3i(140),
          new Vector3i(120, 240, Integer.MAX_VALUE), 
          new Vector3i(180), 
          new Vector3i(180), 
          new Vector3i(90),
          new Vector3i(180, 360, Integer.MAX_VALUE), 
          new Vector3i(60, 180, Integer.MAX_VALUE), 
        };
        pColumnWidthRanges = ranges;
      }

      {
	TableCellRenderer renderers[] = {
	  new JSimpleTableCellRenderer(JLabel.CENTER), 
	  new JJobStatesTableCellRenderer(), 
	  new JSimpleTableCellRenderer(JLabel.CENTER), 
	  new JSimpleTableCellRenderer(JLabel.CENTER), 
	  new JSimpleTableCellRenderer(JLabel.CENTER), 
	  new JSimpleTableCellRenderer(JLabel.CENTER),
	  new JSimpleTableCellRenderer(JLabel.LEFT), 
	  new JSimpleTableCellRenderer(JLabel.CENTER)
	};
	pRenderers = renderers;
      }

      {
	TableCellEditor editors[] = { 
	  null, null, null, null, null, null, null, null
	};
	pEditors = editors;
      }
    }

    pQueueJobGroups = new ArrayList<QueueJobGroup>();
    pJobStateDist   = new TreeMap<Long,double[]>();

    pSortAscending = false;
  }

  

  /*----------------------------------------------------------------------------------------*/
  /*   A C C E S S                                                                          */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Get the ID of the job group at the given row.
   */
  public Long
  getGroupID
  (
   int row
  ) 
  {
    if(row >= pRowToIndex.length) 
      return null;

    QueueJobGroup group = pQueueJobGroups.get(pRowToIndex[row]);
    if(group != null) 
      return group.getGroupID();
    return null;
  }


  /*----------------------------------------------------------------------------------------*/

  /**
   * Set table data.
   * 
   * @param groups
   *   The queue job groups indexe by job group ID.
   * 
   * @param dist
   *   The distribution of job states indexed by job group ID.
   */ 
  public void
  setQueueJobGroups
  (
   TreeMap<Long,QueueJobGroup> groups, 
   TreeMap<Long,double[]> dist
  ) 
  {
    pQueueJobGroups.clear();
    pJobStateDist.clear();
    if((groups != null) && (dist != null)) {
      pQueueJobGroups.addAll(groups.values());
      pJobStateDist.putAll(dist); 
    }

    pNumRows = pQueueJobGroups.size(); 

    sort();
  }
  
  /**
   * Get the table row index which contains the job group with the given ID or <CODE>-1</CODE>
   * if the group cannot be found. 
   */ 
  public int 
  getGroupRow
  (
   long groupID
  )
  {
    int row; 
    for(row=0; row<pRowToIndex.length; row++) {
      QueueJobGroup group = pQueueJobGroups.get(pRowToIndex[row]);
      if((group != null) && (group.getGroupID() == groupID))
	return row;
    }

    return -1; 
  }
  
  

  /*----------------------------------------------------------------------------------------*/
  /*   S O R T I N G                                                                        */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Sort the rows by the values in the current sort column and direction.
   */ 
  public void 
  sort()
  {
    IndexValue cells[] = new IndexValue[pNumRows]; 
    int idx = 0;
    for(QueueJobGroup group : pQueueJobGroups) {
      Comparable value = null;
      switch(pSortColumn) {
      case 0:
	value = new Long(group.getGroupID());
	break;

      case 1:
	{
	  double[] dist = pJobStateDist.get(group.getGroupID());
	  value = new Distribution(dist); 
	}
	break;

      case 2:
	value = group.getRootSequence().toString();
	break;

      case 3: 
	value = group.getSubmittedStamp();
	break;

      case 4:
        value = group.getCompletedStamp();
	break;

      case 5:
        {
          boolean temp = group.doJobKeysNeedUpdate(); 
          if (temp)
            value = "Stale";
          else
            value = "Finished";
        }
        break;
	
      case 6:
	value = group.getNodeID().getName();
	break;

      case 7:
	value = (group.getNodeID().getAuthor() + "|" + group.getNodeID().getView());
      }
      
      cells[idx] = new IndexValue(idx, value); 
      idx++;
    }

    Comparator<IndexValue> comp = 
      pSortAscending ? new AscendingIndexValue() : new DescendingIndexValue(); 
    Arrays.sort(cells, comp);

    pRowToIndex = new int[pNumRows];
    int row; 
    for(row=0; row<pNumRows; row++) 
      pRowToIndex[row] = cells[row].getIndex();       

    fireTableDataChanged();
  }

  

  /*----------------------------------------------------------------------------------------*/
  /*   T A B L E   M O D E L   O V E R R I D E S                                            */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Returns true if the cell at rowIndex and columnIndex is editable.
   */ 
  public boolean 	
  isCellEditable
  (
   int row, 
   int col
  ) 
  {
    return false; 
  }

  /**
   * Returns the value for the cell at columnIndex and rowIndex.
   */ 
  public Object 	
  getValueAt
  (
   int row, 
   int col
  )
  {
    QueueJobGroup group = pQueueJobGroups.get(pRowToIndex[row]);
    switch(col) {
    case 0:
      return new Long(group.getGroupID());
      
    case 1:
      return pJobStateDist.get(group.getGroupID());

    case 2:
      return group.getRootSequence().toString();
      
    case 3:
      return TimeStamps.format(group.getSubmittedStamp());

    case 4:
      if(group.getCompletedStamp() != null)
	return TimeStamps.format(group.getCompletedStamp());
      else 
	return "-";
      
    case 5:
      {
        boolean temp = group.doJobKeysNeedUpdate(); 
        if (temp)
          return "Stale";
        else
          return "Finished";
      }
      
    case 6:
      return group.getNodeID().getName();

    case 7:
      return (group.getNodeID().getAuthor() + "|" + group.getNodeID().getView());
      
    default:
      assert(false);
      return null;
    }
  }


  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L   C L A S S E S                                                      */
  /*----------------------------------------------------------------------------------------*/

  private 
  class Distribution
    implements Comparable<Distribution> 
  {
    public 
    Distribution
    (
     double[] dist
    ) 
    {
      for(JobState jstate : JobState.all()) {
        switch(jstate) {
        case Queued:
        case Preempted: 
        case Paused:
          pPending += dist[jstate.ordinal()];
          break;
          
        case Running:
        case Limbo:
          pRunning += dist[jstate.ordinal()];
          break;
            
        case Aborted:
        case Finished:
        case Failed:
          pDone += dist[jstate.ordinal()];
        }
      }
    }

    public int 	
    compareTo
    (
     Distribution d
    ) 
    {
      if(ExtraMath.equiv(pDone, d.pDone)) {
        if(ExtraMath.equiv(pRunning, d.pRunning)) {
          if(ExtraMath.equiv(pPending, d.pPending)) {
            return 0;
          }
          else {
            return ((pPending < d.pPending) ? -1 : 1);
          }
        }
        else {
          return ((pRunning < d.pRunning) ? -1 : 1);
        }
      }
      else {
        return ((pDone < d.pDone) ? -1 : 1);
      }
    }

    private double pPending; 
    private double pRunning; 
    private double pDone; 
  }
     


  /*----------------------------------------------------------------------------------------*/
  /*   S T A T I C   I N T E R N A L S                                                      */
  /*----------------------------------------------------------------------------------------*/

  private static final long serialVersionUID = -93844522399458365L; 



  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L S                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /**
   * The underlying set of job groups.
   */ 
  private ArrayList<QueueJobGroup> pQueueJobGroups;

  /**
   * The distribution of job states indexed by job group ID.
   */ 
  private TreeMap<Long,double[]> pJobStateDist; 

}
