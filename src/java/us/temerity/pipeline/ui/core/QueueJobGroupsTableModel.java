// $Id: QueueJobGroupsTableModel.java,v 1.13 2009/12/09 09:14:33 jim Exp $

package us.temerity.pipeline.ui.core;

import us.temerity.pipeline.*;
import us.temerity.pipeline.math.*;
import us.temerity.pipeline.ui.*;

import java.text.*;
import java.util.*;
import javax.swing.*;
import javax.swing.table.*;

/*------------------------------------------------------------------------------------------*/
/*   Q U E U E   J O B   G R O U P S   T A B L E   M O D E L                                */
/*------------------------------------------------------------------------------------------*/

/**
 * A {@link SortableTableModel SortableTableModel} which contains a set of 
 * {@link QueueJobGroup QueueJobGroup} instances.
 */ 
public
class QueueJobGroupsTableModel
  extends AbstractSortableTableModel
{
  /*----------------------------------------------------------------------------------------*/
  /*   C O N S T R U C T O R                                                                */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Construct a table model.
   */
  public 
  QueueJobGroupsTableModel() 
  {
    super();

    /* initialize the columns */ 
    { 
      pNumColumns = 7;

      {
	Class classes[] = { 
	  Long.class, double[].class, String.class, String.class, String.class, 
	  String.class, String.class
	}; 
	pColumnClasses = classes;
      }

      {
	String names[] = {
	  "Group ID", "Status", "Target Files", "Submitted", "Completed", 
	  "Target Node", "Owner|View", 
	};
	pColumnNames = names;
      }

      {
	String desc[] = {
	  "The unique job group identifier.", 
	  "The status breakdown of member jobs.", 
	  "The file pattern of the files generated by the root member jobs.", 
	  "When the jobs where submitted for execution.", 
	  "When the all member jobs have completed.", 
	  "The name of the node associated with the root member jobs.", 
	  "The working area where the target files are created."
	};
	pColumnDescriptions = desc;
      }

      {
        Vector3i ranges[] = {
          new Vector3i(80), 
          new Vector3i(140),
          new Vector3i(120, 240, Integer.MAX_VALUE), 
          new Vector3i(180), 
          new Vector3i(180), 
          new Vector3i(180, 360, Integer.MAX_VALUE), 
          new Vector3i(60, 180, Integer.MAX_VALUE), 
        };
        pColumnWidthRanges = ranges;
      }

      {
	TableCellRenderer renderers[] = {
	  new JSimpleTableCellRenderer(JLabel.CENTER), 
	  new JJobStatesTableCellRenderer(), 
	  new JSimpleTableCellRenderer(JLabel.CENTER), 
	  new JSimpleTableCellRenderer(JLabel.CENTER), 
	  new JSimpleTableCellRenderer(JLabel.CENTER), 
	  new JSimpleTableCellRenderer(JLabel.LEFT), 
	  new JSimpleTableCellRenderer(JLabel.CENTER)
	};
	pRenderers = renderers;
      }

      {
	TableCellEditor editors[] = { 
	  null, null, null, null, null, null, null
	};
	pEditors = editors;
      }
    }

    pQueueJobGroups = new ArrayList<QueueJobGroup>();
    pJobStateDist   = new TreeMap<Long,double[]>();

    pSortAscending = false;
  }

  

  /*----------------------------------------------------------------------------------------*/
  /*   A C C E S S                                                                          */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Get the ID of the job group at the given row.
   */
  public Long
  getGroupID
  (
   int row
  ) 
  {
    if(row >= pRowToIndex.length) 
      return null;

    QueueJobGroup group = pQueueJobGroups.get(pRowToIndex[row]);
    if(group != null) 
      return group.getGroupID();
    return null;
  }


  /*----------------------------------------------------------------------------------------*/

  /**
   * Set table data.
   * 
   * @param groups
   *   The queue job groups indexe by job group ID.
   * 
   * @param dist
   *   The distribution of job states indexed by job group ID.
   */ 
  public void
  setQueueJobGroups
  (
   TreeMap<Long,QueueJobGroup> groups, 
   TreeMap<Long,double[]> dist
  ) 
  {
    pQueueJobGroups.clear();
    pJobStateDist.clear();
    if((groups != null) && (dist != null)) {
      pQueueJobGroups.addAll(groups.values());
      pJobStateDist.putAll(dist); 
    }

    pNumRows = pQueueJobGroups.size(); 

    sort();
  }
  
  /**
   * Get the table row index which contains the job group with the given ID or <CODE>-1</CODE>
   * if the group cannot be found. 
   */ 
  public int 
  getGroupRow
  (
   long groupID
  )
  {
    int row; 
    for(row=0; row<pRowToIndex.length; row++) {
      QueueJobGroup group = pQueueJobGroups.get(pRowToIndex[row]);
      if((group != null) && (group.getGroupID() == groupID))
	return row;
    }

    return -1; 
  }
  
  

  /*----------------------------------------------------------------------------------------*/
  /*   S O R T I N G                                                                        */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Sort the rows by the values in the current sort column and direction.
   */ 
  public void 
  sort()
  {
    IndexValue cells[] = new IndexValue[pNumRows]; 
    int idx = 0;
    for(QueueJobGroup group : pQueueJobGroups) {
      Comparable value = null;
      switch(pSortColumn) {
      case 0:
	value = new Long(group.getGroupID());
	break;

      case 1:
	{
	  double[] dist = pJobStateDist.get(group.getGroupID());
	  StringBuilder buf = new StringBuilder();
	  int wk;
	  for(wk=0; wk<dist.length; wk++) 
	    buf.append(dist[wk] + ":");

	  value = buf.toString();
	}
	break;

      case 2:
	value = group.getRootSequence().toString();
	break;

      case 3: 
	value = group.getSubmittedStamp();
	break;

      case 4:
        value = group.getCompletedStamp();
	break;

      case 5:
	value = group.getNodeID().getName();
	break;

      case 6:
	value = (group.getNodeID().getAuthor() + "|" + group.getNodeID().getView());
      }
      
      cells[idx] = new IndexValue(idx, value); 
      idx++;
    }

    Comparator<IndexValue> comp = 
      pSortAscending ? new AscendingIndexValue() : new DescendingIndexValue(); 
    Arrays.sort(cells, comp);

    pRowToIndex = new int[pNumRows];
    int row; 
    for(row=0; row<pNumRows; row++) 
      pRowToIndex[row] = cells[row].getIndex();       

    fireTableDataChanged();
  }

  

  /*----------------------------------------------------------------------------------------*/
  /*   T A B L E   M O D E L   O V E R R I D E S                                            */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Returns true if the cell at rowIndex and columnIndex is editable.
   */ 
  public boolean 	
  isCellEditable
  (
   int row, 
   int col
  ) 
  {
    return false; 
  }

  /**
   * Returns the value for the cell at columnIndex and rowIndex.
   */ 
  public Object 	
  getValueAt
  (
   int row, 
   int col
  )
  {
    QueueJobGroup group = pQueueJobGroups.get(pRowToIndex[row]);
    switch(col) {
    case 0:
      return new Long(group.getGroupID());
      
    case 1:
      return pJobStateDist.get(group.getGroupID());

    case 2:
      return group.getRootSequence().toString();
      
    case 3:
      return TimeStamps.format(group.getSubmittedStamp());

    case 4:
      if(group.getCompletedStamp() != null)
	return TimeStamps.format(group.getCompletedStamp());
      else 
	return "-";

    case 5:
      return group.getNodeID().getName();

    case 6:
      return (group.getNodeID().getAuthor() + "|" + group.getNodeID().getView());
      
    default:
      assert(false);
      return null;
    }
  }



  /*----------------------------------------------------------------------------------------*/
  /*   S T A T I C   I N T E R N A L S                                                      */
  /*----------------------------------------------------------------------------------------*/

  private static final long serialVersionUID = -93844522399458365L; 



  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L S                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /**
   * The underlying set of job groups.
   */ 
  private ArrayList<QueueJobGroup> pQueueJobGroups;

  /**
   * The distribution of job states indexed by job group ID.
   */ 
  private TreeMap<Long,double[]> pJobStateDist; 

}
