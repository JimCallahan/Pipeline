// $Id: NodeCommon.java,v 1.1 2004/02/28 20:05:47 jim Exp $

package us.temerity.pipeline;

import java.util.*;
import java.util.logging.*;
import java.io.*;

/*------------------------------------------------------------------------------------------*/
/*   N O D E   C O M M O N                                                                  */
/*------------------------------------------------------------------------------------------*/

/**
 * The superclass of <CODE>NodeVersion</CODE> and <CODE>NodeMod</CODE> which provides
 * the common fields and methods needed by both classes. <P>
 * 
 * @see Node
 * @see NodeVersion
 * @see NodeMod
 */
public
class NodeCommon
  extends Named
{  
  /*----------------------------------------------------------------------------------------*/
  /*   C O N S T R U C T O R                                                                */
  /*----------------------------------------------------------------------------------------*/

  protected 
  NodeCommon() 
  {
    pSecondarySeqs = new TreeSet<FileSeq>();
  }

  /**
   * Internal constructor used by <CODE>NodeMod</CODE> to construct an initial working 
   * version of a new node. <P> 
   * 
   * The <CODE>secondary</CODE> argument may be <CODE>null</CODE> if there are no 
   * secondary file sequences associated with the node. <P> 
   * 
   * The <CODE>editor</CODE> argument may be <CODE>null</CODE> if there is no default 
   * editor associated with the node. <P> 
   * 
   * If there is no regeneration action for this node then the <CODE>action</CODE> and 
   * <CODE>jobReqs</CODE> must both be <CODE>null</CODE>.  If there is a regeneration
   * action, then both arguments must not be <CODE>null</CODE>. <P>
   * 
   * If the <CODE>batchSize</CODE> argument is zero, then the maximum number of frames
   * which can be assigned to a single job is equal to the number of frames in the 
   * primary file sequence.  The <CODE>batchSize</CODE> argument cannot be negative. <P> 
   * 
   * @param name [<B>in</B>]
   *   The fully resolved node name.
   * 
   * @param primary [<B>in</B>]
   *   The primary file sequence associated with the node.
   * 
   * @param secondary [<B>in</B>]
   *   The secondary file sequences associated with the node.
   * 
   * @param toolset [<B>in</B>]
   *   The named execution environment under which editor and action are run.
   * 
   * @param editor [<B>in</B>]
   *   The name of the editor plugin used to editing/viewing the files associated with 
   *   the node.
   * 
   * @param action [<B>in</B>]
   *   The action plugin instance used to regeneration the files associated the node. 
   * 
   * @param jobReqs [<B>in</B>]
   *   The requirements that a server must meet in order to be eligable to run jobs 
   *   the node.
   *
   * @param ignoreOverflow [<B>in</B>]
   *   Whether dependencies which overflow their frame ranges should be ignored when 
   *   generating jobs for the node?
   *
   * @param isSerial [<B>in</B>]
   *   Are all of the files associated with the node regenerated by a single job invocation?
   *
   * @param batchSize [<B>in</B>]
   *   For parallel jobs, this is the maximum number of frames assigned to each job.
   */
  protected 
  NodeCommon
  (
   String name, 
   FileSeq primary,
   Set<FileSeq> secondary, 
   String toolset, 
   String editor, 
   BaseAction action, 
   JobReqs jobReqs,     
   boolean ignoreOverflow, 
   boolean isSerial, 
   int batchSize
  ) 
  {
    super(name);

    File path = new File(pName);

    {
      if(primary == null) 
	throw new IllegalArgumentException
	  ("The primary file sequence cannot be (null)!");

      String prefix = primary.getFilePattern().getPrefix();
      String simple = path.getName();
      if(!prefix.equals(simple)) 
	throw new IllegalArgumentException
	  ("The primary file sequence prefix (" + prefix + ") was not identical to " + 
	   "the last component of the node name (" + simple + ")!");
      pPrimarySeq = primary;
    }
      
    pSecondarySeqs = new TreeSet<FileSeq>();
    if(secondary != null) {
      for(FileSeq fseq : secondary) {
	if(pPrimarySeq.numFrames() != fseq.numFrames()) 
	  throw new IllegalArgumentException
	    ("The secondary file sequence (" + fseq + ") contained a different number " + 
	     "of files than the primary file sequence (" + pPrimarySeq + ")!");
	pSecondarySeqs.add(fseq);
      }
    }
    
    if(toolset == null) 
      throw new IllegalArgumentException
	("The toolset cannot be (null)!");
    pToolset = toolset;

    pEditor = editor;

    if((action != null) && (jobReqs != null)) {
      try {
	pAction  = (BaseAction) action.clone();
	pJobReqs = (JobReqs)    jobReqs.clone();
      }
      catch(CloneNotSupportedException ex) {
	assert(false);
      }
    }
    else if(!((action == null) && (jobReqs == null))) {
      throw new IllegalArgumentException
	("If either of the action or job requirement arguments are (null) then both " +
	 "of them must be (null)!");
    }
    
    pIgnoreOverflow = ignoreOverflow;
    pIsSerial       = isSerial;

    if(batchSize < 0)
      throw new IllegalArgumentException
	("The batch size cannot be negative!");
    pBatchSize = batchSize; 
  }


  /** 
   * Internal copy constructor used by both <CODE>NodeMod</CODE> and <CODE>NodeVersion</CODE>
   * when constructing instances based off an instance of the other subclass.
   */
  protected 
  NodeCommon
  (
   NodeCommon com
  ) 
  {
    super(com.getName());
    
    pPrimarySeq    = com.getPrimarySequence();
    pSecondarySeqs = (TreeSet) com.getSecondarySequences();
    
    pToolset = com.getToolset();
    pEditor  = com.getEditor();
    
    pAction         = com.getAction();
    pJobReqs        = com.getJobRequirements();
    pIgnoreOverflow = com.ignoreOverflow();
    pIsSerial       = com.isSerial();
    pBatchSize      = com.getBatchSize();
  }



  /*----------------------------------------------------------------------------------------*/
  /*   A C C E S S                                                                          */
  /*----------------------------------------------------------------------------------------*/
  
  /** 
   * Get the primary file sequence associated with the node. 
   */ 
  public FileSeq
  getPrimarySequence() 
  {
    return pPrimarySeq;
  }

  /** 
   * Get the set of secondary file sequences associated with the node.
   */
  public Set<FileSeq>
  getSecondarySequences()
  {
    return new TreeSet<FileSeq>(pSecondarySeqs);
  }

  
  /** 
   * Get the name of the execution environment under which to execute the editor program and 
   * the regeneration action. 
   */
  public String
  getToolset()
  {
    return pToolset;
  }

  /** 
   * Get name of the editor plugin used to editing/viewing the files associated with this 
   * version of the node.
   * 
   * @return 
   *   The name of the editor or <CODE>null</CODE> if there is no editor for this version 
   *   of the node.
   */
  public String
  getEditor()
  {
    return pEditor;
  }


  /** 
   * Get the action plugin instance used to regeneration the files associated with this 
   * version of the node.  
   * 
   * @return 
   *   The regeneration action or <CODE>null</CODE> if this version of the node has no 
   *   action.
   */
  public BaseAction
  getAction() 
  {
    if(pAction != null) {
      try {
	return (BaseAction) pAction.clone();
      }
      catch(CloneNotSupportedException ex) {
	assert(false);
      }
    }
      
    return null;
  }
  
  /** 
   * Get the requirements that a server must meet in order to be eligable to run jobs 
   * for this version of the node.
   * 
   * @return 
   *   The job requirements or <CODE>null</CODE> if this version of the node has no 
   *   action.
   */
  public JobReqs
  getJobRequirements() 
  {
    if(pJobReqs != null) {
      try {
	return (JobReqs) pJobReqs.clone();
      }
      catch(CloneNotSupportedException ex) {
	assert(false);
      }
    }
      
    return null;
  }

  /** 
   * Whether dependencies which overflow their frame ranges should be ignored when 
   * generating jobs for this version of the node.
   */
  public boolean
  ignoreOverflow() 
  {
    return pIgnoreOverflow;
  }

  /**
   * Are all of the files associated with this version of the node regenerated by a 
   * single job invocation?
   */
  public boolean
  isSerial()
  {
    return pIsSerial;
  }

  /**
   * For parallel jobs, this is the maximum number of frames assigned to each job. 
   */ 
  public int 
  getBatchSize() 
  {
    return pBatchSize;
  }
  

  /*----------------------------------------------------------------------------------------*/
  /*   O B J E C T   O V E R R I D E S                                                      */
  /*----------------------------------------------------------------------------------------*/

  /** 
   * Indicates whether some other object is "equal to" this one.
   * 
   * @param obj 
   *   The reference object with which to compare.
   */
  public boolean
  equals
  (
   Object obj
  )
  {
    if((obj != null) && (obj instanceof FilePattern)) {
      NodeCommon com = (NodeCommon) obj;
      return (super.equals(obj) && 
	      pPrimarySeq.equals(com.pPrimarySeq) && 
	      pSecondarySeqs.equals(com.pSecondarySeqs) && 
	      pToolset.equals(com.pToolset) && 
	      (((pEditor == null) && (com.pEditor == null)) || 
	       pEditor.equals(com.pEditor)) &&
	      (((pAction == null) && (com.pAction == null)) || 
	       pAction.equals(com.pAction)) &&
	      (((pJobReqs == null) && (com.pJobReqs == null)) || 
	       pJobReqs.equals(com.pJobReqs)) &&
	      (pIgnoreOverflow == com.pIgnoreOverflow) &&
	      (pIsSerial == com.pIsSerial) &&
	      (pBatchSize == com.pBatchSize));
    }
    return false;
  }


  /*----------------------------------------------------------------------------------------*/
  /*   C L O N E A B L E                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Return a deep copy of this object.
   */
  public Object 
  clone()
    throws CloneNotSupportedException
  {
    return new NodeCommon(this);
  }

  
  /*----------------------------------------------------------------------------------------*/
  /*   G L U E A B L E                                                                      */
  /*----------------------------------------------------------------------------------------*/

  public void 
  toGlue
  ( 
   GlueEncoder encoder   
  ) 
    throws GlueException
  {
    super.toGlue(encoder);

    encoder.encode("PrimarySeq", pPrimarySeq);

    if(!pSecondarySeqs.isEmpty()) 
      encoder.encode("SecondarySeqs", pSecondarySeqs);

    encoder.encode("Toolset", pToolset);

    if(pEditor != null) 
      encoder.encode("Editor", pEditor);
    
    if(pAction != null) {
      encoder.encode("Action", pAction);
      
      assert(pJobReqs != null);
      encoder.encode("JobRequirements", pJobReqs);
   
      encoder.encode("IgnoreOverflow", pIgnoreOverflow); 
      encoder.encode("IsSerial",       pIsSerial);
      encoder.encode("BatchSize",      pBatchSize);
    }
  }

  public void 
  fromGlue
  (
   GlueDecoder decoder 
  ) 
    throws GlueException
  {
    super.fromGlue(decoder);

    FileSeq primary = (FileSeq) decoder.decode("PrimarySeq");
    if(primary == null) 
      throw new GlueException("The \"PrimarySeq\" was missing or (null)!");
    pPrimarySeq = primary;

    TreeSet<FileSeq> secondary = (TreeSet<FileSeq>) decoder.decode("SecondarySeqs");
    if(secondary != null) 
      pSecondarySeqs = secondary;
    
    String toolset = (String) decoder.decode("Toolset");
    if(toolset == null) 
      throw new GlueException("The \"Toolset\" was missing or (null)!");
    pToolset = toolset;
    
    pEditor = (String) decoder.decode("Editor");
    
    BaseAction action = (BaseAction) decoder.decode("Action");
    if(action != null) {
      pAction = action;

      JobReqs jreqs = (JobReqs) decoder.decode("JobRequirements");
      if(jreqs == null) 
	throw new GlueException
	  ("The \"JobRequirements\" were missing or (null), yet the \"Action\" was " + 
	   "NOT (null)!");
      pJobReqs = jreqs;
      
      pIgnoreOverflow = (Boolean) decoder.decode("IgnoreOverflow");
      pIsSerial       = (Boolean) decoder.decode("IsSerial");
      pBatchSize      = (Integer) decoder.decode("BatchSize");
    }
  }



  /*----------------------------------------------------------------------------------------*/
  /*   S T A T I C   I N T E R N A L S                                                      */
  /*----------------------------------------------------------------------------------------*/

  private static final long serialVersionUID = -3524516091753764603L;



  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L S                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /** 
   * The primary file sequence associated with this version of the node.  <P> 
   * 
   * The primary file sequence cannot be <CODE>null</CODE> and must have a prefix which 
   * is identical to the last component of the node name.  The names of primary files 
   * are relative to the parent directory of the last component of the node name.
   */
  protected FileSeq  pPrimarySeq;

  /** 
   * The set of secondary file sequences associated with this version of the node. <P> 
   * 
   * There may be zero or more secondary file sequences.  Each secondary file sequence 
   * must have exactly the same number of files as are in the primary file sequence.
   * The names of secondary files are relative to the parent directory of the last 
   * component of the node name.
   */
  protected TreeSet<FileSeq>  pSecondarySeqs;   



  /**
   * The name of the execution environment under which to execute the editor program and 
   * the regeneration action. 
   */ 
  protected String  pToolset;            

  /**
   * The name of the editor plugin used to edit/view the files associated with this
   * version of the node. If <CODE>null</CODE>, there is no editor for this version 
   * of the node.
   */ 
  protected String  pEditor;         



  /** 
   * The action plugin instance used to regeneration the files associated with this 
   * version of the node.  If <CODE>null</CODE>, then this version of the node has no 
   * action.
   */
  protected BaseAction  pAction;          

  /**
   * The requirements that a server must meet in order to be eligable to run jobs 
   * for this version of the node.  If <CODE>null</CODE>, then this version of the node 
   * has no action and therefore no job requirements.
   */
  protected JobReqs pJobReqs;        

  /**
   * Whether dependencies which overflow their frame ranges should be ignored when 
   * generating jobs for this version of the node.  If this is <CODE>false</CODE>, then 
   * any frame range overflow will trigger an exception during job generation.
   */
  protected boolean  pIgnoreOverflow;    

  /**
   * Are all of the files associated with this version of the node regenerated by a 
   * single job invocation? <P> 
   * 
   * This is the case for inherently serial actions such as simulations.
   */
  protected boolean  pIsSerial;          

  /**
   * For parallel jobs, this is the maximum number of frames assigned to each job. 
   */ 
  protected int  pBatchSize;          

 
}

