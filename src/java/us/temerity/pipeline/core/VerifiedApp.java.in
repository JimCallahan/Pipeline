// $Id: VerifiedApp.java.in,v 1.13 2008/12/02 21:03:01 jim Exp $

package us.temerity.pipeline.core;

import us.temerity.pipeline.*;

import java.io.*; 
import java.net.*; 
import java.util.*;
import java.text.*;
import java.math.*;
import java.security.*;

/*------------------------------------------------------------------------------------------*/
/*   V E R I F I E D   A P P                                                                */
/*------------------------------------------------------------------------------------------*/

/**
 * The common base class for application which must verify the host ID of the machine
 * running the class.
 */
abstract
class VerifiedApp
  extends BaseApp
{  
  /*----------------------------------------------------------------------------------------*/
  /*   C O N S T R U C T O R                                                                */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Construct and the application with the given command-line arguments.
   * 
   * @param name 
   *   The name of the application executable.
   */
  public
  VerifiedApp
  (
   String name
  ) 
  {
    super(name);

    TreeMap<String,BigInteger> IDs = null;
    try {
      IDs = generateIDs();
    }
    catch(IOException ex) {
      LogMgr.getInstance().log
	(LogMgr.Kind.Net, LogMgr.Level.Severe,
	 ex.getMessage());
      System.exit(1);
    }

    /* verify the hostID for this machine */ 
    {
      assert(!IDs.isEmpty());
      assert(sHostNames.length == sHostIDs.length);

      boolean verified = false;
      int wk;
      for(wk=0; wk<sHostNames.length; wk++) {
	BigInteger id = IDs.get(sHostNames[wk]);
	if(id != null) {
	  BigInteger big = new BigInteger(sHostIDs[wk]);
	  if(big.equals(id)) {
	    verified = true; 
	    break;
	  }
	}
      }
      
      if(!verified) {
	LogMgr.getInstance().log
	  (LogMgr.Kind.Net, LogMgr.Level.Severe,
	   "Pipeline is not licensed for this machine!");

	System.exit(1);
      }
    }

    /* check the license time window (unless the license is Perpetual) */ 
    if(!isLicenseValid()) 
      System.exit(1);
  }



  /*----------------------------------------------------------------------------------------*/
  /*   H E L P E R S                                                                        */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Check if the license is still valid.
   */ 
  public boolean
  isLicenseValid() 
  {
    /* check the license time window (unless the license is Perpetual) */ 
    if(sLicenseEnd < Long.MAX_VALUE) {
      try {
	if(!TimeService.isValid(sLicenseStart, sLicenseEnd)) {
	  SimpleDateFormat fmt = new SimpleDateFormat("yyyy-MM-dd"); 
	  LogMgr.getInstance().log
	    (LogMgr.Kind.Net, LogMgr.Level.Severe,  
	     "The current " + sLicenseType + " license is only valid from: " + 
	     fmt.format(new Date(sLicenseStart)) + " until " + 
	     fmt.format(new Date(sLicenseEnd)) + ".\n" + 
	     "Contact <support@temerity.us> to renew the license.\n");
	  
	  return false; 
	}
      }
      catch(IOException ex) {
	LogMgr.getInstance().log
	  (LogMgr.Kind.Net, LogMgr.Level.Severe,  
	   "Unable to reliably determine the time!\n" +
	   "Pipeline was unable to contact any well known Network Time Servers via the " +
	   "InterNet in order to determine whether the current license has expired.\n" + 
	   "Contact your system administrator to verify that your connection to the " + 
	   "InterNet is functioning properly and that NTP packets are not being " + 
	   "filtered by your firewall.");
	
	return false;
      }      
    }

    return true; 
  }

  /**
   * Generate the hardware IDs for the local machine.
   */
  private TreeMap<String,BigInteger>
  generateIDs() 
    throws IOException 
  {
    /* the name of this host */ 
    String hostname = null;
    try {
      InetAddress addr = InetAddress.getLocalHost();
      if((addr instanceof Inet4Address) && !addr.isLoopbackAddress()) 
        hostname = addr.getCanonicalHostName().toLowerCase(Locale.ENGLISH);
    }
    catch(Exception ex) {
      throw new IOException 
	("Could not determine the name of this machine!");
    }

    if(hostname == null) 
      throw new IOException 
        ("Could not determine the name of this machine!");

    /* determine the hardware IDs */ 
    TreeMap<String,BigInteger> IDs = new TreeMap<String,BigInteger>();
    try {
      MessageDigest md = MessageDigest.getInstance("MD5");

      /* get OS release/version info */ 
      {
	StringBuffer buf = new StringBuffer();

	FileReader in = new FileReader("/proc/version");
        try {
          char[] cs = new char[4096];
          while(true) {
            int cnt = in.read(cs);
            if(cnt == -1) 
              break;
            
            buf.append(cs);
          }
        }
        finally {
          in.close();
        }

        md.update(buf.toString().getBytes());
      }

      /* get the CPU info */ 
      {
	FileReader in = new FileReader("/proc/cpuinfo");
        try {
          StringBuffer buf = new StringBuffer();
          char[] cs = new char[4096];
          while(true) {
            int cnt = in.read(cs);
            if(cnt == -1) 
              break;
            
            int wk;
            for(wk=0; wk<cnt; wk++) {
              if(cs[wk] == '\n') {
                String line = buf.toString();
                if(!line.startsWith("cpu MHz") && 
                   !line.startsWith("bogomips") &&
                   !line.startsWith("core id")) 
                  md.update(line.getBytes());
                buf = new StringBuffer();
              }
              else {
                buf.append(cs[wk]);
              }
            }
          }
        }
        finally {
          in.close();
        }
      }

      BigInteger hardwareID = new BigInteger(md.digest());
      IDs.put(hostname, hardwareID);
    }
    catch(Exception ex) {
      throw new IOException
        (Exceptions.getFullMessage("Unable to determine local host ID.", ex));
    }      

    return IDs;
  }



  /*----------------------------------------------------------------------------------------*/
  /*   S T A T I C   I N T E R N A L S                                                      */
  /*----------------------------------------------------------------------------------------*/

  private static final String[] sHostNames = {
    @PIPELINE_HOST_NAMES@
  };

  private static final String[] sHostIDs = {
    @PIPELINE_HOST_IDS@
  };

  private static final String sLicenseType = "@LICENSE_TYPE@";

  private static final long sLicenseStart = @LICENSE_START_STAMP@L;
  private static final long sLicenseEnd   = @LICENSE_END_STAMP@L;
  
}
