// $Id: VerifiedApp.java.in,v 1.9 2006/05/07 20:06:15 jim Exp $

package us.temerity.pipeline.core;

import us.temerity.pipeline.*;

import java.io.*; 
import java.net.*; 
import java.util.*;
import java.text.*;
import java.math.*;
import java.security.*;

/*------------------------------------------------------------------------------------------*/
/*   V E R I F I E D   A P P                                                                */
/*------------------------------------------------------------------------------------------*/

/**
 * The common base class for application which must verify the host ID of the machine
 * running the class.
 */
abstract
class VerifiedApp
  extends BaseApp
{  
  /*----------------------------------------------------------------------------------------*/
  /*   C O N S T R U C T O R                                                                */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Construct and the application with the given command-line arguments.
   * 
   * @param name 
   *   The name of the application executable.
   */
  public
  VerifiedApp
  (
   String name
  ) 
  {
    super(name);

    TreeMap<String,BigInteger> IDs = null;
    try {
      IDs = generateIDs();
    }
    catch(IOException ex) {
      LogMgr.getInstance().log
	(LogMgr.Kind.Net, LogMgr.Level.Severe,
	 ex.getMessage());
      System.exit(1);
    }

    /* verify the hostID for this machine */ 
    {
      assert(!IDs.isEmpty());
      assert(sHostNames.length == sHostIDs.length);

      boolean verified = false;
      int wk;
      for(wk=0; wk<sHostNames.length; wk++) {
	BigInteger id = IDs.get(sHostNames[wk]);
	if(id != null) {
	  BigInteger big = new BigInteger(sHostIDs[wk]);
	  if(big.equals(id)) {
	    verified = true; 
	    break;
	  }
	}
      }
      
      if(!verified) {
	LogMgr.getInstance().log
	  (LogMgr.Kind.Net, LogMgr.Level.Severe,
	   "Pipeline is not licensed for this machine!");

	System.exit(1);
      }
    }

    /* check the license time window (unless the license is Perpetual) */ 
    if(!isLicenseValid()) 
      System.exit(1);
  }



  /*----------------------------------------------------------------------------------------*/
  /*   H E L P E R S                                                                        */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Check if the license is still valid.
   */ 
  public boolean
  isLicenseValid() 
  {
    /* check the license time window (unless the license is Perpetual) */ 
    if(sLicenseEnd < Long.MAX_VALUE) {
      try {
	if(!TimeService.isValid(sLicenseStart, sLicenseEnd)) {
	  SimpleDateFormat fmt = new SimpleDateFormat("yyyy-MM-dd"); 
	  LogMgr.getInstance().log
	    (LogMgr.Kind.Net, LogMgr.Level.Severe,  
	     "The current " + sLicenseType + " license is only valid from: " + 
	     fmt.format(new Date(sLicenseStart)) + " until " + 
	     fmt.format(new Date(sLicenseEnd)) + ".\n" + 
	     "Contact <support@temerity.us> to renew the license.\n");
	  
	  return false; 
	}
      }
      catch(IOException ex) {
	LogMgr.getInstance().log
	  (LogMgr.Kind.Net, LogMgr.Level.Severe,  
	   "Unable to reliably determine the time!\n" +
	   "Pipeline was unable to contact any well known Network Time Servers via the " +
	   "InterNet in order to determine whether the current license has expired.\n" + 
	   "Contact your system administrator to verify that your connection to the " + 
	   "InterNet is functioning properly and that NTP packets are not being " + 
	   "filtered by your firewall.");
	
	return false;
      }      
    }

    return true; 
  }

  /**
   * Generate the hardware IDs for the local machine.
   */
  private TreeMap<String,BigInteger>
  generateIDs() 
    throws IOException 
  {
    /* the names of this host indexed by IP address */ 
    TreeMap<String,String> hostnames = new TreeMap<String,String>();
    try {
      Enumeration nets = NetworkInterface.getNetworkInterfaces();  
      while(nets.hasMoreElements()) {
	NetworkInterface net = (NetworkInterface) nets.nextElement();
	Enumeration addrs = net.getInetAddresses();
	while(addrs.hasMoreElements()) {
	  InetAddress addr = (InetAddress) addrs.nextElement();
	  if((addr instanceof Inet4Address) && !addr.isLoopbackAddress()) 
	    hostnames.put(addr.getHostAddress(), addr.getCanonicalHostName());
	}
      }
    }
    catch(Exception ex) {
      throw new IOException 
	("Could not determine the name of this machine!");
    }

    if(hostnames.isEmpty()) 
      throw new IOException 
	("Could not determine the name of this machine!");

    /* determine the hardware IDs */ 
    TreeMap<String,BigInteger> IDs = new TreeMap<String,BigInteger>();
    try {
      MessageDigest md = MessageDigest.getInstance("MD5");
      
      /* get the network card MAC addresses */ 
      TreeSet<String> found = new TreeSet<String>();
      {
	String str = null;
	try {
	  String args[] = new String[1];
	  args[0] = "/sbin/ifconfig";
	  
	  String env[] = new String[0];
	  
	  Process proc = Runtime.getRuntime().exec(args, env);
	  
	  StringBuffer buf = new StringBuffer();
	  InputStreamReader in = new InputStreamReader(proc.getInputStream());
	  char cs[] = new char[1024];
	  while(true) {
	    int cnt = in.read(cs);
	    if(cnt == -1) 
	      break;
	    
	    buf.append(cs, 0, cnt);
	  }

	  int exitCode = proc.waitFor();
	  if(exitCode != 0)
	    throw new IOException();

	  str = buf.toString();
	}
	catch(Exception ex) {
	  throw new IOException();
	}      
	
	if(str == null)
	  throw new IOException();
	
	{
	  boolean hwNext = false;
	  boolean ipNext = false;

	  String hw = null;

	  String tok[] = str.split(" ");
	  int wk; 
	  for(wk=0; wk<tok.length; wk++) {
	    if(tok[wk].length() > 0) {
	      if(hwNext) {
		String[] hex = tok[wk].split(":");
		if(hex.length != 6) 
		  throw new IOException();

		int i;
		for(i=0; i<hex.length; i++) 
		  if(hex[i].length() != 2)
		    throw new IOException();
		
		hw = tok[wk];
		hwNext = false;
	      }
	      else if(ipNext) {
		if(tok[wk].startsWith("addr:")) {
		  String addr = tok[wk].substring(5);
		  String hname = hostnames.get(addr);
		  if(hname != null) {
		    String s = ("IP=" + addr + " HWaddr=" + hw);
		    md.update(s.getBytes());
		    found.add(hname);
		  }
		}
		else {
		  throw new IOException();
		}
		
		hw     = null;
		ipNext = false;
	      }
	      else if(tok[wk].equals("HWaddr")) {
		hwNext = true;
	      }
	      else if(tok[wk].equals("inet")) {
		ipNext = true;
	      }
	      else {
		hwNext = false;
		ipNext = false;
	      }
	    }
	  }
	}

	if(found.isEmpty()) 
	  throw new IOException();
      }
      
      /* get the CPU info */ 
      {
	char[] cs = new char[4096];
	StringBuffer buf = new StringBuffer();

	FileReader in = new FileReader("/proc/cpuinfo");
	while(true) {
	  int cnt = in.read(cs);
	  if(cnt == -1) 
	    break;
	  
	  int wk;
	  for(wk=0; wk<cnt; wk++) {
	    if(cs[wk] == '\n') {
	      String line = buf.toString();
	      if(!line.startsWith("cpu MHz") && !line.startsWith("bogomips")) 
		md.update(line.getBytes());
	      buf = new StringBuffer();
	    }
	    else {
	      buf.append(cs[wk]);
	    }
	  }
	}
      }

      BigInteger hardwareID = new BigInteger(md.digest());
      for(String host : found) 
	IDs.put(host, hardwareID);
    }
    catch(Exception ex) {
      throw new IOException("Unable to determine local host ID.");
    }      

    return IDs;
  }


  /*----------------------------------------------------------------------------------------*/
  /*   S T A T I C   I N T E R N A L S                                                      */
  /*----------------------------------------------------------------------------------------*/

  private static final String[] sHostNames = {
    @PIPELINE_HOST_NAMES@
  };

  private static final String[] sHostIDs = {
    @PIPELINE_HOST_IDS@
  };

  private static final String sLicenseType = "@LICENSE_TYPE@";

  private static final long sLicenseStart = @LICENSE_START_STAMP@L;
  private static final long sLicenseEnd   = @LICENSE_END_STAMP@L;
  
}
