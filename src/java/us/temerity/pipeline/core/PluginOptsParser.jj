options {
  STATIC = false;
}

PARSER_BEGIN(PluginOptsParser)

package us.temerity.pipeline.core;

import us.temerity.pipeline.*;

import java.util.*;
import java.text.*;
import java.io.*;
import java.util.logging.*;

/*------------------------------------------------------------------------------------------*/
/*   Q U E U E   M G R   O P T S   P A R S E R                                              */
/*                                                                                          */
/*    The parser for the pljobmgr(1) job manager daemon.                                */
/*------------------------------------------------------------------------------------------*/

public class 
PluginOptsParser
{
  /*----------------------------------------------------------------------------------------*/
  /*   A C C E S S                                                                          */
  /*----------------------------------------------------------------------------------------*/

  /** 
   * Set the application instance. 
   */ 
  public void 
  setApp
  (
   PluginApp app  
  ) 
  {
    if(app == null) 
      throw new IllegalArgumentException("The application cannot be (null)!");
    pApp = app;
  }


  /*----------------------------------------------------------------------------------------*/
  /*   H E L P E R S                                                                        */
  /*----------------------------------------------------------------------------------------*/

  private void 
  init()
  {
    pList  = false;
    pForce = false; 

    pClassFiles = new TreeSet();
  }
 


  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L S                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /**
   * The application instance. 
   */
  private PluginApp  pApp;

  /**
   * Whether to list information about the installed plugins.
   */ 
  private boolean  pList; 

  /**
   * Whether to list information about the given plugins.
   */ 
  private boolean  pInspect; 

  /**
   * Whether to replace existing plugins when conflicts are detected.
   */ 
  private boolean  pForce; 

  /**
   * Whether to install the given plugins. 
   */ 
  private boolean  pInstall;

  /**
   * The list of compiled Java class files containing plugins.
   */ 
  private TreeSet  pClassFiles; 
}


PARSER_END(PluginOptsParser)

<DEFAULT> 
TOKEN :
{       
  /* information options */ 
  <HELP:         "--help">         
| <HTML_HELP:    "--html-help">    
| <VERSION:      "--version">      
| <RELEASE_DATE: "--release-date"> 
| <COPYRIGHT:    "--copyright">    
| <LICENSE:      "--license">    

  /* global options */	
| <LOG:          "--log">          : LOG_SEP

  /* action options */	
| <LIST:         "--list">   
| <INSPECT:      "--inspect">    
| <FORCE:        "--force">    
| <INSTALL:      "--install">    

  /* class files */
| <CLASS_FILE:   ("/")* ("../")* <CLASS_COMP> 
                 ("/" (".." | (<CLASS_COMP>)+)?)* ".class">  
| <#CLASS_COMP:  (["a"-"z","A"-"Z","0"-"9","_","-","."])*>

  /* seperators */ 
| <AE1: (["\0"])+>

  /* errors */ 
| <UNKNOWN_OPTION:  "-" ("-")? (~["\0","="])*>  : IGNORE_STATE
| <UNKNOWN_COMMAND: ~["-","\0"] (~["\0"])*>     : IGNORE_STATE
}


/* common states */ 
<IGNORE_STATE> 
TOKEN :
{
  <IGNORED: (~[])+>
}


/* --log arguments */ 
<LOG_SEP> 
TOKEN :
{
  <EQ1:               "=">   : LOG_STATE
| <MISSING_LOG_ARG: ~["="]>  : IGNORE_STATE
}

<LOG_STATE> 
TOKEN :
{
  <LOG_ALL:         "all">       
| <LOG_ARG: 	    "arg">        
| <LOG_OPS: 	    "ops">     
| <LOG_PLG: 	    "plg">     
| <LOG_SUB: 	    "sub">         
| <COLON:  	    ":">       
| <SEVERE:  	    "severe">  
| <WARNING: 	    "warning"> 
| <INFO:    	    "info">    
| <FINE:    	    "fine">    
| <FINER :  	    "finer">   
| <FINEST:    	    "finest">  
| <COMMA:  	    ",">       
| <AE2:             (["\0"])+>                   : DEFAULT
| <ILLEGAL_LOG_ARG: (~["\0","a"-"z",":",","])+>  : IGNORE_STATE
}



/*------------------------------------------------------------------------------------------*/
/*   T O P   L E V E L                                                                      */
/*------------------------------------------------------------------------------------------*/

void
CommandLine() 
  throws PipelineException :
{}
{
  (InformationOpts() | Commands()) <EOF>
  {}
}


void
Commands()
  throws PipelineException :
{
  init();
}
{
  (GlobalOpts() AE())* 
  ((List()) | 
   (Inspect() (ClassFile() AE())+) | 
   ((Force())? Install() (ClassFile() AE())+))
  { 
    try {
      PluginMgr.init();
    }
    catch(PipelineException ex) {
      Logs.plg.severe("Unable to load plugins: " + ex);
      System.exit(1);
    }

    if(pList && pForce)
      throw new ParseException
	("The --list and --force options are mutually exclusive!");
    
    PluginMgr mgr = PluginMgr.getInstance();
    if(pList) {
      mgr.listPlugins();
    }
    else if(pInspect) {
      Iterator iter = pClassFiles.iterator();
      while(iter.hasNext()) {
	File file = (File) iter.next();
	mgr.inspectPlugin(file);
      }
    } 
    else if(pInstall) {
      if(pClassFiles.isEmpty()) 
	throw new ParseException
	  ("No plugins where installed, since no Java class files where given!");

      Iterator iter = pClassFiles.iterator();
      while(iter.hasNext()) {
	File file = (File) iter.next();
	mgr.installPlugin(file, pForce);
      }
    }
  }
}
    

void
List() :
{}
{
  <LIST> AE() 
  { 
    pList = true;
  }
}

void
Inspect() :
{}
{
  <INSPECT> AE() 
  { 
    pInspect = true;
  }
}

void
Force() :
{}
{
  <FORCE> AE() 
  { 
    pForce = true; 
  }
}

void
Install() :
{}
{
  <INSTALL> AE() 
  { 
    pInstall = true; 
  }
}

void ClassFile() : 
{
  Token t; 
}
{
  (t=<CLASS_FILE>) 
  {
    File file = new File(t.image);
    if(!file.isFile()) 
      throw new ParseException
	("The given class file (" + file + ") does not exist!");

    pClassFiles.add(file);
  }
}


/*------------------------------------------------------------------------------------------*/
/*   I N F O R M A T I O N   O P T I O N S                                                  */
/*------------------------------------------------------------------------------------------*/

void
InformationOpts() :
{}
{
  (Help() | HtmlHelp() | Version() | ReleaseDate() | Copyright() | License())
  {}
}

void
Help() : 
{}
{
  <HELP> AE()
  { 
    pApp.help(); 
  }
}

void
HtmlHelp() : 
{}
{
  <HTML_HELP> AE()
  { 
    pApp.htmlHelp(); 
  }
}

void
Version() :
{}
{
  <VERSION> AE()
  { 
    pApp.version(); 
  }
}

void
ReleaseDate() :
{}
{
  <RELEASE_DATE> AE()
  { 
    pApp.releaseDate(); 
  }
}

void
Copyright() :
{}
{
  <COPYRIGHT> AE() 
  { 
    pApp.copyright(); 
  }
}

void
License() :
{}
{
  <LICENSE> AE() 
  { 
    pApp.license(); 
  }
}



/*------------------------------------------------------------------------------------------*/
/*   G L O B A L   O P T I O N S                                                            */
/*------------------------------------------------------------------------------------------*/

void
GlobalOpts() :
{}
{
  (Log())
  {}
}

void Log() : 
{}
{
  (<LOG> EQ() LoggerArg() (<COMMA> LoggerArg())*)
  {}
}

void LoggerArg() : 
{}
{
  (LoggerAll() | LoggerPair()) 
  {}
}

void LoggerAll() : 
{
  Level v;
}
{
  (<LOG_ALL> <COLON> v=LogLevel())
  {
    Logs.arg.setLevel(v); 
    Logs.ops.setLevel(v);
    Logs.net.setLevel(v);
    Logs.plg.setLevel(v);
    Logs.sub.setLevel(v);
  }
}

void LoggerPair() : 
{
  Logger g; 
  Level v;
}
{
  (g=Logger() <COLON> v=LogLevel())
  {
    g.setLevel(v);
  }
}

Logger Logger() :
{
  Logger g;
}
{
  (g=ArgLogger() | g=OpsLogger() | g=PlgLogger() | g=SubLogger())
  {
    return g;
  }
}

Logger ArgLogger() : 
{}
{
  <LOG_ARG>
  {
    return Logs.arg;
  }
}

Logger OpsLogger() : 
{}
{
  <LOG_OPS>
  {
    return Logs.ops;
  }
}

Logger PlgLogger() : 
{}
{
  <LOG_PLG>
  {
    return Logs.plg;
  }
}

Logger SubLogger() : 
{}
{
  <LOG_SUB>
  {
    return Logs.sub;
  }
}


Level LogLevel() : 
{
  Level v;
}
{
  (v=SevereLevel() | v=WarningLevel() | v=InfoLevel() | 
   v=FineLevel() | v=FinerLevel() | v=FinestLevel()) 
  {
    return v;
  }
}

Level SevereLevel() :
{
  Level v;
}
{
  <SEVERE> 
  {
    return Level.SEVERE;
  }
}

Level WarningLevel() :
{
  Level v;
}
{
  <WARNING> 
  {
    return Level.WARNING;
  }
}

Level InfoLevel() :
{
  Level v;
}
{
  <INFO> 
  {
    return Level.INFO;
  }
}

Level FineLevel() :
{
  Level v;
}
{
  <FINE> 
  {
    return Level.FINE;
  }
}

Level FinerLevel() :
{
  Level v;
}
{
  <FINER> 
  {
    return Level.FINER;
  }
}

Level FinestLevel() :
{
  Level v;
}
{
  <FINEST> 
  {
    return Level.FINEST;
  }
}




/*------------------------------------------------------------------------------------------*/
/*   S H A R E D   T O K E N S                                                              */
/*------------------------------------------------------------------------------------------*/

Token
AE() :
{
  Token t;
}
{
  (t=<AE1> | t=<AE2>)
  { 
    return t; 
  }
}


Token
EQ() :
{
  Token t;
}
{
  (t=<EQ1>) 
  { 
    return t; 
  }
}
