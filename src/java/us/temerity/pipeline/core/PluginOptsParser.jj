options {
  STATIC = false;
}

PARSER_BEGIN(PluginOptsParser)

package us.temerity.pipeline.core;

import us.temerity.pipeline.*;

import java.util.*;
import java.text.*;
import java.io.*;

/*------------------------------------------------------------------------------------------*/
/*   P L U G I N   O P T S   P A R S E R                                                    */
/*                                                                                          */
/*    The parser for the plplugin(1) plugin tool.                                           */
/*------------------------------------------------------------------------------------------*/

class 
PluginOptsParser
{
  /*----------------------------------------------------------------------------------------*/
  /*   A C C E S S                                                                          */
  /*----------------------------------------------------------------------------------------*/

  /** 
   * Set the application instance. 
   */ 
  public void 
  setApp
  (
   PluginApp app  
  ) 
  {
    if(app == null) 
      throw new IllegalArgumentException("The application cannot be (null)!");
    pApp = app;
  }


  /*----------------------------------------------------------------------------------------*/
  /*   H E L P E R S                                                                        */
  /*----------------------------------------------------------------------------------------*/

  private void 
  init()
  {
    pLogBackups  = 10;
    pList        = false;
    pSummary     = false;
    pPluginFiles = new TreeSet();
  }
 


  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L S                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /**
   * The application instance. 
   */
  private PluginApp  pApp;


  /*----------------------------------------------------------------------------------------*/

  /**
   * The name of the log file.
   */ 
  private Path  pLogFile; 

  /**
   * The number of backup to maintain of the log file.
   */ 
  private int  pLogBackups;


  /*----------------------------------------------------------------------------------------*/

  /**
   * Whether non-information commands have been given.
   */   
  private boolean  pHasCommands; 

  /**
   * Whether to list information about the installed plugins.
   */ 
  private boolean  pList; 

  /**
   * Whether to list the contents of installed plugins with plugins.
   */
  private boolean  pContents;

  /**
   * Whether to display a summary table about the installed plugins.
   */
  private boolean  pSummary;

  /**
   * The list of PluginStatus enums used to filter the display of installed plugins.
   */
  private TreeSet<PluginStatus>  pStatusSet;

  /**
   * The list of PluginType enums used to filter the display of installed plugins.
   */
  private TreeSet<PluginType>  pTypeSet;

  /**
   * The list of plugin vendor name Strings used to filter the 
   * display of installed plugins.
   */
  private TreeSet<String>  pVendorSet;

  /**
   * The list of plugin name Strings used to filter the display of installed plugins.
   */
  private TreeSet<String>  pNameSet;

  /**
   * The list of VersionID objects used to filter the display of installed plugins.
   */
  private TreeSet<VersionID>  pVersionSet;

  /**
   * Whether to ignore the Local Vendor check.
   */ 
  private boolean  pExternal;

  /**
   * Whether to ignore the Java class/package aliasing check.
   */ 
  private boolean  pRename;

  /**
   * Whether to just perform plugin validation and not load the plugin.
   */
  private boolean  pDryRun;

  /**
   * Whether to install the given plugins. 
   */ 
  private boolean  pInstall;

  /**
   * The list of compiled Java plugin files containing plugins.
   */ 
  private TreeSet  pPluginFiles; 
}


PARSER_END(PluginOptsParser)

<DEFAULT> 
TOKEN :
{       
  /* information options */ 
  <HELP:         "--help">         
| <HTML_HELP:    "--html-help">    
| <VERSION:      "--version">      
| <RELEASE_DATE: "--release-date"> 
| <COPYRIGHT:    "--copyright">    
| <LICENSE:      "--license">    

  /* global options */
| <LOG_FILE:          "--log-file">                : PATH_SEP
| <STANDARD_LOG_FILE: "--standard-log-file"> 
| <LOG_BACKUPS:       "--log-backups">             : INTEGER_SEP
| <LOG:               "--log">                     : LOG_SEP

  /* action options */	
| <LIST:           "--list">     
| <CONTENTS:       "--contents">
| <STATUS_FILTER:  "--status">                     : PLG_STATUS_SEP
| <TYPE_FILTER:    "--type">                       : PLG_TYPE_SEP
| <VENDOR_FILTER:  "--vendor">                     : PLG_VENDOR_SEP
| <NAME_FILTER:    "--name">                       : PLG_NAME_SEP
| <VERSION_FILTER: "--vsn">                        : PLG_VERSION_SEP
| <SUMMARY:        "--summary">
| <EXTERNAL:       "--external">    
| <RENAME:         "--rename">    
| <DRYRUN:         "--dry-run">
| <INSTALL:        "--install">    

  /* plugin files */
| <PLUGIN_FILE:   (["/","\\"])* ("../" | "..\\")* <PLUGIN_COMP> 
                 (["/","\\"] (".." | (<PLUGIN_COMP>)+)?)* (".jar" | ".class")>  
| <#PLUGIN_COMP:  (["a"-"z","A"-"Z","0"-"9","_","-","."])*>

  /* seperators */ 
| <AE1: (["\0"])+>

  /* errors */ 
| <UNKNOWN_OPTION:  "-" ("-")? (~["\0","="])*>  : IGNORE_STATE
| <UNKNOWN_COMMAND: ~["-","\0"] (~["\0"])*>     : IGNORE_STATE
}


/* common states */ 
<IGNORE_STATE> 
TOKEN :
{
  <IGNORED: (~[])+>
}


/* integer arguments */ 
<INTEGER_SEP> 
TOKEN :
{
  <EQ1:                   "=">   : INTEGER_STATE
| <MISSING_INTEGER_ARG: ~["="]>  : IGNORE_STATE
}

<INTEGER_STATE> 
TOKEN :
{
  <INTEGER:         (["0"-"9"])+>    : DEFAULT
| <MISSING_INTEGER: ["\0"]>      : IGNORE_STATE
| <ILLEGAL_INTEGER: (~["\0"])+>  : IGNORE_STATE
}


/* filesystem path arguments */ 
<PATH_SEP> 
TOKEN :
{
  <EQ2:                "=">   : PATH_STATE
| <MISSING_PATH_ARG: ~["="]>  : IGNORE_STATE
}

<PATH_STATE> 
TOKEN :
{
  <PATH_ARG:       ("/")* ("../")* <PATH_ARG_COMP> 
		     ("/" (".." | (<PATH_ARG_COMP>)+)?)*>      : DEFAULT
| <#PATH_ARG_COMP: (["a"-"z","A"-"Z","0"-"9","_","-","."])*>
| <MISSING_PATH:   ["\0"]>                                     : IGNORE_STATE
| <ILLEGAL_PATH:   (~["\0"])+>                                 : IGNORE_STATE
}


/* --log arguments */ 
<LOG_SEP> 
TOKEN :
{
  <EQ3:               "=">   : LOG_TYPE
| <MISSING_LOG_ARG: ~["="]>  : IGNORE_STATE
}

<LOG_TYPE> 
TOKEN :
{
  <LOG_ALL:          "all">       
| <LOG_ARG: 	     "arg">     
| <LOG_OPS: 	     "ops">      
| <LOG_NET: 	     "net">     
| <LOG_PLG: 	     "plg">     
| <COLON:  	     ":">        : LOG_LEVEL  
| <ILLEGAL_LOG_TYPE: (~[":"])+>  : IGNORE_STATE    
}

<LOG_LEVEL> 
TOKEN : 
{
  <SEVERE:  	      "severe">  
| <WARNING: 	      "warning"> 
| <INFO:    	      "info">    
| <FINE:    	      "fine">    
| <FINER :  	      "finer">   
| <FINEST:    	      "finest">  
| <COMMA:  	      ",">             : LOG_TYPE
| <AE2:               (["\0"])+>       : DEFAULT
| <ILLEGAL_LOG_LEVEL: (~["\0",","])+>  : IGNORE_STATE
}


/* plugins status arguments */ 
<PLG_STATUS_SEP> 
TOKEN :
{
  <EQ4:                       "=">   : PLG_STATUS_STATE
| <MISSING_PLG_STATUS_ARG:  ~["="]>  : IGNORE_STATE
}

<PLG_STATUS_STATE> 
TOKEN :
{
  <PLG_STATUS_ALL:              "all"> 
| <PLG_STATUS_REQ:              "req"> 
| <PLG_STATUS_INST:             "inst"> 
| <PLG_STATUS_DEV:              "dev"> 
| <PLG_STATUS_PERM:             "perm"> 
| <PLG_STATUS_MISS:             "miss"> 
| <PLG_STATUS_UNKNOWN:          "unknown"> 
| <COMMA1:                      ","> 
| <AE3:                         "\0">               : DEFAULT
| <ILLEGAL_PLG_STATUS:          (~[",","\0"])+>     : IGNORE_STATE
}


/* plugin type arguments */ 
<PLG_TYPE_SEP> 
TOKEN :
{
  <EQ5:                       "=">   : PLG_TYPE_STATE
| <MISSING_PLG_TYPE_ARG:    ~["="]>  : IGNORE_STATE
}

<PLG_TYPE_STATE> 
TOKEN :
{
  <PLG_TYPE_ALL:          "all"> 
| <PLG_TYPE_ACT:          "act"> 
| <PLG_TYPE_ANNOT:        "annot"> 
| <PLG_TYPE_ARCH:         "arch"> 
| <PLG_TYPE_BUILD:        "build"> 
| <PLG_TYPE_COMP:         "comp"> 
| <PLG_TYPE_EDIT:         "edit"> 
| <PLG_TYPE_KEY:          "key">
| <PLG_TYPE_MASTER:       "master">
| <PLG_TYPE_QUEUE:        "queue">
| <PLG_TYPE_TOOL:         "tool">
| <COMMA2:                ","> 
| <AE4:                   "\0">               : DEFAULT
| <ILLEGAL_PLG_TYPE:      (~[",","\0"])+>     : IGNORE_STATE
}


/* plugin vendor arguments */
<PLG_VENDOR_SEP>
TOKEN :
{
  <EQ6:                         "=">   : PLG_VENDOR_STATE
| <MISSING_PLG_VENDOR_ARG:    ~["="]>  : IGNORE_STATE
}

<PLG_VENDOR_STATE> 
TOKEN :
{
  <PLUGIN_VENDOR:           (["a"-"z","A"-"Z"]) 
	   	            (["a"-"z","A"-"Z","0"-"9","_","-","."])+>  
| <COMMA3:                  ",">
| <AE5:                     ["\0"]>                                   : DEFAULT
| <ILLEGAL_PLUGIN_VENDOR:   (~[",","\0"])+>                           : IGNORE_STATE
}


/* plugin name arguments */
<PLG_NAME_SEP>
TOKEN :
{
  <EQ7:                       "=">   : PLG_NAME_STATE
| <MISSING_PLG_NAME_ARG:    ~["="]>  : IGNORE_STATE
}

<PLG_NAME_STATE> 
TOKEN :
{
  <PLUGIN_NAME:             (["a"-"z","A"-"Z"]) 
	   	            (["a"-"z","A"-"Z","0"-"9","_","-","."])+>  
| <COMMA4:                  ",">
| <AE6:                     ["\0"]>                                   : DEFAULT
| <ILLEGAL_PLUGIN_NAME:   (~[",","\0"])+>                           : IGNORE_STATE
}


/* plugin version arguments */
<PLG_VERSION_SEP>
TOKEN :
{
  <EQ8:                          "=">   : PLG_VERSION_STATE
| <MISSING_PLG_VERSION_ARG:    ~["="]>  : IGNORE_STATE
}

<PLG_VERSION_STATE> 
TOKEN :
{
//  <PLUGIN_VERSION:           (["a"-"z","A"-"Z"]) 
//	   	             (["a"-"z","A"-"Z","0"-"9","_","-","."])+>  
  <PLUGIN_VERSION:            (<IREVNUM> "." <REVNUM> "." <REVNUM>)>  
| <#IREVNUM:                   ["1"-"9"] (["0"-"9"])*>
| <#REVNUM:                    (["0"-"9"])+>
| <COMMA5:                   ",">
| <AE7:                      ["\0"]>                                   : DEFAULT
| <ILLEGAL_PLUGIN_VERSION:   (~[",","\0"])+>                           : IGNORE_STATE
}


/*------------------------------------------------------------------------------------------*/
/*   T O P   L E V E L                                                                      */
/*------------------------------------------------------------------------------------------*/

void
CommandLine() 
  throws PipelineException :
{
  init();
}
{
  (InformationOpts() | Commands()) <EOF>
  {
    if(pHasCommands) {
      /* setup the log files */ 
      if(pLogFile != null) {
        try {
          LogMgr.getInstance().logToFile(pLogFile, pLogBackups, 10485760L);
        }
        catch(Exception ex) {
          System.out.print("Unable to setup log file: " + ex.getMessage());
          System.exit(1);
        }
      }

      /* initialize the plugins */ 
      PluginMgrControlClient client = new PluginMgrControlClient();
      try {
        try {
          client.update();
        }
        catch(PipelineException ex) {
          LogMgr.getInstance().log
            (LogMgr.Kind.Plg, LogMgr.Level.Severe,
             "Unable to load plugins: " + ex);
          System.exit(1);
        }
      
        /* run the program */ 
        if(pList) {
          pApp.listPlugins(client, 
	                   pStatusSet, pTypeSet, 
			   pVendorSet, pNameSet, pVersionSet, 
			   false);
        }
	else if(pContents) {
	  pApp.listPlugins(client, 
	                   pStatusSet, pTypeSet, 
			   pVendorSet, pNameSet, pVersionSet, 
			   true);
	}
        else if(pInstall) {
          if(pPluginFiles.isEmpty()) 
            throw new ParseException
              ("No plugins where installed, since no Java class or JAR files were given!");
	
          File plugindir = new File(".");
          Iterator iter = pPluginFiles.iterator();
          while(iter.hasNext()) {
            File pluginfile = (File) iter.next();
	  
            LogMgr.getInstance().log
              (LogMgr.Kind.Ops, LogMgr.Level.Info,
               (pDryRun ? "Dry run install: " : "Installing: ") + pluginfile); 
            LogMgr.getInstance().flush();
	  
            try {
              client.installPlugin(plugindir, pluginfile, pExternal, pRename, pDryRun);
            }
            catch(PipelineException ex) {
              LogMgr.getInstance().log
                (LogMgr.Kind.Ops, LogMgr.Level.Warning,
                 ex.getMessage());
            }
          }
        }

	if(pSummary) {
	  pApp.pluginSummary(client);
	}
      }
      finally {
        client.disconnect();
        LogMgr.getInstance().flush();
      }
    }
  }
}


void
Commands()
  throws PipelineException :
{}
{
  (GlobalOpts() AE())* 
    (
     ((List() | Contents()) (Summary())?) | 
     (Summary() (List() | Contents())?) | 
     ((External() | Rename() | DryRun())* Install() (PluginFile() AE())+)
    )
  { 
    pHasCommands = true;
  }
}
    

void
Summary() :
{}
{
  <SUMMARY> AE()
  {
    pSummary = true;
  }
}

void
List() :
{
  pStatusSet  = new TreeSet<PluginStatus>();
  pTypeSet    = new TreeSet<PluginType>();
  pVendorSet  = new TreeSet<String>();
  pNameSet    = new TreeSet<String>();
  pVersionSet = new TreeSet<VersionID>();
}
{
  <LIST> AE() (ListOpts())*
  { 
    pList = true;
  }
}

void
Contents() :
{
  pStatusSet  = new TreeSet<PluginStatus>();
  pTypeSet    = new TreeSet<PluginType>();
  pVendorSet  = new TreeSet<String>();
  pNameSet    = new TreeSet<String>();
  pVersionSet = new TreeSet<VersionID>();
}
{
  <CONTENTS> AE() (ListOpts())*
  { 
    pContents = true;
  }
}

void
ListOpts() :
{}
{
  (PluginStatus() | PluginType() | PluginVendor() | PluginName() | PluginVersion())
  {}
}

void
ContentsOpts() :
{}
{
  (PluginStatus() | PluginType() | PluginVendor() | PluginName() | PluginVersion())
  {}
}

void
PluginStatus() :
{}
{
  <STATUS_FILTER> EQ() PluginStatusToken() (COMMA() PluginStatusToken())* AE()
  {}
}

void
PluginType() :
{}
{
  <TYPE_FILTER> EQ() PluginTypeToken() (COMMA() PluginTypeToken())* AE()
  {}
}

void
PluginVendor() :
{}
{
  <VENDOR_FILTER> EQ() PluginVendorToken() (COMMA() PluginVendorToken())* AE()
  {}
}

void
PluginName() :
{}
{
  <NAME_FILTER> EQ() PluginNameToken() (COMMA() PluginNameToken())* AE()
  {}
}

void
PluginVersion() :
{}
{
  <VERSION_FILTER> EQ() PluginVersionToken() (COMMA() PluginVersionToken())* AE()
  {}
}

void
PluginVendorToken() :
{
  Token t;
}
{
  t=<PLUGIN_VENDOR>
  {
    pVendorSet.add(t.image);
  }
}

void
PluginNameToken() :
{
  Token t;
}
{
  t=<PLUGIN_NAME>
  {
    pNameSet.add(t.image);
  }
}

void
PluginVersionToken() :
{
  Token t;
}
{
  t=<PLUGIN_VERSION>
  {
    pVersionSet.add(new VersionID(t.image));
  }
}

void
PluginStatusToken() :
{}
{
  (PluginStatusAll() | 
   PluginStatusReq() | PluginStatusMiss() | 
   PluginStatusInst() | PluginStatusDev() | PluginStatusPerm() | 
   PluginStatusUnknown())
  {}
}

void
PluginTypeToken() :
{}
{
  (PluginTypeAll() | 
   PluginTypeAct() | PluginTypeAnnot() | PluginTypeArch() | 
   PluginTypeBuild() | PluginTypeComp() | PluginTypeEdit() | 
   PluginTypeKey() | PluginTypeMaster() | PluginTypeQueue() | PluginTypeTool())
  {}
}

void
PluginStatusAll() :
{}
{
  <PLG_STATUS_ALL>
  {
    for(PluginStatus status : PluginStatus.all())
      pStatusSet.add(status);
  }
}

void
PluginStatusReq() :
{}
{
  <PLG_STATUS_REQ>
  {
    pStatusSet.add(PluginStatus.Required);
  }
}

void
PluginStatusInst() :
{}
{
  <PLG_STATUS_INST>
  {
    pStatusSet.add(PluginStatus.Installed);
  }
}

void
PluginStatusDev() :
{}
{
  <PLG_STATUS_DEV>
  {
    pStatusSet.add(PluginStatus.UnderDevelopment);
  }
}

void
PluginStatusPerm() :
{}
{
  <PLG_STATUS_PERM>
  {
    pStatusSet.add(PluginStatus.Permanent);
  }
}

void
PluginStatusMiss() :
{}
{
  <PLG_STATUS_MISS>
  {
    pStatusSet.add(PluginStatus.Missing);
  }
}

void
PluginStatusUnknown() :
{}
{
  <PLG_STATUS_UNKNOWN>
  {
    pStatusSet.add(PluginStatus.Unknown);
  }
}

void
PluginTypeAll() :
{}
{
  <PLG_TYPE_ALL>
  {
    for(PluginType type : PluginType.all())
      pTypeSet.add(type);
  }
}

void
PluginTypeAct() :
{}
{
  <PLG_TYPE_ACT>
  {
    pTypeSet.add(PluginType.Action);
  }
}

void
PluginTypeAnnot() :
{}
{
  <PLG_TYPE_ANNOT>
  {
    pTypeSet.add(PluginType.Annotation);
  }
}

void
PluginTypeArch() :
{}
{
  <PLG_TYPE_ARCH>
  {
    pTypeSet.add(PluginType.Archiver);
  }
}

void
PluginTypeBuild() :
{}
{
  <PLG_TYPE_BUILD>
  {
    pTypeSet.add(PluginType.BuilderCollection);
  }
}

void
PluginTypeComp() :
{}
{
  <PLG_TYPE_COMP>
  {
    pTypeSet.add(PluginType.Comparator);
  }
}

void
PluginTypeEdit() :
{}
{
  <PLG_TYPE_EDIT>
  {
    pTypeSet.add(PluginType.Editor);
  }
}

void
PluginTypeKey() :
{}
{
  <PLG_TYPE_KEY>
  {
    pTypeSet.add(PluginType.KeyChooser);
  }
}

void
PluginTypeMaster() :
{}
{
  <PLG_TYPE_MASTER>
  {
    pTypeSet.add(PluginType.MasterExt);
  }
}

void
PluginTypeQueue() :
{}
{
  <PLG_TYPE_QUEUE>
  {
    pTypeSet.add(PluginType.QueueExt);
  }
}

void
PluginTypeTool() :
{}
{
  <PLG_TYPE_TOOL>
  {
    pTypeSet.add(PluginType.Tool);
  }
}

void
External() :
{}
{
  <EXTERNAL> AE() 
  { 
    pExternal = true;
  }
}

void
Rename() :
{}
{
  <RENAME> AE() 
  { 
    pRename = true;
  }
}


void
DryRun() :
{}
{
  <DRYRUN> AE()
  {
    pDryRun = true;
  }
}


void
Install() :
{}
{
  <INSTALL> AE() 
  { 
    pInstall = true; 
  }
}

void PluginFile() : 
{
  Token t; 
}
{
  (t=<PLUGIN_FILE>) 
  {
    File file = new File(t.image);
    if(!file.isFile()) 
      throw new ParseException
	("The given plugin file (" + file + ") does not exist!");

    pPluginFiles.add(file);
  }
}


/*------------------------------------------------------------------------------------------*/
/*   I N F O R M A T I O N   O P T I O N S                                                  */
/*------------------------------------------------------------------------------------------*/

void
InformationOpts() :
{}
{
  (Help() | HtmlHelp() | Version() | ReleaseDate() | Copyright() | License())
  {}
}

void
Help() : 
{}
{
  <HELP> AE()
  { 
    pApp.help(); 
  }
}

void
HtmlHelp() : 
{}
{
  <HTML_HELP> AE()
  { 
    pApp.htmlHelp(); 
  }
}

void
Version() :
{}
{
  <VERSION> AE()
  { 
    pApp.version(); 
  }
}

void
ReleaseDate() :
{}
{
  <RELEASE_DATE> AE()
  { 
    pApp.releaseDate(); 
  }
}

void
Copyright() :
{}
{
  <COPYRIGHT> AE() 
  { 
    pApp.copyright(); 
  }
}

void
License() :
{}
{
  <LICENSE> AE() 
  { 
    pApp.license(); 
  }
}



/*------------------------------------------------------------------------------------------*/
/*   G L O B A L   O P T I O N S                                                            */
/*------------------------------------------------------------------------------------------*/

void
GlobalOpts() :
{}
{
  (Log() | LogFile() | StandardLogFile() | LogBackups())
  {}
}


void LogFile() : 
{
  Token t;
}
{
  <LOG_FILE> EQ() t=<PATH_ARG>
  { 
    pLogFile = new Path(t.image);
  }
}

void StandardLogFile() : 
{}
{
  <STANDARD_LOG_FILE>
  { 
    pLogFile = new Path(PackageInfo.sInstPath, "/logs/plplugin.log");
  }
}

void LogBackups() : 
{
  Token t;
}
{
  <LOG_BACKUPS> EQ() t=<INTEGER>
  { 
    pLogBackups = Integer.parseInt(t.image);
  }
}

void Log() : 
{}
{
  (<LOG> EQ() LoggerArg() (<COMMA> LoggerArg())*)
  {}
}

void LoggerArg() : 
{}
{
  (LoggerAll() | LoggerPair()) 
  {}
}


void LoggerAll() : 
{
  LogMgr.Level v;
}
{
  (<LOG_ALL> <COLON> v=LogLevel())
  {
    LogMgr.getInstance().setLevels(v);
  }
}

void LoggerPair() : 
{
  LogMgr.Kind k;
  LogMgr.Level v;
}
{
  (k=LogKind() <COLON> v=LogLevel())
  {
    LogMgr.getInstance().setLevel(k, v);
  }
}

LogMgr.Kind LogKind() : 
{
  LogMgr.Kind g;
}
{
  (g=ArgKind() | g=OpsKind() | g=NetKind() | g=PlgKind())
  {
    return g;
  }
}

LogMgr.Kind ArgKind() : 
{}
{
  <LOG_ARG>
  {
    return LogMgr.Kind.Arg;
  }
}

LogMgr.Kind OpsKind() : 
{}
{
  <LOG_OPS>
  {
    return LogMgr.Kind.Ops;
  }
}

LogMgr.Kind NetKind() : 
{}
{
  <LOG_NET>
  {
    return LogMgr.Kind.Net;
  }
}

LogMgr.Kind PlgKind() : 
{}
{
  <LOG_PLG>
  {
    return LogMgr.Kind.Plg;
  }
}



LogMgr.Level LogLevel() : 
{
  LogMgr.Level v;
}
{
  (v=SevereLevel() | v=WarningLevel() | v=InfoLevel() | 
   v=FineLevel() | v=FinerLevel() | v=FinestLevel()) 
  {
    return v;
  }
}

LogMgr.Level SevereLevel() :
{
  LogMgr.Level v;
}
{
  <SEVERE> 
  {
    return LogMgr.Level.Severe;
  }
}

LogMgr.Level WarningLevel() :
{
  LogMgr.Level v;
}
{
  <WARNING> 
  {
    return LogMgr.Level.Warning;
  }
}

LogMgr.Level InfoLevel() :
{
  LogMgr.Level v;
}
{
  <INFO> 
  {
    return LogMgr.Level.Info;
  }
}

LogMgr.Level FineLevel() :
{
  LogMgr.Level v;
}
{
  <FINE> 
  {
    return LogMgr.Level.Fine;
  }
}

LogMgr.Level FinerLevel() :
{
  LogMgr.Level v;
}
{
  <FINER> 
  {
    return LogMgr.Level.Finer;
  }
}

LogMgr.Level FinestLevel() :
{
  LogMgr.Level v;
}
{
  <FINEST> 
  {
    return LogMgr.Level.Finest;
  }
}




/*------------------------------------------------------------------------------------------*/
/*   S H A R E D   T O K E N S                                                              */
/*------------------------------------------------------------------------------------------*/

Token
AE() :
{
  Token t;
}
{
  (t=<AE1> | t=<AE2> | 
   t=<AE3> | t=<AE4> | t=<AE5> | t=<AE6> | t=<AE7>)
  { 
    return t; 
  }
}


Token
COMMA() :
{
  Token t;
}
{
  (t=<COMMA1> | t=<COMMA2> | t=<COMMA3> | t=<COMMA4> | t=<COMMA5>)
  { 
    return t; 
  }
}


Token
EQ() :
{
  Token t;
}
{
  (t=<EQ1> | t=<EQ2> | t=<EQ3> | 
   t=<EQ4> | t=<EQ5> | t=<EQ6> | t=<EQ7> | t=<EQ8>)  
  { 
    return t; 
  }
}
