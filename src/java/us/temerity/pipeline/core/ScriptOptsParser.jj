options {
  STATIC = false;
}

PARSER_BEGIN(ScriptOptsParser)

package us.temerity.pipeline.core;

import us.temerity.pipeline.*;
import us.temerity.pipeline.ui.*;

import java.util.*;
import java.text.*;
import java.io.*;
import java.util.logging.*;
import javax.swing.*;        

/*------------------------------------------------------------------------------------------*/
/*   S C R I P T   O P T S   P A R S E R                                                    */
/*                                                                                          */
/*    The parser for the plscript(1) tool.                                                  */
/*------------------------------------------------------------------------------------------*/

public class 
ScriptOptsParser
{
  /*----------------------------------------------------------------------------------------*/
  /*   A C C E S S                                                                          */
  /*----------------------------------------------------------------------------------------*/

  /** 
   * Set the application instance. 
   */ 
  public void 
  setApp
  (
   ScriptApp app  
  ) 
  {
    if(app == null) 
      throw new IllegalArgumentException("The application cannot be (null)!");
    pApp = app;
  }


  /*----------------------------------------------------------------------------------------*/
  /*   I N I T I A L I Z A T I O N                                                          */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Initialize the parser.
   */
  private void 
  init()
  {
    pMasterServer = PackageInfo.sMasterServer;
    pMasterPort   = PackageInfo.sMasterPort;

    pQueueServer = PackageInfo.sQueueServer; 
    pQueuePort   = PackageInfo.sQueuePort;
    pJobPort     = PackageInfo.sJobPort;

    pBatchFiles = new Stack();
  }
 
  /**
   * Initialize the parser from a parent parser.
   */ 
  public void 
  init
  (
   ScriptOptsParser parent
  ) 
  {
    pApp = parent.pApp;

    pMasterServer    = parent.pMasterServer;
    pMasterPort      = parent.pMasterPort;
    pMasterMgrClient = parent.pMasterMgrClient;

    pQueueServer    = parent.pQueueServer;
    pQueuePort      = parent.pQueuePort;
    pJobPort        = parent.pJobPort;
    pQueueMgrClient = parent.pQueueMgrClient;

    pBatchFiles = new Stack(); 
    pBatchFiles.addAll(parent.pBatchFiles);
  }


  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L S                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /**
   * The application instance. 
   */
  private ScriptApp  pApp;


  /*----------------------------------------------------------------------------------------*/

  /**
   * The name of the host running the <B>plmaster</B><A>(1) daemon.
   */ 
  private String  pMasterServer;

  /**
   * The network port listened to by the <B>plmaster</B><A>(1) daemon.
   */
  private int  pMasterPort;

  /**
   * The connection to the <B>plmaster</B><A>(1) daemon. 
   */ 
  private MasterMgrClient  pMasterMgrClient; 


  /*----------------------------------------------------------------------------------------*/

  /*
   * The name of the host running the <B>plqueuemgr</B><A>(1) daemon. 
   */
  private String  pQueueServer;

  /**
   * The network port listened to by the <B>plqueuemgr</B><A>(1) daemon.
   */
  private int  pQueuePort;

  /**
   * The network port listened to by the <B>pljobmgr</B><A>(1) daemons.
   */
  private int  pJobPort;

  /**
   * The connection to the <B>plqueuemgr</B><A>(1) daemon. 
   */ 
  private QueueMgrClient  pQueueMgrClient; 



  /*----------------------------------------------------------------------------------------*/

  /**
   * The stack of currently open batch files.
   */ 
  private Stack pBatchFiles; 


  /*----------------------------------------------------------------------------------------*/

  /**
   * job-server command option temporaries
   */ 
  private QueueHost.Status  pJobStatus; 

  private String   pJobReserve;
  private boolean  pSetJobReserve;
  private Integer  pJobSlots;
  private TreeMap  pJobSelectionBiases;
  private TreeSet  pJobSelectionRemoves;
}


PARSER_END(ScriptOptsParser)

<DEFAULT> 
TOKEN :
{       
  /* information options */ 
  <HELP:         "--help">         
| <HTML_HELP:    "--html-help">    
| <VERSION:      "--version">      
| <RELEASE_DATE: "--release-date"> 
| <COPYRIGHT:    "--copyright">    
| <LICENSE:      "--license">    

  /* global options */	
| <MASTER_HOST:  "--master-host">   : HOST_NAME_SEP
| <MASTER_PORT:  "--master-port">   : PORT_NUMBER_SEP

| <QUEUE_HOST:   "--queue-host">    : HOST_NAME_SEP
| <QUEUE_PORT:   "--queue-port">    : PORT_NUMBER_SEP
| <JOB_PORT:     "--job-port">      : PORT_NUMBER_SEP

| <LOG:          "--log">           : LOG_SEP

  /* batch */ 
| <BATCH:        "--batch">         : PATH_SEP
		   
  /* commands */ 
| <PRIVILEGED:        "privileged">       : PRIVILEGED_OPTS 
| <DEFAULT_TOOLSET:   "default-toolset">  : TOOLSET_OPTS 
| <ACTIVE_TOOLSET:    "active-toolset">   : TOOLSET_OPTS 
| <TOOLSET:           "toolset">          : TOOLSET_OPTS 
| <LICENSE_KEY:       "license-key">      : KEY_OPTS 
| <SELECTION_KEY:     "selection-key">    : KEY_OPTS  
| <JOB_SERVER:        "job-server">       : JOB_SERVER_OPTS

  /* command options */ 
| <MSG:            "--msg">             : STRING_SEP  
| <TOTAL:          "--total">           : INTEGER_SEP  
| <SHUTDOWN:       "--shutdown">       
| <DISABLE:        "--disable">       
| <ENABLE:         "--enable">  
| <RESERVE:        "--reserve">         : USER_NAME_SEP            
| <OPEN:           "--open">  
| <SLOTS:          "--slots">           : INTEGER_SEP  
| <SELECTION_BIAS: "--selection-bias">  : KEY_BIAS_SEP  
| <REMOVE_KEY:     "--remove-key">      : KEY_NAME_SEP   

  /* argument end separator */ 
| <AE1: ("\0")+>

  /* errors */ 
| <UNKNOWN_OPTION:  "-" ("-")? (~["\0","="])*>  : IGNORE_STATE
| <UNKNOWN_COMMAND: ~["-","\0"] (~["\0"])*>     : IGNORE_STATE
}


/* common states */ 
<IGNORE_STATE> 
TOKEN :
{
  <IGNORED: (~[])+>
}


/* integer arguments */ 
<INTEGER_SEP> 
TOKEN :
{
  <EQ1:                   "=">   : INTEGER_STATE
| <MISSING_INTEGER_ARG: ~["="]>  : IGNORE_STATE
}

<INTEGER_STATE> 
TOKEN :
{
  <INTEGER:         (["0"-"9"])+>    : DEFAULT
| <MISSING_INTEGER: ["\0"]>          : IGNORE_STATE
| <ILLEGAL_INTEGER: (~["\0"])+>      : IGNORE_STATE
}


/* port number arguments */ 
<PORT_NUMBER_SEP> 
TOKEN :
{
  <EQ2:                       "=">   : PORT_NUMBER_STATE
| <MISSING_PORT_NUMBER_ARG: ~["="]>  : IGNORE_STATE
}

<PORT_NUMBER_STATE> 
TOKEN :
{
  <PORT_NUMBER:         (["0"-"9"])+>    : DEFAULT
| <MISSING_PORT_NUMBER: ["\0"]>          : IGNORE_STATE
| <ILLEGAL_PORT_NUMBER: (~["\0"])+>      : IGNORE_STATE
}


/* string arguments */   
<STRING_SEP> 
TOKEN :
{
  <EQ3:                  "=">   : STRING_STATE
| <MISSING_STRING_ARG: ~["="]>  : IGNORE_STATE
}

<STRING_STATE>
TOKEN :
{
  <STRING:         (~["\0"])*>  : DEFAULT
| <EMPTY_STRING:   "\0">        : DEFAULT
}


/* filesystem path arguments */ 
<PATH_SEP> 
TOKEN :
{
  <EQ4:                "=">   : PATH_STATE
| <MISSING_PATH_ARG: ~["="]>  : IGNORE_STATE
}

<PATH_STATE> 
TOKEN :
{
  <PATH_ARG:       ("/")* ("../")* <PATH_ARG_COMP> 
		     ("/" (".." | (<PATH_ARG_COMP>)+)?)*>      : DEFAULT
| <#PATH_ARG_COMP: (["a"-"z","A"-"Z","0"-"9","_","-","."])*>
| <MISSING_PATH:   ["\0"]>                                     : IGNORE_STATE
| <ILLEGAL_PATH:   (~["\0"])+>                                 : IGNORE_STATE
}


/* hostname arguments */ 
<HOST_NAME_SEP> 
TOKEN :
{
  <EQ5:                    "=">   : HOST_NAME_STATE
| <MISSING_HOST_NAME_ARG: ~["="]>  : IGNORE_STATE
}

<HOST_NAME_STATE> 
TOKEN :
{
  <HOST_NAME:         ((["a"-"z","A"-"Z","0"-"9"])+ 
		      ("." (["a"-"z","A"-"Z","0"-"9"])+)*)>   : DEFAULT
| <MISSING_HOST_NAME: ["\0"]>                                  : IGNORE_STATE
| <ILLEGAL_HOST_NAME: (~["\0"])+>                              : IGNORE_STATE
}


/* node name arguments */ 
<NODE_SEP> 
TOKEN :
{
  <EQ6:                "=">   : NODE_STATE
| <MISSING_NODE_ARG: ~["="]>  : IGNORE_STATE
}

<NODE_STATE> 
TOKEN :
{
  <NODE_ARG:       ("/" (["a"-"z","A"-"Z","0"-"9","_","-"])+)+>  : DEFAULT
| <MISSING_NODE:   ["\0"]>                                       : IGNORE_STATE
| <ILLEGAL_NODE:   (~["\0"])+>                                   : IGNORE_STATE
}


/* toolset name arguments */ 
<TOOLSET_NAME_SEP> 
TOKEN :
{
  <EQ7:                "=">           : TOOLSET_NAME_STATE
| <MISSING_TOOLSET_NAME_ARG: ~["="]>  : IGNORE_STATE
}

<TOOLSET_NAME_STATE> 
TOKEN :
{
  <TRUE1:                  "true">                                   : DEFAULT
| <FALSE1:                 "false">                                  : DEFAULT
| <TOOLSET_NAME:           (["a"-"z","A"-"Z"]) 
		           (["a"-"z","A"-"Z","0"-"9","_","-"])+>  
| <COLON1:                 ":">                                      
| <AE2:                    ["\0"]>                                   : DEFAULT
| <ILLEGAL_TOOLSET_NAME:   (~[":","\0"])+>                           : IGNORE_STATE
}


/* user name arguments */ 
<USER_NAME_SEP> 
TOKEN :
{
  <EQ8:                     "=">   : USER_NAME_STATE
| <MISSING_USER_NAME_ARG: ~["="]>  : IGNORE_STATE
}

<USER_NAME_STATE> 
TOKEN :
{
  <TRUE:                "true">                                   : DEFAULT
| <FALSE:               "false">                                  : DEFAULT
| <USER_NAME:           (["a"-"z","A"-"Z"]) 
	   	          (["a"-"z","A"-"Z","0"-"9","_","-"])+>  
| <COLON2:              ":">                                      
| <AE3:                 ["\0"]>                                   : DEFAULT
| <ILLEGAL_USER_NAME:   (~[":","\0"])+>                           : IGNORE_STATE
}


/* key name arguments */ 
<KEY_NAME_SEP> 
TOKEN :
{
  <EQ9:                    "=">   : KEY_NAME_STATE
| <MISSING_KEY_NAME_ARG: ~["="]>  : IGNORE_STATE
}

<KEY_NAME_STATE> 
TOKEN :
{
  <KEY_NAME:           (["a"-"z","A"-"Z"]) 
		         (["a"-"z","A"-"Z","0"-"9","_","-"])+>  
| <AE4:                ["\0"]>                                   : DEFAULT
| <ILLEGAL_KEY_NAME:   (~[":","\0"])+>                           : IGNORE_STATE
}

/* key bias arguments */ 
<KEY_BIAS_SEP> 
TOKEN :
{
  <EQ10:                   "=">   : KEY_BIAS_STATE
| <MISSING_KEY_BIAS_ARG: ~["="]>  : IGNORE_STATE
}

<KEY_BIAS_STATE> 
TOKEN :
{
  <KEY_BIAS_NAME:      (["a"-"z","A"-"Z"]) 
		         (["a"-"z","A"-"Z","0"-"9","_","-"])+>  
| <COLON3:             ":">      
| <KEY_BIAS:           (["0"-"9"])+>                             : DEFAULT  
| <AE5:                ["\0"]>                                   : DEFAULT
| <ILLEGAL_KEY_BIAS:   (~[":","\0"])+>                           : IGNORE_STATE
}

/* --log arguments */ 
<LOG_SEP> 
TOKEN :
{
  <EQ11:              "=">   : LOG_STATE
| <MISSING_LOG_ARG: ~["="]>  : IGNORE_STATE
}

<LOG_STATE> 
TOKEN :
{
  <LOG_ALL:         "all">       
| <LOG_ARG: 	    "arg">        
| <LOG_OPS: 	    "ops">     
| <LOG_NET: 	    "net">      
| <LOG_PLG: 	    "plg">       
| <LOG_SUB: 	    "sub">     
| <COLON4:  	    ":">       
| <SEVERE:  	    "severe">  
| <WARNING: 	    "warning"> 
| <INFO:    	    "info">    
| <FINE:    	    "fine">    
| <FINER :  	    "finer">   
| <FINEST:    	    "finest">  
| <COMMA:  	    ",">       
| <AE6:             (["\0"])+>                   : DEFAULT
| <ILLEGAL_LOG_ARG: (~["\0","a"-"z",":",","])+>  : IGNORE_STATE
}


/* privileged command options */ 
<PRIVILEGED_OPTS> 
TOKEN :
{
  <PRIVILEGED_GET:   "--get">                   : DEFAULT
| <PRIVILEGED_SET:   "--set">                   : USER_NAME_SEP 
| <AE7:              ["\0"]>  
| <UNKNOWN_OPTION1:  "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN1:         ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}


/* toolset command options */ 
<TOOLSET_OPTS> 
TOKEN :
{
  <TOOLSET_GET:        "--get">                   : DEFAULT
| <TOOLSET_GET_INFO:   "--get-info">              : TOOLSET_NAME_SEP  
| <TOOLSET_SET:        "--set">                   : TOOLSET_NAME_SEP 
| <TOOLSET_EXPORT:     "--export">                : TOOLSET_NAME_SEP
| <AE8:                ["\0"]>            
| <UNKNOWN_OPTION2:    "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN2:           ~["-","\0"] (~["\0"])*>    : IGNORE_STATE          
}


/* key command options */ 
<KEY_OPTS> 
TOKEN :
{
  <KEY_GET:            "--get">                   : DEFAULT
| <KEY_GET_INFO:       "--get-info">              : KEY_NAME_SEP  
| <KEY_ADD:            "--add">                   : KEY_NAME_SEP 
| <KEY_SET:            "--set">                   : KEY_NAME_SEP 
| <KEY_REMOVE:         "--remove">                : KEY_NAME_SEP 
| <AE9:                ["\0"]>    
| <UNKNOWN_OPTION3:    "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN3:           ~["-","\0"] (~["\0"])*>    : IGNORE_STATE           
}


/* job server command options */ 
<JOB_SERVER_OPTS> 
TOKEN :
{
  <JOB_GET:            "--get">                   : DEFAULT
| <JOB_GET_INFO:       "--get-info">              : HOST_NAME_SEP  
| <JOB_SET:            "--set">                   : HOST_NAME_SEP 
| <JOB_ADD:            "--add">                   : HOST_NAME_SEP 
| <JOB_REMOVE:         "--remove">                : HOST_NAME_SEP
| <AE10:               ["\0"]>   
| <UNKNOWN_OPTION4:    "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN4:           ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}



/*------------------------------------------------------------------------------------------*/
/*   T O P   L E V E L                                                                      */
/*------------------------------------------------------------------------------------------*/

void
CommandLine() 
  throws PipelineException :
{
  init();
}
{
  (InformationOpts() | ((GlobalOpts() AE())* (Batch() | Commands()))) <EOF>
  {}
}


void 
Commands() 
  throws PipelineException :
{
  try {
    PluginMgr.init();
  }
  catch(PipelineException ex) {
    Logs.plg.severe("Unable to load plugins: " + ex);
    System.exit(1);
  }

  pMasterMgrClient = new MasterMgrClient(pMasterServer, pMasterPort);
  pQueueMgrClient  = new QueueMgrClient(pQueueServer, pQueuePort);
}
{
  (PrivilegedCmds() | 
   DefaultToolsetCmds() | ActiveToolsetCmds() | ToolsetCmds() |
   LicenseKeyCmds() | SelectionKeyCmds() | JobServerCmds()

   ) 
  {
    pMasterMgrClient.disconnect();
    pQueueMgrClient.disconnect();
  }
}
    

/*------------------------------------------------------------------------------------------*/
/*   B A T C H   M O D E                                                                    */
/*------------------------------------------------------------------------------------------*/

void 
Batch() 
  throws PipelineException : 
{
  try {
    PluginMgr.init();
  }
  catch(PipelineException ex) {
    Logs.plg.severe("Unable to load plugins: " + ex);
    System.exit(1);
  }

  pMasterMgrClient = new MasterMgrClient(pMasterServer, pMasterPort);
  pQueueMgrClient  = new QueueMgrClient(pQueueServer, pQueuePort);
}
{
  (BatchOpt())
  {
    pMasterMgrClient.disconnect();
    pQueueMgrClient.disconnect();
  }
}

void 
BatchOpt() 
  throws PipelineException : 
{
  Token t;
}
{
  <BATCH> EQ() t=<PATH_ARG> AE()
  {
    /* process the batch file */ 
    File canon = null;
    {
      File file = new File(t.image);
      try {
	canon = file.getCanonicalFile();
      }
      catch(IOException ex) {
	throw new PipelineException
        ("Unable to determine the canonical filesystem path to the batch " + 
	 "file (" + file + ")!");
      }
    }

    Logs.ops.info("Processing Batch File: " + canon);

    if(pBatchFiles.contains(canon)) {
      StringBuffer buf = new StringBuffer();
      buf.append("Circular Batch Files:\n");

      Iterator iter = pBatchFiles.iterator();
      while(iter.hasNext()) {
	File file = (File) iter.next();
	buf.append("  " + file + " -> ");
      }
      buf.append("  " + canon);

      throw new PipelineException(buf.toString());
    }
    pBatchFiles.push(canon);

    ArrayList lines = pApp.packageFile(canon);
    Iterator iter = lines.iterator();
    while(iter.hasNext()) {
      String line = (String) iter.next();

      Logs.ops.info
	("\n" + 
	 pApp.repeat("*", 80) + "\n" +
	 "  BATCH: " + line.replace('\0',' ') + "\n" +
	 pApp.repeat("*", 80) + "\n");
      
      ScriptOptsParser parser = new ScriptOptsParser(new StringReader(line));
      parser.init(this);
      parser.BatchCommand();
    }

    pBatchFiles.pop();
  }
}

void 
BatchCommand() 
  throws PipelineException : 
{}
{
  (PrivilegedCmds() | 
   DefaultToolsetCmds() | ActiveToolsetCmds() | ToolsetCmds() |
   LicenseKeyCmds() | SelectionKeyCmds() | JobServerCmds() 
   
   ) (AE())* <EOF>
  {}
}



/*------------------------------------------------------------------------------------------*/
/*   I N F O R M A T I O N   O P T I O N S                                                  */
/*------------------------------------------------------------------------------------------*/

void
InformationOpts() :
{}
{
  (Help() | HtmlHelp() | Version() | ReleaseDate() | Copyright() | License())
  {}
}

void
Help() : 
{}
{
  <HELP> AE()
  { 
    pApp.help(); 
  }
}

void
HtmlHelp() : 
{}
{
  <HTML_HELP> AE()
  { 
    pApp.htmlHelp(); 
  }
}

void
Version() :
{}
{
  <VERSION> AE()
  { 
    pApp.version(); 
  }
}

void
ReleaseDate() :
{}
{
  <RELEASE_DATE> AE()
  { 
    pApp.releaseDate(); 
  }
}

void
Copyright() :
{}
{
  <COPYRIGHT> AE() 
  { 
    pApp.copyright(); 
  }
}

void
License() :
{}
{
  <LICENSE> AE() 
  { 
    pApp.license(); 
  }
}



/*------------------------------------------------------------------------------------------*/
/*   G L O B A L   O P T I O N S                                                            */
/*------------------------------------------------------------------------------------------*/

void
GlobalOpts() :
{}
{
  (MasterHost() | MasterPort() | 
   QueueHost() | QueuePort() | JobPort() | 
   Log())
  {}
}


void
MasterHost() :
{
  String hname = null;
}
{
  <MASTER_HOST> EQ() hname=HostName()
  { 
    pMasterServer = hname;
  }
}

void
MasterPort() :
{
  int port; 
}
{
  <MASTER_PORT> EQ() port=PortNumber() 
  { 
    pMasterPort = port;
  }
}

void
QueueHost() :
{
  String hname = null;
}
{
  <QUEUE_HOST> EQ() hname=HostName()
  { 
    pQueueServer = hname;
  }
}

void
QueuePort() :
{
  int port; 
}
{
  <QUEUE_PORT> EQ() port=PortNumber()
  { 
    pQueuePort = port;
  }
}

void
JobPort() :
{
  int port; 
}
{
  <JOB_PORT> EQ() port=PortNumber()
  { 
    pJobPort = port;
  }
}



void Log() : 
{}
{
  (<LOG> EQ() LoggerArg() (<COMMA> LoggerArg())*)
  {}
}

void LoggerArg() : 
{}
{
  (LoggerAll() | LoggerPair()) 
  {}
}

void LoggerAll() : 
{
  Level v;
}
{
  (<LOG_ALL> COLON() v=LogLevel())
  {
    Logs.arg.setLevel(v); 
    Logs.ops.setLevel(v);
    Logs.net.setLevel(v);
    Logs.plg.setLevel(v);
    Logs.sub.setLevel(v);
  }
}

void LoggerPair() : 
{
  Logger g; 
  Level v;
}
{
  (g=Logger() COLON() v=LogLevel())
  {
    g.setLevel(v);
  }
}

Logger Logger() :
{
  Logger g;
}
{
  (g=ArgLogger() | g=OpsLogger() | g=NetLogger() | 
   g=PlgLogger() | g=SubLogger())
  {
    return g;
  }
}

Logger ArgLogger() : 
{}
{
  <LOG_ARG>
  {
    return Logs.arg;
  }
}

Logger OpsLogger() : 
{}
{
  <LOG_OPS>
  {
    return Logs.ops;
  }
}

Logger NetLogger() : 
{}
{
  <LOG_NET>
  {
    return Logs.net;
  }
}

Logger PlgLogger() : 
{}
{
  <LOG_PLG>
  {
    return Logs.plg;
  }
}

Logger SubLogger() : 
{}
{
  <LOG_SUB>
  {
    return Logs.sub;
  }
}


Level LogLevel() : 
{
  Level v;
}
{
  (v=SevereLevel() | v=WarningLevel() | v=InfoLevel() | 
   v=FineLevel() | v=FinerLevel() | v=FinestLevel()) 
  {
    return v;
  }
}

Level SevereLevel() :
{
  Level v;
}
{
  <SEVERE> 
  {
    return Level.SEVERE;
  }
}

Level WarningLevel() :
{
  Level v;
}
{
  <WARNING> 
  {
    return Level.WARNING;
  }
}

Level InfoLevel() :
{
  Level v;
}
{
  <INFO> 
  {
    return Level.INFO;
  }
}

Level FineLevel() :
{
  Level v;
}
{
  <FINE> 
  {
    return Level.FINE;
  }
}

Level FinerLevel() :
{
  Level v;
}
{
  <FINER> 
  {
    return Level.FINER;
  }
}

Level FinestLevel() :
{
  Level v;
}
{
  <FINEST> 
  {
    return Level.FINEST;
  }
}



/*------------------------------------------------------------------------------------------*/
/*   P R I V I L E G E D   U S E R S                                                        */
/*------------------------------------------------------------------------------------------*/

void 
PrivilegedCmds() 
  throws PipelineException : 
{}
{
  <PRIVILEGED> AE() (PrivilegedGet() |  PrivilegedSet())
  {}
}

void 
PrivilegedGet() 
  throws PipelineException : 
{}
{
  <PRIVILEGED_GET> AE()
  {
    TreeSet users = pMasterMgrClient.getPrivilegedUsers(false);
    Iterator iter = users.iterator();
    while(iter.hasNext()) {
      String user = (String) iter.next();
      Logs.ops.info(user);
    }
    Logs.flush();
  }
}

void 
PrivilegedSet() 
  throws PipelineException : 
{
  String user = null;
  boolean tf = true;
}
{
  <PRIVILEGED_SET> EQ() user=UserName() (COLON() tf=TrueFalse())? AE()
  {
    if(tf) 
      pMasterMgrClient.grantPrivileges(user);
    else 
      pMasterMgrClient.removePrivileges(user);
  }
}


/*------------------------------------------------------------------------------------------*/
/*   T O O L S E T                                                                          */
/*------------------------------------------------------------------------------------------*/

void 
DefaultToolsetCmds() 
  throws PipelineException : 
{}
{
  <DEFAULT_TOOLSET> AE() (DefaultToolsetGet() |  DefaultToolsetSet())
  {}
}

void 
DefaultToolsetGet() 
  throws PipelineException : 
{}
{
  <TOOLSET_GET> AE()
  {
    Logs.ops.info(pMasterMgrClient.getDefaultToolsetName());
    Logs.flush();
  }
}

void 
DefaultToolsetSet() 
  throws PipelineException : 
{
  String tname = null;
}
{
  <TOOLSET_SET> EQ() tname=ToolsetName() AE()
  {
    pMasterMgrClient.setDefaultToolsetName(tname);
  }
}


/*------------------------------------------------------------------------------------------*/

void 
ActiveToolsetCmds() 
  throws PipelineException : 
{}
{
  <ACTIVE_TOOLSET> AE() (ActiveToolsetGet() |  ActiveToolsetSet())
  {}
}

void 
ActiveToolsetGet() 
  throws PipelineException : 
{}
{
  <TOOLSET_GET> AE()
  {
    TreeSet tnames = pMasterMgrClient.getActiveToolsetNames(); 
    Iterator iter = tnames.iterator();
    while(iter.hasNext()) {
      String tname = (String) iter.next();
      Logs.ops.info(tname);
    }
    Logs.flush();
  }
}

void 
ActiveToolsetSet() 
  throws PipelineException : 
{
  String tname = null;
  boolean tf = true;
}
{
  <TOOLSET_SET> EQ() tname=ToolsetName() (COLON() tf=TrueFalse())? AE()
  {
    pMasterMgrClient.setToolsetActive(tname, tf);
  }
}


/*------------------------------------------------------------------------------------------*/

void 
ToolsetCmds() 
  throws PipelineException : 
{}
{
  <TOOLSET> AE() (ToolsetGet() |  ToolsetGetInfo() |  ToolsetExport())
  {}
}

void 
ToolsetGet() 
  throws PipelineException : 
{}
{
  <TOOLSET_GET> AE()
  {
    TreeSet tnames = pMasterMgrClient.getToolsetNames(); 
    Iterator iter = tnames.iterator();
    while(iter.hasNext()) {
      String tname = (String) iter.next();
      Logs.ops.info(tname);
    }
    Logs.flush();
  }
}

void 
ToolsetGetInfo() 
  throws PipelineException : 
{
  String tname = null;
}
{
  <TOOLSET_GET_INFO> EQ() tname=ToolsetName() AE()
  {
    pApp.printToolset(tname, pMasterMgrClient);
  }
}

void 
ToolsetExport() 
  throws PipelineException : 
{
  String tname = null;
}
{
  <TOOLSET_EXPORT> EQ() tname=ToolsetName() AE()
  {
    pApp.exportToolset(tname, pMasterMgrClient);
  }
}


/*------------------------------------------------------------------------------------------*/
/*   Q U E U E   A D M I N I S T R A T I O N                                                */
/*------------------------------------------------------------------------------------------*/

void 
LicenseKeyCmds() 
  throws PipelineException : 
{}
{
  <LICENSE_KEY> AE() 
     (LicenseKeyGet() | LicenseKeyGetInfo() | LicenseKeyAdd() | 
      LicenseKeySet() | LicenseKeyRemove())
  {}
}

void 
LicenseKeyGet() 
  throws PipelineException : 
{}
{
  <KEY_GET> AE()
  {
    TreeSet knames = pQueueMgrClient.getLicenseKeyNames();
    Iterator iter = knames.iterator();
    while(iter.hasNext()) {
      String kname = (String) iter.next();
      Logs.ops.info(kname);
    }
    Logs.flush();    
  }
}

void 
LicenseKeyGetInfo() 
  throws PipelineException : 
{
  String kname = null;
}
{
  <KEY_GET_INFO> EQ() kname=KeyName() AE()
  {
    pApp.printLicenseKey(kname, pQueueMgrClient);
  }
}

void 
LicenseKeyAdd() 
  throws PipelineException : 
{
  String kname = null;
  String msg = null;
  int total = 0;
}
{
  <KEY_ADD> EQ() kname=KeyName() AE() 
     ((msg=Msg() AE() total=Total()) | (total=Total() AE() msg=Msg())) AE()
  {
    LicenseKey key = new LicenseKey(kname, msg, total);
    pQueueMgrClient.addLicenseKey(key);
  }
}
 
void 
LicenseKeySet() 
  throws PipelineException : 
{
  String kname = null;
  int total = 0;
}
{
  <KEY_SET> EQ() kname=KeyName() AE() total=Total() AE()
  {
    pQueueMgrClient.setTotalLicenses(kname, total);
  }
}
 
void 
LicenseKeyRemove() 
  throws PipelineException : 
{
  String kname = null;
}
{
  <KEY_REMOVE> EQ() kname=KeyName() AE()
  {
    pQueueMgrClient.removeLicenseKey(kname);
  }
}

int 
Total() : 
{
  int total = 0;
}
{
  <TOTAL> EQ() total=IntegerLiteral() 
  {
    return total;
  }
}
      

/*------------------------------------------------------------------------------------------*/

void 
SelectionKeyCmds() 
  throws PipelineException : 
{}
{
  <SELECTION_KEY> AE() 
     (SelectionKeyGet() | SelectionKeyGetInfo() | SelectionKeyAdd() | SelectionKeyRemove())
  {}
}

void 
SelectionKeyGet() 
  throws PipelineException : 
{}
{
  <KEY_GET> AE()
  {
    TreeSet knames = pQueueMgrClient.getSelectionKeyNames();
    Iterator iter = knames.iterator();
    while(iter.hasNext()) {
      String kname = (String) iter.next();
      Logs.ops.info(kname);
    }
    Logs.flush();    
  }
}

void 
SelectionKeyGetInfo() 
  throws PipelineException : 
{
  String kname = null;
}
{
  <KEY_GET_INFO> EQ() kname=KeyName() AE()
  {
    pApp.printSelectionKey(kname, pQueueMgrClient);
  }
}

void 
SelectionKeyAdd() 
  throws PipelineException : 
{
  String kname = null;
  String msg = null;
}
{
  <KEY_ADD> EQ() kname=KeyName() AE() msg=Msg() AE()
  {
    SelectionKey key = new SelectionKey(kname, msg);
    pQueueMgrClient.addSelectionKey(key);
  }
}
 
void 
SelectionKeyRemove() 
  throws PipelineException : 
{
  String kname = null;
}
{
  <KEY_REMOVE> EQ() kname=KeyName() AE()
  {
    pQueueMgrClient.removeSelectionKey(kname);
  }
}


/*------------------------------------------------------------------------------------------*/

void 
JobServerCmds() 
  throws PipelineException : 
{}
{
  <JOB_SERVER> AE() 
     (JobServerGet() | JobServerGetInfo() | JobServerAdd() | 
      JobServerSet() | JobServerRemove())
  {}
}

void 
JobServerGet() 
  throws PipelineException : 
{}
{
  <JOB_GET> AE()
  {
    TreeMap hosts = pQueueMgrClient.getHosts();
    Iterator iter = hosts.keySet().iterator();
    while(iter.hasNext()) {
      String hname = (String) iter.next();
      Logs.ops.info(hname);
    }
    Logs.flush();    
  }
}

void 
JobServerGetInfo() 
  throws PipelineException : 
{
  String hname = null;
}
{
  <JOB_GET_INFO> EQ() hname=HostName() AE()
  {
    pApp.printHosts(hname, pQueueMgrClient);
  }
}

void 
JobServerAdd() 
  throws PipelineException : 
{
  String hname = null;
}
{
  <JOB_ADD> EQ() hname=HostName() AE()
  {
    pQueueMgrClient.addHost(hname);
  }
}

void 
JobServerSet() 
  throws PipelineException : 
{
  String hname = null;

  pJobStatus           = null;
  pJobReserve          = null;
  pSetJobReserve       = false;
  pJobSlots            = null;
  pJobSelectionBiases  = new TreeMap();
  pJobSelectionRemoves = new TreeSet();
}
{
  <JOB_SET> EQ() hname=HostName() AE() (JobServerSetOption())+
  {
    pApp.editHost(hname, 
		  pJobStatus, pJobReserve, pSetJobReserve, pJobSlots, 
		  pJobSelectionBiases, pJobSelectionRemoves, 
		  pQueueMgrClient);
  }
}

void 
JobServerSetOption() :
{}
{
  (JobServerShutdown() | JobServerEnable() | JobServerDisable() | 
   JobServerReserve() | JobServerSlots() | 
   JobServerSelectionBias() | JobServerSelectionRemoveKey())
  {}
}

void 
JobServerShutdown() :
{}
{
  <SHUTDOWN> AE()
  {
    if(pJobStatus != null) 
      throw new ParseException
	("The --shutdown, --enable and --disable options are mutually exclusive!");
    pJobStatus = QueueHost.Status.Shutdown;
  }
}

void 
JobServerEnable() :
{}
{
  <ENABLE> AE()
  {
    if(pJobStatus != null) 
      throw new ParseException
	("The --shutdown, --enable and --disable options are mutually exclusive!");
    pJobStatus = QueueHost.Status.Enabled;
  }
}

void 
JobServerDisable() :
{}
{
  <DISABLE> AE()
  {
    if(pJobStatus != null) 
      throw new ParseException
	("The --shutdown, --enable and --disable options are mutually exclusive!");
    pJobStatus = QueueHost.Status.Disabled;
  }
}

void 
JobServerReserve() :
{
  String name    = null;
  pSetJobReserve = true;
}
{
  ((<RESERVE> EQ() name=UserName()) | <OPEN>) AE()
  {
    pJobReserve = name;
  }
}

void
JobServerSlots() : 
{
  Integer slots = null;
}
{
  <SLOTS> EQ() slots=IntegerLiteral() AE()
  {
    pJobSlots = slots;
  }
}

void 
JobServerSelectionBias() : 
{
  String kname;
  Integer bias; 
}
{
  <SELECTION_BIAS> EQ() kname=KeyBiasName() COLON() bias=KeyBias() AE()
  {
    pJobSelectionBiases.put(kname, bias);
  }  
}

void 
JobServerSelectionRemoveKey() : 
{
  String kname;
}
{
  <REMOVE_KEY> EQ() kname=KeyName() AE()
  {
    pJobSelectionRemoves.add(kname);
  }
}
  

void 
JobServerRemove() 
  throws PipelineException : 
{
  String hname = null;
}
{
  <JOB_REMOVE> EQ() hname=KeyName() AE()
  {
    pApp.removeHost(hname, pQueueMgrClient);
  }
}



/*------------------------------------------------------------------------------------------*/
/*   S H A R E D   T O K E N S                                                              */
/*------------------------------------------------------------------------------------------*/

Token
AE() :
{
  Token t;
}
{
  (t=<AE1> | t=<AE2> | t=<AE3> | t=<AE4> | t=<AE5> | 
   t=<AE6> | t=<AE7> | t=<AE8> | t=<AE9> | t=<AE10>)
  { 
    return t; 
  }
}

Token
COLON() :
{
  Token t;
}
{
  (t=<COLON1> | t=<COLON2> | t=<COLON3> | t=<COLON4>)
  { 
    return t; 
  }
}

Token
EQ() :
{
  Token t;
}
{
  (t=<EQ1> | t=<EQ2> | t=<EQ3> | t=<EQ4> | t=<EQ5> | 
   t=<EQ6> | t=<EQ7> | t=<EQ8> | t=<EQ9> | t=<EQ10> | 
   t=<EQ11>)
  { 
    return t; 
  }
}


/*------------------------------------------------------------------------------------------*/

boolean 
TrueFalse() : 
{
  boolean tf; 
}
{
  (tf=True() | tf=False()) 
  { 
    return tf; 
  }
}

boolean 
True() : 
{}
{
  <TRUE>
  { 
    return true; 
  }
}

boolean 
False() : 
{}
{
  <FALSE>
  { 
    return false; 
  }
}


/*------------------------------------------------------------------------------------------*/

String
Name() : 
{
  Token t;
}
{
  t=<USER_NAME>
  {
    return t.image;
  }
}

String
HostName() : 
{
  Token t;
}
{
  t=<HOST_NAME>
  {
    return t.image;
  }
}

String
UserName() : 
{
  Token t;
}
{
  t=<USER_NAME>
  {
    return t.image;
  }
}

String
ToolsetName() : 
{
  Token t;
}
{
  t=<TOOLSET_NAME>
  {
    return t.image;
  }
}

String
KeyName() : 
{
  Token t;
}
{
  t=<KEY_NAME>
  {
    return t.image;
  }
}

String
KeyBiasName() : 
{
  Token t;
}
{
  t=<KEY_BIAS_NAME>
  {
    return t.image;
  }
}



/*------------------------------------------------------------------------------------------*/

int
IntegerLiteral() :
{
  Token t;
}
{
  t=<INTEGER>
  { 
    try {
      return Integer.parseInt(t.image);
    }
    catch(NumberFormatException ex) {
      Logs.arg.severe(ex.getMessage());
    }
  }
}

int
PortNumber() :
{
  Token t;
}
{
  t=<PORT_NUMBER>
  { 
    try {
      return Integer.parseInt(t.image);
    }
    catch(NumberFormatException ex) {
      Logs.arg.severe(ex.getMessage());
    }
  }
}

int
KeyBias() : 
{
  Token t;
}
{
  t=<KEY_BIAS>
  { 
    try {
      return Integer.parseInt(t.image);
    }
    catch(NumberFormatException ex) {
      Logs.arg.severe(ex.getMessage());
    }
  }
}


/*------------------------------------------------------------------------------------------*/

String
StringLiteral() : 
{
  Token t;
}
{
  t=<STRING>
  { 
    if(t.image.length() > 0) 
      return t.image;
    return null;
  }
}


/*------------------------------------------------------------------------------------------*/

String 
Msg() : 
{
  String msg; 
}
{
  <MSG> EQ() msg=StringLiteral() 
  {
    return msg;
  }
}
