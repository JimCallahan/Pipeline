options {
  STATIC = false;
}

PARSER_BEGIN(ScriptOptsParser)

package us.temerity.pipeline.core;

import us.temerity.pipeline.*;
import us.temerity.pipeline.ui.*;

import java.util.*;
import java.text.*;
import java.io.*;
import javax.swing.*;        

/*------------------------------------------------------------------------------------------*/
/*   S C R I P T   O P T S   P A R S E R                                                    */
/*                                                                                          */
/*    The parser for the plscript(1) tool.                                                  */
/*------------------------------------------------------------------------------------------*/

class 
ScriptOptsParser
{
  /*----------------------------------------------------------------------------------------*/
  /*   A C C E S S                                                                          */
  /*----------------------------------------------------------------------------------------*/

  /** 
   * Set the application instance. 
   */ 
  public void 
  setApp
  (
   ScriptApp app  
  ) 
  {
    if(app == null) 
      throw new IllegalArgumentException("The application cannot be (null)!");
    pApp = app;
  }


  /*----------------------------------------------------------------------------------------*/
  /*   I N I T I A L I Z A T I O N                                                          */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Initialize the parser.
   */
  private void 
  init()
  {
    pLogBackups = 10;
    pBatchFiles = new Stack();
  }
 
  /**
   * Initialize the parser from a parent parser.
   */ 
  public void 
  init
  (
   ScriptOptsParser parent
  ) 
  {
    pApp = parent.pApp;

    pMasterMgrClient = parent.pMasterMgrClient;
    pQueueMgrClient  = parent.pQueueMgrClient;

    pBatchFiles = new Stack(); 
    pBatchFiles.addAll(parent.pBatchFiles);
  }


  /**
   * Close the network connections to the plqueuemgr(1) and plmaster(1) daemons.
   */ 
  public void
  disconnect()
  {
    if(pMasterMgrClient != null)
      pMasterMgrClient.disconnect();
    
    if(pQueueMgrClient != null)
      pQueueMgrClient.disconnect();
  }
  

  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L S                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /**
   * The application instance. 
   */
  private ScriptApp  pApp;


  /*----------------------------------------------------------------------------------------*/

  /**
   * The name of the log file.
   */ 
  private Path pLogFile; 

  /**
   * The number of backup to maintain of the log file.
   */ 
  private int  pLogBackups;


  /*----------------------------------------------------------------------------------------*/

  /**
   * The connection to the <B>plmaster</B><A>(1) daemon. 
   */ 
  private MasterMgrClient  pMasterMgrClient; 

  /**
   * The connection to the <B>plqueuemgr</B><A>(1) daemon. 
   */ 
  private QueueMgrClient  pQueueMgrClient; 



  /*----------------------------------------------------------------------------------------*/

  /**
   * The stack of currently open batch files.
   */ 
  private Stack pBatchFiles; 


  /*----------------------------------------------------------------------------------------*/

  /**
   * user --set options. 
   */ 
  private Boolean  pWorkGroupMembership; 
  private TreeSet  pWorkGroupUsers; 

  /**
   * privilege --grant/--revoke options; 
   */ 
  private Boolean  pIsMasterAdmin; 
  private Boolean  pIsDeveloper; 
  private Boolean  pIsQueueAdmin; 
  private Boolean  pIsQueueManager; 
  private Boolean  pIsNodeManager; 

  /**
   * admin options. 
   */ 
  private boolean  pShutdownJobMgrs;
  private boolean  pShutdownPluginMgr;

  /**
   * runtime options. 
   */ 
  private LogControls  pLogControls; 

  private Integer pCollectorBatchSize;
  private Long    pDispatcherInterval;
  
  private Long  pNodeGCInterval;
  private Long  pMinOverhead;
  private Long  pMaxOverhead;
  private Long  pAvgNodeSize;
  private Long  pRestoreCleanupInterval;

  /**
   * archive-volume options. 
   */ 
  private String     pArchivePattern; 
  private Integer    pMaxArchives; 
  private Long       pMinSize; 

  private String     pArchiverName;
  private VersionID  pArchiverVersionID;
  private String     pArchiverVendor; 

  private boolean    pAutoStart; 

  private Integer    pExcludeLatest; 
  private Integer    pMinArchives; 
  
  private TreeMap    pCheckedInVersions; 

  /**
   * job-server command option temporaries
   */ 
  private QueueHostStatusChange  pJobStatus; 

  private String   pJobReserve;
  private boolean  pSetJobReserve;
  private Integer  pJobOrder;
  private Integer  pJobSlots;
  private String   pJobSelectionSchedule;
  private boolean  pJobNoSelectionSchedule;
  private String   pJobSelectionGroup;
  private boolean  pJobNoSelectionGroup;


  private String         pMessage;
  private LicenseScheme  pLicenseScheme;
  private Integer        pMaxSlots;
  private Integer        pMaxHosts;
  private Integer        pMaxHostSlots;
  
  /**
   * view options
   */ 
  private String   pViewPattern; 
  private Boolean  pRemoveArea; 

  /**
   * working node version command option temporaries
   */   
  private ArrayList  pFrames; 
  private ArrayList  pIndices; 
  private FileSeq    pFileSeq; 
  private Integer    pPadding; 
  private Boolean    pWait; 

  private String     pAuthor; 
  private String     pView; 
  private TreeSet    pSections; 
  private String     pToolset;

  private String     pEditorName;
  private VersionID  pEditorVersionID; 
  private String     pEditorVendor; 

  private Boolean    pNoAction; 
  private String     pActionName;
  private VersionID  pActionVersionID; 
  private String     pActionVendor; 
  private Boolean    pActionEnabled;
  private TreeMap    pParams;
  private TreeMap    pSourceParams;

  private OverflowPolicy   pOverflowPolicy;
  private ExecutionMethod  pExecutionMethod;
  private Integer          pBatchSize;
  private Integer          pPriority;
  private Integer          pRampUp; 
  private Float            pMaxLoad;
  private Long             pMinMemory;
  private Long             pMinDisk;
  private TreeMap          pLicenseKeys;
  private TreeMap          pSelectionKeys;

  private Boolean     pRemoveFiles;
  private Boolean     pRenameFiles;
  private FilePattern pNewFilePattern; 
  private FrameRange  pFrameRange; 

  private String  pCloneSource; 

  private String            pLinkSourceName;  
  private LinkPolicy        pLinkPolicy;      
  private LinkRelationship  pLinkRelationship;
  private Integer           pLinkFrameOffset; 


  /**
   * checked-in node version command option temporaries
   */  
  private TreeSet  pVersionIDs; 
  private boolean  pLatest; 


  /**
   * node command option temporaries
   */  
  private boolean          pBrief;
  private boolean          pUpstream;
  private boolean          pLight;
  private boolean          pLinkGraph; 
  private boolean          pGlue; 
  private VersionID.Level  pLevel; 
  private CheckOutMode     pCheckOutMode; 
  private CheckOutMethod   pCheckOutMethod; 

  private TreeSet          pEventNames;
  private TreeSet          pEventUsers;
  private Long             pEventStart; 
  private Long             pEventFinish; 
}


PARSER_END(ScriptOptsParser)

<DEFAULT> 
TOKEN :
{       
  /* information options */ 
  <HELP:         "--help">         
| <HTML_HELP:    "--html-help">    
| <VERSION1:     "--version">      
| <RELEASE_DATE: "--release-date"> 
| <COPYRIGHT:    "--copyright">    
| <LICENSE:      "--license">    

  /* global options */	
| <LOG_FILE:          "--log-file">           : PATH_SEP2
| <STANDARD_LOG_FILE: "--standard-log-file"> 
| <LOG_BACKUPS:       "--log-backups">        : INTEGER_SEP2
| <LOG:               "--log">                : LOG_SEP

  /* batch */ 
| <BATCH:        "--batch">               : PATH_SEP2
		   
  /* commands */ 
| <USER:              "user">             : USER_OPTS 
| <WORK_GROUP:        "work-group">       : WORK_GROUP_OPTS 
| <PRIVILEGE:         "privilege">        : PRIVILEGE_OPTS 
| <ADMIN:             "admin">            : ADMIN_OPTS
| <RUNTIME:           "runtime">          : RUNTIME_OPTS
| <ARCHIVE_VOLUME:    "archive-volume">   : ARCHIVE_VOLUME_OPTS
| <DEFAULT_TOOLSET:   "default-toolset">  : TOOLSET_OPTS 
| <ACTIVE_TOOLSET:    "active-toolset">   : TOOLSET_OPTS 
| <TOOLSET1:          "toolset">          : TOOLSET_OPTS 
| <LICENSE_KEY1:      "license-key">      : KEY_OPTS 
| <SELECTION_KEY1:    "selection-key">    : KEY_OPTS  
| <JOB_SERVER:        "job-server">       : JOB_SERVER_OPTS
| <EDITOR1:           "editor">           : EDITOR_OPTS
| <ACTION1:           "action">           : ACTION_OPTS
| <COMPARATOR:        "comparator">       : COMPARATOR_OPTS
| <TOOL:              "tool">             : TOOL_OPTS        
| <ARCHIVER:          "archiver">         : ARCHIVER_OPTS        
| <SUFFIX_EDITOR:     "suffix-editor">    : SUFFIX_EDITOR_OPTS
| <VIEW1:             "view">             : VIEW_OPTS
| <WORKING:           "working">          : WORKING_OPTS
| <CHECKED_IN:        "checked-in">       : CHECKED_IN_OPTS
| <NODE:              "node">             : NODE_OPTS

  /* argument end separator */ 
| <AE1: ("\0")+>

  /* errors */ 
| <UNKNOWN_OPTION1:  "-" ("-")? (~["\0","="])*>  : IGNORE_STATE
| <UNKNOWN_COMMAND1: ~["-","\0"] (~["\0"])*>     : IGNORE_STATE
}


<OPTIONS> 
TOKEN :
{
  /* command options */ 
  <MSG:                "--msg">                 : STRING_SEP  
| <PER_SLOT:           "--per-slot">  
| <PER_HOST:           "--per-host">  
| <PER_HOST_SLOT:      "--per-host-slot">
| <MAX_SLOTS:          "--max-slots">           : INTEGER_SEP  
| <MAX_HOSTS:          "--max-hosts">           : INTEGER_SEP  
| <MAX_HOST_SLOTS:     "--max-host-slots">      : INTEGER_SEP  
| <MANAGER:            "--manager">  
| <MEMBER:             "--member">  
| <NOT_MEMBER:         "--not-member">  
| <USER2:              "--user">                : USER_NAME_SEP
| <MASTER_ADMIN:       "--master-admin">    
| <DEVELOPER:          "--developer">    
| <QUEUE_ADMIN:        "--queue-admin">    
| <QUEUE_MANAGER:      "--queue-manager">    
| <NODE_MANAGER:       "--node-manager">    
| <SHUTDOWN_JOBMGRS:   "--shutdown-jobmgrs">       
| <SHUTDOWN_PLUGINMGR: "--shutdown-pluginmgr"> 
| <REMOTE_LOG:               "--remote-log">                : REMOTE_LOG_SEP
| <COLLECTOR_BATCH_SIZE:     "--collector-batch-size">      : INTEGER_SEP
| <DISPATCHER_INTERVAL:      "--dispatcher-interval">       : INTEGER_SEP
| <RESTORE_CLEANUP_INTERVAL: "--restore-cleanup-interval">  : INTEGER_SEP
| <NODE_GC_INTERVAL:         "--node-gc-interval">          : INTEGER_SEP
| <MIN_OVERHEAD:             "--min-overhead">              : INTEGER_SEP  
| <MAX_OVERHEAD:             "--max-overhead">              : INTEGER_SEP  
| <AVG_NODE_SIZE:            "--avg-node-size">             : INTEGER_SEP  
| <PATTERN:            "--pattern">         	: STRING_SEP	      
| <MAX_ARCHIVES:       "--max-archives">    	: INTEGER_SEP	      
| <MIN_SIZE:           "--min-size">        	: BYTE_SIZE_SEP	      
| <ARCHIVER2:          "--archiver">        	: ARCHIVER_NAME_SEP	      
| <AUTO_START:         "--auto-start">	        
| <EXCLUDE_LATEST:     "--exclude-latest">  	: INTEGER_SEP
| <MIN_ARCHIVES:       "--min-archives">    	: INTEGER_SEP
| <CHECKED_IN_VSN:     "--vsn">                 : VSN_NAME_SEP
| <DISABLE:            "--disable">         				      
| <ENABLE:             "--enable"> 
| <SHUTDOWN1:          "--shutdown">  
| <RESERVE:            "--reserve">         	: USER_NAME_SEP           
| <OPEN:               "--open">  	    				      
| <SLOTS:              "--slots">           	: INTEGER_SEP  	      
| <ORDER:              "--order">           	: INTEGER_SEP  	      
| <SEL_SCHEDULE:       "--selection-schedule">  : SCHEDULE_NAME_SEP
| <NO_SEL_SCHEDULE:    "--no-selection-schedule">  	      
| <SEL_GROUP:          "--selection-group">     : GROUP_NAME_SEP
| <NO_SEL_GROUP:       "--no-selection-group">  	      
| <EDITOR2:            "--editor">          	: EDITOR_NAME_SEP 	      
| <VERSION2:           "--version">         	: REVISION_NUMBER_SEP     
| <LATEST:             "--latest"> 	    		    		      
| <AUTHOR:             "--author">          	: USER_NAME_SEP 	      
| <VIEW2:              "--view">            	: VIEW_NAME_SEP 	      
| <SHOW:               "--show">            	: SECTION_SEP   	      
| <HIDE:               "--hide">            	: SECTION_SEP   	      
| <TOOLSET2:           "--toolset">         	: TOOLSET_NAME_SEP	      
| <NO_ACTION:          "--no-action">       				      
| <ACTION2:            "--action">          	: ACTION_NAME_SEP	      
| <ACTION_ENABLED:     "--action-enabled">  	: BOOLEAN_SEP	      
| <PARAM:              "--param">           	: PARAM_SEP 	      
| <NO_PARAM:           "--no-param">        	: LINK_PARAM_SEP 	      
| <SOURCE_PARAM:       "--source-param">    	: SOURCE_PARAM_SEP 	      
| <IGNORE:             "--ignore">          	 			      
| <ABORT:              "--abort">           				      
| <SERIAL:             "--serial">          	 			      
| <SUBDIVIDED:         "--subdivided">          	 			      
| <PARALLEL:           "--parallel">        	   			      
| <BATCH_SIZE:         "--batch-size">      	: INTEGER_SEP	      
| <PRIORITY:           "--priority">        	: INTEGER_SEP	      
| <RAMP_UP:            "--ramp-up">         	: INTEGER_SEP	      
| <MAX_LOAD:           "--max-load">        	: REAL_SEP     	      
| <MIN_MEMORY:         "--min-memory">      	: BYTE_SIZE_SEP	      
| <MIN_DISK:           "--min-disk">        	: BYTE_SIZE_SEP	      
| <LICENSE_KEY2:       "--license-key">     	: KEY_TOGGLE_SEP	      
| <SELECTION_KEY2:     "--selection-key">   	: KEY_TOGGLE_SEP
| <CLONE_SOURCE:       "--clone-source">        : NODE_NAME_SEP
| <REF:                "--ref">             	: LINK_PARAM_SEP	      
| <DEPEND:             "--depend">          	: LINK_PARAM_SEP	      
| <SOURCE:             "--source">          	: LINK_PARAM_SEP	      
| <FSEQ:               "--fseq">            	: FILE_SEQ_SEP	      
| <FILE_PATTERN:       "--file-pattern">    	: FILE_PAT_SEP  	      
| <RENAME_FILES:       "--rename-files">    				      
| <REMOVE_FILES:       "--remove-files">    				      
| <REMOVE_AREA:        "--remove-area">    				      
| <RANGE:              "--range">           	: FRAME_RANGE_SEP	      
| <FRAME:              "--frame">           	: FRAME_NUMBERS_SEP	      
| <INDEX:              "--index">           	: FRAME_INDICES_SEP	      
| <WAIT:               "--wait">					
| <MAJOR:              "--major">					
| <MINOR:              "--minor">					
| <MICRO:              "--micro">					
| <OVERWRITE_ALL:      "--overwrite-all">				
| <KEEP_MODIFIED:      "--keep-modified">				
| <MODIFIABLE:         "--modifiable">				
| <FROZEN_UPSTREAM:    "--frozen-upstream">			
| <ALL_FROZEN:         "--all-frozen">				
| <BRIEF:              "--brief">					
| <UPSTREAM:           "--upstream">				
| <LIGHT:              "--light">				
| <LINK_GRAPH:         "--link-graph">                             
| <GLUE:               "--glue">
| <NODE_OPT:           "--node">                : NODE_NAME_SEP
| <FROM:               "--from">                : DATE_SEP 
| <UNTIL:              "--until">               : DATE_SEP 

  /* argument end separator */ 
| <AE2:               (["\0"])+>   

  /* errors */ 
| <UNKNOWN_OPTION2:   "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN_COMMAND2:  ~["-","\0"] (~["\0"])*>    : IGNORE_STATE   
}


/* common states */ 
<IGNORE_STATE> 
TOKEN :
{
  <IGNORED: (~[])+>
}


/* boolean arguments */ 
<BOOLEAN_SEP> 
TOKEN :
{
  <EQ1:                   "=">   : BOOLEAN_STATE
| <MISSING_BOOLEAN_ARG: ~["="]>  : IGNORE_STATE
}

<BOOLEAN_STATE> 
TOKEN :
{
  <TRUE:            ["t","T"] ["r","R"] ["u","U"] ["e","E"]>            : OPTIONS
| <FALSE:           ["f","F"] ["a","A"] ["l","L"] ["s","S"] ["e","E"]>  : OPTIONS
| <MISSING_BOOLEAN: ["\0"]>                                             : IGNORE_STATE
| <ILLEGAL_BOOLEAN: (~["\0"])+>                                         : IGNORE_STATE
}


/* integer arguments */ 
<INTEGER_SEP> 
TOKEN :
{
  <EQ2:                   "=">   : INTEGER_STATE
| <MISSING_INTEGER_ARG: ~["="]>  : IGNORE_STATE
}

<INTEGER_STATE> 
TOKEN :
{
  <INTEGER:         (["0"-"9"])+>    : OPTIONS
| <MISSING_INTEGER: ["\0"]>          : IGNORE_STATE
| <ILLEGAL_INTEGER: (~["\0"])+>      : IGNORE_STATE
} 

<INTEGER_SEP2> 
TOKEN :
{
  <EQ3:                    "=">   : INTEGER_STATE2
| <MISSING_INTEGER_ARG2: ~["="]>  : IGNORE_STATE
}

<INTEGER_STATE2> 
TOKEN :
{
  <INTEGER2:         (["0"-"9"])+>    : DEFAULT
| <MISSING_INTEGER2: ["\0"]>          : IGNORE_STATE
| <ILLEGAL_INTEGER2: (~["\0"])+>      : IGNORE_STATE
}



/* port number arguments */ 
<PORT_NUMBER_SEP> 
TOKEN :
{
  <EQ4:                       "=">   : PORT_NUMBER_STATE
| <MISSING_PORT_NUMBER_ARG: ~["="]>  : IGNORE_STATE
}

<PORT_NUMBER_STATE> 
TOKEN :
{
  <PORT_NUMBER:         (["0"-"9"])+>    : DEFAULT
| <MISSING_PORT_NUMBER: ["\0"]>          : IGNORE_STATE
| <ILLEGAL_PORT_NUMBER: (~["\0"])+>      : IGNORE_STATE
}


/* byte size arguments */ 
<BYTE_SIZE_SEP> 
TOKEN :
{
  <EQ5:                     "=">   : BYTE_SIZE_STATE
| <MISSING_BYTE_SIZE_ARG: ~["="]>  : IGNORE_STATE
}

<BYTE_SIZE_STATE> 
TOKEN :
{
  <BYTE_SIZE:         (["0"-"9"])+>   
| <KILO:              ["k","K"]>                           : OPTIONS
| <MEGA:              ["m","M"]>                           : OPTIONS
| <GIGA:              ["g","G"]>                           : OPTIONS
| <AE3:               ["\0"]>                              : OPTIONS
| <ILLEGAL_BYTE_SIZE: (~["k","K","m","M","g","G","\0"])+>  : IGNORE_STATE
}


/* real arguments */ 
<REAL_SEP> 
TOKEN :
{
  <EQ6:                "=">   : REAL_STATE
| <MISSING_REAL_ARG: ~["="]>  : IGNORE_STATE
}

<REAL_STATE> 
TOKEN :
{
  <REAL:         ((["0"-"9"])+ "." (["0"-"9"])*) | 
		 ((["0"-"9"])* "." (["0"-"9"])+)>    : OPTIONS
| <MISSING_REAL: ["\0"]>                             : IGNORE_STATE
| <ILLEGAL_REAL: (~["\0"])+>                         : IGNORE_STATE
}


/* string arguments */   
<STRING_SEP> 
TOKEN :
{
  <EQ7:                  "=">   : STRING_STATE
| <MISSING_STRING_ARG: ~["="]>  : IGNORE_STATE
}

<STRING_STATE>
TOKEN :
{
  <STRING:         (~["\0"])*>  : OPTIONS
| <EMPTY_STRING:   "\0">        : OPTIONS
}


/* filesystem path arguments */ 
<PATH_SEP> 
TOKEN :
{
  <EQ8:                "=">   : PATH_STATE
| <MISSING_PATH_ARG: ~["="]>  : IGNORE_STATE
}

<PATH_STATE> 
TOKEN :
{
  <PATH_ARG:       ("/")* ("../")* <PATH_ARG_COMP> 
		     ("/" (".." | (<PATH_ARG_COMP>)+)?)*>      : OPTIONS
| <#PATH_ARG_COMP: (["a"-"z","A"-"Z","0"-"9","_","-","."])+>
| <MISSING_PATH:   ["\0"]>                                     : IGNORE_STATE
| <ILLEGAL_PATH:   (~["\0"])+>                                 : IGNORE_STATE
}

<PATH_SEP2>
TOKEN :
{
  <EQ34:                 "=">   : PATH_STATE2
| <MISSING_PATH_ARG2:  ~["="]>  : IGNORE_STATE
}

<PATH_STATE2> 
TOKEN :
{
  <PATH_ARG2:       ("/")* ("../")* <PATH_ARG_COMP2> 
		      ("/" (".." | (<PATH_ARG_COMP2>)+)?)*>     : DEFAULT
| <#PATH_ARG_COMP2: (["a"-"z","A"-"Z","0"-"9","_","-","."])+>
| <MISSING_PATH2:   ["\0"]>                                     : IGNORE_STATE
| <ILLEGAL_PATH2:   (~["\0"])+>                                 : IGNORE_STATE
}


/* hostname arguments */ 
<HOST_NAME_SEP> 
TOKEN :
{
  <EQ9:                    "=">    : HOST_NAME_STATE
| <MISSING_HOST_NAME_ARG: ~["="]>  : IGNORE_STATE
}

<HOST_NAME_STATE> 
TOKEN :
{
  <HOST_NAME:         ((["a"-"z","A"-"Z","0"-"9","-"])+ 
		      ("." (["a"-"z","A"-"Z","0"-"9","-"])+)*)>    : OPTIONS
| <MISSING_HOST_NAME: ["\0"]>                                      : IGNORE_STATE
| <ILLEGAL_HOST_NAME: (~["\0"])+>                                  : IGNORE_STATE
}  

<HOST_NAME_SEP2> 
TOKEN :
{
  <EQ10:                    "=">    : HOST_NAME_STATE2
| <MISSING_HOST_NAME_ARG2: ~["="]>  : IGNORE_STATE
}

<HOST_NAME_STATE2> 
TOKEN :
{
  <HOST_NAME2:          ((["a"-"z","A"-"Z","0"-"9","-"])+ 
		        ("." (["a"-"z","A"-"Z","0"-"9","-"])+)*)>    : DEFAULT
| <MISSING_HOST_NAME2:  ["\0"]>                                      : IGNORE_STATE
| <ILLEGAL_HOST_NAME2:  (~["\0"])+>                                  : IGNORE_STATE
}


/* node name arguments */ 
<NODE_NAME_SEP> 
TOKEN :
{
  <EQ11:                    "=">   : NODE_NAME_STATE
| <MISSING_NODE_NAME_ARG: ~["="]>  : IGNORE_STATE
}

<NODE_NAME_STATE> 
TOKEN :
{
  <NODE_NAME:           ("/" (["a"-"z","A"-"Z","0"-"9","-","_"])+)* 
			("/" ["a"-"z","A"-"Z"] 
		          (["a"-"z","A"-"Z","0"-"9","_","-"])*)+>  : OPTIONS
| <MISSING_NODE_NAME:   ["\0"]>                                    : IGNORE_STATE
| <ILLEGAL_NODE_NAME:   (~["\0"])+>                                : IGNORE_STATE
}


/* toolset name arguments */ 
<TOOLSET_NAME_SEP> 
TOKEN :
{
  <EQ12:                       "=">   : TOOLSET_NAME_STATE
| <MISSING_TOOLSET_NAME_ARG: ~["="]>  : IGNORE_STATE
}

<TOOLSET_NAME_STATE> 
TOKEN :
{
  <TOOLSET_NAME:           (["a"-"z","A"-"Z"]) 
		           (["a"-"z","A"-"Z","0"-"9","_","-"])*>  
| <AE4:                    ["\0"]>                                   : OPTIONS
| <ILLEGAL_TOOLSET_NAME:   (~["\0"])+>                               : IGNORE_STATE
}


/* user name arguments */ 
<USER_NAME_SEP> 
TOKEN :
{
  <EQ13:                    "=">   : USER_NAME_STATE
| <MISSING_USER_NAME_ARG: ~["="]>  : IGNORE_STATE
}

<USER_NAME_STATE> 
TOKEN :
{
  <USER_NAME:           (["a"-"z","A"-"Z"]) 
	   	          (["a"-"z","A"-"Z","0"-"9","_","-"])+>  
| <AE5:                 ["\0"]>                                   : OPTIONS
| <ILLEGAL_USER_NAME:   (~["\0"])+>                               : IGNORE_STATE
}


/* work group name arguments */ 
<WORK_GROUP_NAME_SEP> 
TOKEN :
{
  <EQ41:                          "=">   : WORK_GROUP_NAME_STATE
| <MISSING_WORK_GROUP_NAME_ARG: ~["="]>  : IGNORE_STATE
}

<WORK_GROUP_NAME_STATE> 
TOKEN :
{
  <WORK_GROUP_NAME:           (["a"-"z","A"-"Z"]) 
	   	                (["a"-"z","A"-"Z","0"-"9","_","-"])+>  
| <AE54:                      ["\0"]>                                   : OPTIONS
| <ILLEGAL_WORK_GROUP_NAME:   (~["\0"])+>                               : IGNORE_STATE
}


/* schedule arguments */ 
<SCHEDULE_NAME_SEP> 
TOKEN :
{
  <EQ14:                   "=">   : SCHEDULE_NAME_STATE
| <MISSING_SCHEDULE_ARG: ~["="]>  : IGNORE_STATE
}

<SCHEDULE_NAME_STATE> 
TOKEN :
{
  <SCHEDULE_NAME:      (["a"-"z","A"-"Z"]) 
	               (["a"-"z","A"-"Z","0"-"9","_","-"])+>   
| <AE6:                ["\0"]>                                  : OPTIONS
| <ILLEGAL_SCHEDULE:   (~[":","\0"])+>                          : IGNORE_STATE
}

/* group arguments */ 
<GROUP_NAME_SEP> 
TOKEN :
{
  <EQ15:                "=">   : GROUP_NAME_STATE
| <MISSING_GROUP_ARG: ~["="]>  : IGNORE_STATE
}

<GROUP_NAME_STATE> 
TOKEN :
{
  <GROUP_NAME:      (["a"-"z","A"-"Z"]) 
	              (["a"-"z","A"-"Z","0"-"9","_","-"])+>   
| <AE7:             ["\0"]>                                  : OPTIONS
| <ILLEGAL_GROUP:   (~[":","\0"])+>                          : IGNORE_STATE
}

/* key name arguments */ 
<KEY_NAME_SEP> 
TOKEN :
{
  <EQ40:                   "=">   : KEY_NAME_STATE
| <MISSING_KEY_NAME_ARG: ~["="]>  : IGNORE_STATE
}

<KEY_NAME_STATE> 
TOKEN :
{
  <KEY_NAME1:          (["a"-"z","A"-"Z"]) 
		         (["a"-"z","A"-"Z","0"-"9","_","-"])+>  
| <AE51:                ["\0"]>                                   : OPTIONS
| <ILLEGAL_KEY_NAME:   (~["\0"])+>                               : IGNORE_STATE
}

/* key toggle arguments */ 
<KEY_TOGGLE_SEP> 
TOKEN :
{
  <EQ16:                     "=">   : KEY_TOGGLE_STATE
| <MISSING_KEY_TOGGLE_ARG: ~["="]>  : IGNORE_STATE
}

<KEY_TOGGLE_STATE> 
TOKEN :
{
  <KEY_NAME2:            (["a"-"z","A"-"Z"]) 
		          (["a"-"z","A"-"Z","0"-"9","_","-"])+>  
| <COLON2:               ":">                                      : BOOLEAN_STATE
| <AE8:                  ["\0"]>                                   : OPTIONS
| <ILLEGAL_KEY_TOGGLE:   (~[":","\0"])+>                           : IGNORE_STATE
}


/* filename suffix arguments */ 
<SUFFIX_SEP> 
TOKEN :
{
  <EQ17:                 "=">   : SUFFIX_STATE
| <MISSING_SUFFIX_ARG: ~["="]>  : IGNORE_STATE
}

<SUFFIX_STATE> 
TOKEN :
{
  <SUFFIX1:          (["a"-"z","A"-"Z","0"-"9"])+>  
| <AE9:              ["\0"]>                          : OPTIONS
| <ILLEGAL_SUFFIX:   (~["\0"])+>                      : IGNORE_STATE
}


/* editor arguments */ 
<EDITOR_NAME_SEP> 
TOKEN :
{
  <EQ18:                 "=">   : EDITOR_NAME_STATE
| <MISSING_EDITOR_ARG: ~["="]>  : IGNORE_STATE
}

<EDITOR_NAME_STATE> 
TOKEN :
{
  <EDITOR_NAME:      (["a"-"z","A"-"Z"]) 
	               (["a"-"z","A"-"Z","0"-"9","_","-"])+>   
| <COLON3:           ":">                                     : REVISION_NUMBER_STATE2 
| <COMMA11:          ",">                                     : VENDOR_NAME_STATE 
| <AE10:             ["\0"]>                                  : OPTIONS
| <ILLEGAL_EDITOR:   (~[":",",","\0"])+>                      : IGNORE_STATE
}


/* action arguments */ 
<ACTION_NAME_SEP> 
TOKEN :
{
  <EQ19:                 "=">   : ACTION_NAME_STATE
| <MISSING_ACTION_ARG: ~["="]>  : IGNORE_STATE
}

<ACTION_NAME_STATE> 
TOKEN :
{
  <ACTION_NAME:      (["a"-"z","A"-"Z"]) 
	               (["a"-"z","A"-"Z","0"-"9","_","-"])+>   
| <COLON4:           ":">                                     : REVISION_NUMBER_STATE2 
| <COMMA12:          ",">                                     : VENDOR_NAME_STATE 
| <AE11:             ["\0"]>                                  : OPTIONS
| <ILLEGAL_ACTION:   (~[":",",","\0"])+>                      : IGNORE_STATE
}


/* comparator arguments */ 
<COMPARATOR_NAME_SEP> 
TOKEN :
{
  <EQ20:                     "=">   : COMPARATOR_NAME_STATE
| <MISSING_COMPARATOR_ARG: ~["="]>  : IGNORE_STATE
}

<COMPARATOR_NAME_STATE> 
TOKEN :
{
  <COMPARATOR_NAME:      (["a"-"z","A"-"Z"]) 
	                   (["a"-"z","A"-"Z","0"-"9","_","-"])+>   
| <COLON5:               ":">                                     : REVISION_NUMBER_STATE2 
| <COMMA13:              ",">                                     : VENDOR_NAME_STATE 
| <AE12:                 ["\0"]>                                  : OPTIONS
| <ILLEGAL_COMPARATOR:   (~[":",",","\0"])+>                      : IGNORE_STATE
}


/* tool arguments */ 
<TOOL_NAME_SEP> 
TOKEN :
{
  <EQ35:               "=">   : TOOL_NAME_STATE
| <MISSING_TOOL_ARG: ~["="]>  : IGNORE_STATE
}

<TOOL_NAME_STATE> 
TOKEN :
{
  <TOOL_NAME:      (["a"-"z","A"-"Z"]) 
	             (["a"-"z","A"-"Z","0"-"9","_","-"])+>   
| <COLON8:         ":">                                     : REVISION_NUMBER_STATE2 
| <COMMA14:        ",">                                     : VENDOR_NAME_STATE 
| <AE42:           ["\0"]>                                  : OPTIONS
| <ILLEGAL_TOOL:   (~[":",",","\0"])+>                      : IGNORE_STATE
}


/* archiver arguments */ 
<ARCHIVER_NAME_SEP> 
TOKEN :
{
  <EQ36:                   "=">     : ARCHIVER_NAME_STATE
| <MISSING_ARCHIVER_ARG: ~["="]>    : IGNORE_STATE
}

<ARCHIVER_NAME_STATE> 
TOKEN :
{
  <ARCHIVER_NAME:      (["a"-"z","A"-"Z"]) 
	                 (["a"-"z","A"-"Z","0"-"9","_","-"])+>   
| <COLON9:             ":">                                     : REVISION_NUMBER_STATE2 
| <COMMA15:            ",">                                     : VENDOR_NAME_STATE 
| <AE43:               ["\0"]>                                  : OPTIONS
| <ILLEGAL_ARCHIVER:   (~[":",",","\0"])+>                      : IGNORE_STATE
}


/* archive prefix arguments */ 
<ARCHIVE_PREFIX_SEP> 
TOKEN :
{
  <EQ38:                         "=">   : ARCHIVE_PREFIX_STATE
| <MISSING_ARCHIVE_PREFIX_ARG: ~["="]>  : IGNORE_STATE
}

<ARCHIVE_PREFIX_STATE> 
TOKEN :
{
  <ARCHIVE_PREFIX:          (["a"-"z","A"-"Z"]) 
	                      (["a"-"z","A"-"Z","0"-"9","_","-"])+>  : OPTIONS
| <ILLEGAL_ARCHIVE_PREFIX:  (~["\0"])+>                              : IGNORE_STATE
}


/* checked-in version arguments */  
<VSN_NAME_SEP> 
TOKEN :
{
  <EQ37:              "=">     : VSN_NAME_STATE
| <MISSING_VSN_ARG: ~["="]>    : IGNORE_STATE
}

<VSN_NAME_STATE> 
TOKEN :
{
  <VSN_NAME:      ("/" (["a"-"z","A"-"Z","0"-"9","-","_"])+)* 
		    ("/" ["a"-"z","A"-"Z"] 
		     (["a"-"z","A"-"Z","0"-"9","_","-"])*)+>  
| <COLON10:       ":">                                        : REVISION_NUMBER_STATE
| <AE44:          ["\0"]>                                     : OPTIONS
| <ILLEGAL_VSN:   (~[":","\0"])+>                             : IGNORE_STATE
}


/* revision number arguments */ 
<REVISION_NUMBER_SEP> 
TOKEN :
{
  <EQ21:                          "=">   : REVISION_NUMBER_STATE
| <MISSING_REVISION_NUMBER_ARG: ~["="]>  : IGNORE_STATE
}

<REVISION_NUMBER_STATE> 
TOKEN :
{
  <REVISION_NUMBER:            (<IREVNUM> "." <REVNUM> "." <REVNUM>)>  
| <#IREVNUM:                   ["1"-"9"] (["0"-"9"])*>
| <#REVNUM:                    (["0"-"9"])+>
| <AE13:                       ["\0"]>                       : OPTIONS
| <ILLEGAL_REVISION_NUMBER:    (~["\0"])+>                   : IGNORE_STATE
}

<REVISION_NUMBER_STATE2> 
TOKEN :
{
  <REVISION_NUMBER2:           (<IREVNUM2> "." <REVNUM2> "." <REVNUM2>)>  
| <#IREVNUM2:                  ["1"-"9"] (["0"-"9"])*>
| <#REVNUM2:                   (["0"-"9"])+>
| <COMMA16:                    ",">                          : VENDOR_NAME_STATE 
| <AE50:                       ["\0"]>                       : OPTIONS
| <ILLEGAL_REVISION_NUMBER2:   (~[",","\0"])+>               : IGNORE_STATE
}


/* vendor name arguments */ 
<VENDOR_NAME_STATE> 
TOKEN :
{
  <VENDOR_NAME:      (["a"-"z","A"-"Z"]) 
	               (["a"-"z","A"-"Z","0"-"9","_","-"])+>  
| <AE49:             ["\0"]>                                  : OPTIONS
| <ILLEGAL_VENDOR:   (~["\0"])+>                              : IGNORE_STATE
}


/* view name arguments */ 
<VIEW_NAME_SEP> 
TOKEN :
{
  <EQ22:               "=">     : VIEW_NAME_STATE
| <MISSING_VIEW_ARG: ~["="]>    : IGNORE_STATE
}

<VIEW_NAME_STATE> 
TOKEN :
{
  <VIEW_NAME:      (["a"-"z","A"-"Z"]) 
	             (["a"-"z","A"-"Z","0"-"9","_","-"])+>   
| <AE14:           ["\0"]>                                  : OPTIONS
| <ILLEGAL_VIEW:   (~["\0"])+>                              : IGNORE_STATE
}


/* param name arguments */ 
<PARAM_SEP> 
TOKEN :
{
  <EQ23:                "=">      : PARAM_STATE
| <MISSING_PARAM_ARG: ~["="]>    : IGNORE_STATE
}

<PARAM_STATE> 
TOKEN :
{
  <PARAM_NAME:      (["a"-"z","A"-"Z"]) 
	             (["a"-"z","A"-"Z","0"-"9","_","-"])+>   
| <COLON6:          ":">                                    : PARAM_VALUE_STATE
| <AE15:            ["\0"]>                                 : OPTIONS
| <ILLEGAL_PARAM:   (~[":","\0"])+>                         : IGNORE_STATE
}

<PARAM_VALUE_STATE> 
TOKEN :
{
  <PARAM_VALUE:         (~["\0"])*>  : OPTIONS
| <EMPTY_PARAM_VALUE:   "\0">        : OPTIONS
}


/* source param arguments */ 
<SOURCE_PARAM_SEP> 
TOKEN :
{
  <EQ24:                       "=">   : SOURCE_PARAM_STATE
| <MISSING_SOURCE_PARAM_ARG: ~["="]>  : IGNORE_STATE
}

<SOURCE_PARAM_STATE> 
TOKEN :
{
  <SOURCE_NAME:         ("/" (["a"-"z","A"-"Z","0"-"9","_","-"])+)* 
			("/" ["a"-"z","A"-"Z"] 
		          (["a"-"z","A"-"Z","0"-"9","_","-"])*)+> 
| <COMMA1:              ",">                                       : PARAM_STATE
| <ILLEGAL_SOURCE_NAME: (~[","])+>                                 : IGNORE_STATE
}


/* link param arguments */ 
<LINK_PARAM_SEP> 
TOKEN :
{
  <EQ25:                     "=">    : LINK_PARAM_STATE
| <MISSING_LINK_PARAM_ARG: ~["="]>  : IGNORE_STATE
}

<LINK_PARAM_STATE> 
TOKEN :
{
  <LINK_NAME:         ("/" (["a"-"z","A"-"Z","0"-"9","_","-"])+)* 
		      ("/" ["a"-"z","A"-"Z"] 
		        (["a"-"z","A"-"Z","0"-"9","_","-"])*)+> 
| <COMMA2:            ",">                                       : LINK_RELATION_STATE
| <AE16:              "\0">                                      : OPTIONS
| <ILLEGAL_LINK_NAME: (~[",","\0"])+>                            : IGNORE_STATE
}

<LINK_RELATION_STATE> 
TOKEN :
{
  <LINK_ALL:          ["a","A"] ["l","L"] ["l","L"]>  : OPTIONS
| <OFFSET:            (["0"-"9"])+>                   : OPTIONS
| <MISSING_RELATION:  ["\0"]>                         : IGNORE_STATE
| <ILLEGAL_RELATION:  (~["\0"])+>                     : IGNORE_STATE
}
  

/* file sequence arguments */ 
<FILE_SEQ_SEP> 
TOKEN :
{
  <EQ26:                   "=">   : FILE_SEQ_STATE
| <MISSING_FILE_SEQ_ARG: ~["="]>  : IGNORE_STATE
}

<FILE_SEQ_STATE> 
TOKEN :
{
  <PREFIX:            (["a"-"z","A"-"Z"] 
		        (["a"-"z","A"-"Z","0"-"9","_","-"])*)+>  
| <DOT1:              ".">                                       : FILE_SEQ_STATE2
| <COMMA3:            ",">                                       : FRAME_RANGE_STATE
| <AE17:              "\0">                                      : OPTIONS
| <ILLEGAL_FILE_SEQ:  (~[".",",","\0"])+>                        : IGNORE_STATE
}

<FILE_SEQ_STATE2> 
TOKEN :
{
  <SUFFIX2:           (["a"-"z","A"-"Z","0"-"9"])+>  
| <DOT2:              ".">                                       
| <AT1:               "@"> 
| <POUND1:            "#"> 
| <COMMA4:            ",">                          : FRAME_RANGE_STATE
| <AE18:              "\0">                         : OPTIONS
| <ILLEGAL_FILE_SEQ2: (~[".","@","#",",","\0"])+>   : IGNORE_STATE
}


/* file pattern arguments */ 
<FILE_PAT_SEP> 
TOKEN :
{
  <EQ39:                   "=">   : FILE_PAT_STATE
| <MISSING_FILE_PAT_ARG: ~["="]>  : IGNORE_STATE
}

<FILE_PAT_STATE> 
TOKEN :
{
  <FILE_PAT_PREFIX:   ("/" (["a"-"z","A"-"Z","0"-"9","-","_"])+)* 
			("/" ["a"-"z","A"-"Z"] 
		          (["a"-"z","A"-"Z","0"-"9","_","-"])*)+>  
| <DOT3:              ".">                                       : FILE_PAT_STATE2
| <AE47:              "\0">                                      : OPTIONS
| <ILLEGAL_FILE_PAT:  (~[".",",","\0"])+>                        : IGNORE_STATE
}

<FILE_PAT_STATE2> 
TOKEN :
{
  <FILE_PAT_SUFFIX:   (["a"-"z","A"-"Z","0"-"9"])+>  
| <DOT4:              ".">                                       
| <AT2:               "@"> 
| <POUND2:            "#"> 
| <AE48:              "\0">                         : OPTIONS
| <ILLEGAL_FILE_PAT2: (~[".","@","#",",","\0"])+>   : IGNORE_STATE
}

/* frame range arguments */ 
<FRAME_RANGE_SEP> 
TOKEN :
{
  <EQ27:                      "=">   : FRAME_RANGE_STATE
| <MISSING_FRAME_RANGE_ARG: ~["="]>  : IGNORE_STATE
}

<FRAME_RANGE_STATE> 
TOKEN :
{
  <FRAME_NUMBER:         (["0"-"9"])+>   
| <DASH1:                "-"> 
| <BY:                   "x"> 
| <AE19:                 "\0">           : OPTIONS
| <ILLEGAL_FRAME_RANGE:  (~["-","x","\0"])+>     : IGNORE_STATE
}

  
/* frame numbers arguments */ 
<FRAME_NUMBERS_SEP> 
TOKEN :
{
  <EQ28:                        "=">   : FRAME_NUMBERS_STATE
| <MISSING_FRAME_NUMBERS_ARG: ~["="]>  : IGNORE_STATE
}

<FRAME_NUMBERS_STATE> 
TOKEN :
{
  <FRAME_NUMBER2:          (["0"-"9"])+>   
| <DASH2:                  "-"> 
| <COMMA5:                 ","> 
| <AE20:                   "\0">                  : OPTIONS
| <ILLEGAL_FRAME_NUMBERS:  (~["-",",","\0"])+>     : IGNORE_STATE
}
  

/* frame indices arguments */ 
<FRAME_INDICES_SEP> 
TOKEN :
{
  <EQ29:                        "=">   : FRAME_INDICES_STATE
| <MISSING_FRAME_INDICES_ARG: ~["="]>  : IGNORE_STATE
}

<FRAME_INDICES_STATE> 
TOKEN :
{
  <FRAME_INDEX:            (["0"-"9"])+>   
| <DASH3:                  "-"> 
| <COMMA6:                 ","> 
| <AE21:                   "\0">                  : OPTIONS
| <ILLEGAL_FRAME_INDICES:  (~["-",",","\0"])+>     : IGNORE_STATE
}
  

/* hide/show section arguments */ 
<SECTION_SEP> 
TOKEN :
{
  <EQ30:                  "=">   : SECTION_STATE
| <MISSING_SECTION_ARG: ~["="]>  : IGNORE_STATE
}

<SECTION_STATE> 
TOKEN :
{
  <ALL:              "all"> 
| <VSN:              "vsn"> 
| <PROP:             "prop"> 
| <ACT:              "act"> 
| <JREQ:             "jreq"> 
| <KEY:              "key"> 
| <LINK:             "link"> 
| <DLINK:            "dlink"> 
| <TIME:             "time"> 
| <PROC:             "proc"> 
| <WKDIR:            "wkdir"> 
| <CMD:              "cmd"> 
| <ENV:              "env"> 
| <OUT:              "out"> 
| <ERR:              "err"> 
| <FILE:             "file"> 
| <ARCH:             "arch"> 
| <COMMA7:           ","> 
| <AE22:             "\0">               : OPTIONS
| <ILLEGAL_SECTION:  (~[",","\0"])+>     : IGNORE_STATE
}


/* job group arguments */ 
<JOB_GROUP_ID_SEP>  
TOKEN :
{
  <EQ31:                       "=">   : JOB_GROUP_ID_STATE
| <MISSING_JOB_GROUP_ID_ARG: ~["="]>  : IGNORE_STATE
}

<JOB_GROUP_ID_STATE> 
TOKEN :
{
  <JOB_GROUP_ID:          (["0"-"9"])+> 
| <COMMA8:                ","> 
| <AE23:                  "\0">             : OPTIONS
| <ILLEGAL_JOB_GROUP_ID:  (~[",","\0"])+>   : IGNORE_STATE
}

/* job arguments */ 
<JOB_ID_SEP>  
TOKEN :
{
  <EQ32:                 "=">   : JOB_ID_STATE
| <MISSING_JOB_ID_ARG: ~["="]>  : IGNORE_STATE
}

<JOB_ID_STATE> 
TOKEN :
{
  <JOB_ID:          (["0"-"9"])+> 
| <COMMA9:          ","> 
| <AE24:            "\0">             : OPTIONS
| <ILLEGAL_JOB_ID:  (~[",","\0"])+>   : IGNORE_STATE
}


/* date arguments */ 
<DATE_SEP>   
TOKEN :
{
  <EQ43:               "=">   : DATE_STATE
| <MISSING_DATE_ARG: ~["="]>  : IGNORE_STATE
}

<DATE_STATE> 
TOKEN :
{
  <STAMP_FOUR:    (["0"-"9"] ["0"-"9"] ["0"-"9"] ["0"-"9"])> 
| <STAMP_TWO:     (["0"-"9"] ["0"-"9"])> 
| <DASH4:         "-"> 
| <COMMA18:       ","> 
| <COLON11:       ":"> 
| <AE57:          "\0">                     : OPTIONS
| <ILLEGAL_DATE:  (~["-",",",":","\0"])+>   : IGNORE_STATE
}


/*------------------------------------------------------------------------------------------*/

/* --log arguments */ 
<LOG_SEP> 
TOKEN :
{
  <EQ33:               "=">  : LOG_TYPE
| <MISSING_LOG_ARG: ~["="]>  : IGNORE_STATE
}

<LOG_TYPE> 
TOKEN :
{
  <LOG_ALL:          "all">       
| <LOG_ARG: 	     "arg">        
| <LOG_SUM: 	     "sum">        
| <LOG_GLU: 	     "glu">        
| <LOG_JOB: 	     "job">        
| <LOG_MEM: 	     "mem">        
| <LOG_NET: 	     "net">        
| <LOG_OPS: 	     "ops">        
| <LOG_PLG: 	     "plg">        
| <LOG_SUB: 	     "sub">        
| <LOG_TEX: 	     "tex">        
| <LOG_DSP: 	     "dsp">        
| <LOG_COL: 	     "col">        
| <LOG_SCH: 	     "sch">        
| <LOG_EXT: 	     "ext">
| <COLON7:  	     ":">        : LOG_LEVEL  
| <ILLEGAL_LOG_TYPE: (~[":"])+>  : IGNORE_STATE    
}

<LOG_LEVEL> 
TOKEN : 
{
  <SEVERE:  	      "severe">  
| <WARNING: 	      "warning"> 
| <INFO:    	      "info">    
| <FINE:    	      "fine">    
| <FINER :  	      "finer">   
| <FINEST:    	      "finest">  
| <COMMA10:  	      ",">             : LOG_TYPE
| <AE25:              (["\0"])+>       : DEFAULT
| <ILLEGAL_LOG_LEVEL: (~["\0",","])+>  : IGNORE_STATE
}


/*------------------------------------------------------------------------------------------*/

/* --remote-log arguments */ 
<REMOTE_LOG_SEP> 
TOKEN :
{
  <EQ42:                   "=">     : REMOTE_LOG_TYPE
| <MISSING_REMOTE_LOG_ARG: ~["="]>  : IGNORE_STATE
}

<REMOTE_LOG_TYPE> 
TOKEN :
{
  <REMOTE_LOG_ALL:           "all">       
| <REMOTE_LOG_ARG: 	     "arg">        
| <REMOTE_LOG_SUM: 	     "sum">        
| <REMOTE_LOG_GLU: 	     "glu">        
| <REMOTE_LOG_JOB: 	     "job">        
| <REMOTE_LOG_MEM: 	     "mem">        
| <REMOTE_LOG_NET: 	     "net">        
| <REMOTE_LOG_OPS: 	     "ops">        
| <REMOTE_LOG_PLG: 	     "plg">        
| <REMOTE_LOG_SUB: 	     "sub">        
| <REMOTE_LOG_TEX: 	     "tex">        
| <REMOTE_LOG_DSP: 	     "dsp">        
| <REMOTE_LOG_COL: 	     "col">        
| <REMOTE_LOG_SCH: 	     "sch">        
| <REMOTE_LOG_EXT: 	     "ext">
| <COLON1:  	             ":">       : REMOTE_LOG_LEVEL  
| <ILLEGAL_REMOTE_LOG_TYPE: (~[":"])+>  : IGNORE_STATE    
}

<REMOTE_LOG_LEVEL> 
TOKEN : 
{
  <REMOTE_SEVERE:            "severe">  
| <REMOTE_WARNING:           "warning"> 
| <REMOTE_INFO:              "info">    
| <REMOTE_FINE:              "fine">    
| <REMOTE_FINER :            "finer">   
| <REMOTE_FINEST:            "finest">  
| <COMMA17:  	             ",">             : REMOTE_LOG_TYPE
| <AE56:                     (["\0"])+>       : OPTIONS
| <ILLEGAL_REMOTE_LOG_LEVEL: (~["\0",","])+>  : IGNORE_STATE
}


/*------------------------------------------------------------------------------------------*/

/* user command options */ 
<USER_OPTS> 
TOKEN :
{
  <USER_GET:          "--get">                   : OPTIONS
| <USER_ADD:          "--add">                   : USER_NAME_SEP 
| <USER_REMOVE:       "--remove">                : USER_NAME_SEP 
| <AE52:              ["\0"]>  
| <UNKNOWN_OPTION21:  "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN21:         ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}

/* work-group command options */ 
<WORK_GROUP_OPTS> 
TOKEN :
{
  <WORK_GROUP_GET:           "--get">                   : OPTIONS
| <WORK_GROUP_GET_INFO:      "--get-info">              : WORK_GROUP_NAME_SEP  
| <WORK_GROUP_GET_INFO_ALL:  "--get-info-all">          : OPTIONS 
| <WORK_GROUP_ADD:           "--add">                   : WORK_GROUP_NAME_SEP 
| <WORK_GROUP_REMOVE:        "--remove">                : WORK_GROUP_NAME_SEP 
| <WORK_GROUP_SET:           "--set">                   : WORK_GROUP_NAME_SEP 
| <AE53:                     ["\0"]>  
| <UNKNOWN_OPTION22:         "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN22:                ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}

/* privileged command options */ 
<PRIVILEGE_OPTS> 
TOKEN :
{
  <PRIVILEGE_GET_INFO:      "--get-info">              : USER_NAME_SEP 
| <PRIVILEGE_GET_INFO_ALL:  "--get-info-all">          : OPTIONS 
| <PRIVILEGE_GRANT:         "--grant">                 : USER_NAME_SEP
| <PRIVILEGE_REVOKE:        "--revoke">                : USER_NAME_SEP
| <AE26:                    ["\0"]>  
| <UNKNOWN_OPTION3:         "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN3:                ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}

/* admin command options */ 
<ADMIN_OPTS>
TOKEN :
{
  <SHUTDOWN2:          "--shutdown">  : OPTIONS    	 
| <BACKUP:    	       "--backup">    : PATH_SEP		 
| <ARCHIVE:   	       "--archive">   : ARCHIVE_PREFIX_SEP
| <OFFLINE:   	       "--offline">   : OPTIONS		 
| <RESTORE:   	       "--restore">   : ARCHIVE_PREFIX_SEP
| <AE45:               ["\0"]>   
| <UNKNOWN_OPTION19:   "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN19:          ~["-","\0"] (~["\0"])*>    : IGNORE_STATE   
}


/* runtime command options */ 
<RUNTIME_OPTS>
TOKEN :
{  
  <SET_MASTER_RT:      "--set-master"> : OPTIONS     
| <SET_QUEUE_RT:       "--set-queue">  : OPTIONS  
| <GET_MASTER_RT:      "--get-master"> : OPTIONS     
| <GET_QUEUE_RT:       "--get-queue">  : OPTIONS  
| <AE55:               ["\0"]>   
| <UNKNOWN_OPTION23:   "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN23:          ~["-","\0"] (~["\0"])*>    : IGNORE_STATE   
}


/* toolset command options */ 
<ARCHIVE_VOLUME_OPTS> 
TOKEN :
{
  <ARCHIVE_VOLUME_GET:       "--get">                   : OPTIONS
| <ARCHIVE_VOLUME_GET_INFO:  "--get-info">              : ARCHIVE_PREFIX_SEP
| <AE46:                     ["\0"]>            
| <UNKNOWN_OPTION20:         "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN20:                ~["-","\0"] (~["\0"])*>    : IGNORE_STATE          
}


/* toolset command options */ 
<TOOLSET_OPTS> 
TOKEN :
{
  <TOOLSET_GET:           "--get">                   : OPTIONS
| <TOOLSET_GET_INFO:      "--get-info">              : TOOLSET_NAME_SEP  
| <TOOLSET_GET_INFO_ALL:  "--get-info-all">          : OPTIONS
| <TOOLSET_SET:           "--set">                   : TOOLSET_NAME_SEP  
| <TOOLSET_ADD:           "--add">                   : TOOLSET_NAME_SEP 
| <TOOLSET_REMOVE:        "--remove">                : TOOLSET_NAME_SEP 
| <TOOLSET_EXPORT:        "--export">                : TOOLSET_NAME_SEP
| <AE27:                  ["\0"]>            
| <UNKNOWN_OPTION4:       "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN4:              ~["-","\0"] (~["\0"])*>    : IGNORE_STATE          
}


/* key command options */ 
<KEY_OPTS> 
TOKEN :
{
  <KEY_GET:            "--get">                   : OPTIONS
| <KEY_GET_INFO:       "--get-info">              : KEY_NAME_SEP  
| <KEY_GET_INFO_ALL:   "--get-info-all">          : OPTIONS
| <KEY_ADD:            "--add">                   : KEY_NAME_SEP 
| <KEY_SET:            "--set">                   : KEY_NAME_SEP 
| <KEY_REMOVE:         "--remove">                : KEY_NAME_SEP 
| <AE28:               ["\0"]>    
| <UNKNOWN_OPTION5:    "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN5:           ~["-","\0"] (~["\0"])*>    : IGNORE_STATE           
}


/* job server command options */ 
<JOB_SERVER_OPTS> 
TOKEN :
{
  <JOB_GET:            "--get">                   : OPTIONS
| <JOB_GET_INFO:       "--get-info">              : HOST_NAME_SEP  
| <JOB_GET_INFO_ALL:   "--get-info-all">          : OPTIONS
| <JOB_GET_HISTOGRAMS: "--get-histograms">        : OPTIONS
| <JOB_SET:            "--set">                   : HOST_NAME_SEP 
| <JOB_ADD:            "--add">                   : HOST_NAME_SEP 
| <JOB_REMOVE:         "--remove">                : HOST_NAME_SEP
| <AE29:               ["\0"]>   
| <UNKNOWN_OPTION6:    "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN6:           ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}

/* editor command options */ 
<EDITOR_OPTS> 
TOKEN :
{
  <EDITOR_GET:            "--get">                   : OPTIONS
| <EDITOR_GET_INFO:       "--get-info">              : EDITOR_NAME_SEP  
| <EDITOR_GET_INFO_ALL:   "--get-info-all">          : OPTIONS
| <AE30:                  ["\0"]>   
| <UNKNOWN_OPTION7:       "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN7:              ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}


/* action command options */ 
<ACTION_OPTS> 
TOKEN :
{
  <ACTION_GET:            "--get">                   : OPTIONS
| <ACTION_GET_INFO:       "--get-info">              : ACTION_NAME_SEP  
| <ACTION_GET_INFO_ALL:   "--get-info-all">          : OPTIONS
| <AE31:                  ["\0"]>   
| <UNKNOWN_OPTION8:       "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN8:              ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}


/* comparator command options */ 
<COMPARATOR_OPTS> 
TOKEN :
{
  <COMPARATOR_GET:            "--get">                   : OPTIONS
| <COMPARATOR_GET_INFO:       "--get-info">              : COMPARATOR_NAME_SEP  
| <COMPARATOR_GET_INFO_ALL:   "--get-info-all">          : OPTIONS
| <AE32:                      ["\0"]>   
| <UNKNOWN_OPTION9:           "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN9:                  ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}


/* tool command options */ 
<TOOL_OPTS> 
TOKEN :
{
  <TOOL_GET:           "--get">                   : OPTIONS
| <TOOL_GET_INFO:      "--get-info">              : TOOL_NAME_SEP  
| <TOOL_GET_INFO_ALL:  "--get-info-all">          : OPTIONS
| <AE33:               ["\0"]>   
| <UNKNOWN_OPTION10:   "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN10:          ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}


/* archiver command options */ 
<ARCHIVER_OPTS> 
TOKEN :
{
  <ARCHIVER_GET:            "--get">                   : OPTIONS
| <ARCHIVER_GET_INFO:       "--get-info">              : ARCHIVER_NAME_SEP  
| <ARCHIVER_GET_INFO_ALL:   "--get-info-all">          : OPTIONS
| <AE34:                    ["\0"]>   
| <UNKNOWN_OPTION11:        "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN11:               ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}



/* job server command options */ 
<SUFFIX_EDITOR_OPTS> 
TOKEN :
{
  <SUFFIX_EDITOR_GET:            "--get">                   : OPTIONS
| <SUFFIX_EDITOR_GET_INFO:       "--get-info">              : SUFFIX_SEP  
| <SUFFIX_EDITOR_GET_INFO_ALL:   "--get-info-all">          : OPTIONS
| <SUFFIX_EDITOR_SET:            "--set">                   : SUFFIX_SEP 
| <SUFFIX_EDITOR_REMOVE:         "--remove">                : SUFFIX_SEP
| <SUFFIX_EDITOR_RESET:          "--reset">                 : OPTIONS
| <AE35:                         ["\0"]>   
| <UNKNOWN_OPTION12:             "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN12:                    ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}


/* view command options */ 
<VIEW_OPTS> 
TOKEN :
{
  <VIEW_GET:            "--get">                   : OPTIONS
| <VIEW_CREATE:         "--create">                : VIEW_NAME_SEP
| <VIEW_RELEASE:        "--release">               : VIEW_NAME_SEP
| <AE36:                ["\0"]>   
| <UNKNOWN_OPTION13:    "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN13:           ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}


/* working command options */ 
<WORKING_OPTS> 
TOKEN :
{
  <WORKING_GET_INFO:          "--get-info">              : NODE_NAME_SEP
| <WORKING_REGISTER:          "--register">              : NODE_NAME_SEP
| <WORKING_CLONE:             "--clone">                 : NODE_NAME_SEP
| <WORKING_RELEASE:           "--release">               : NODE_NAME_SEP
| <WORKING_SET:               "--set">                   : NODE_NAME_SEP
| <WORKING_LINK:              "--link">                  : NODE_NAME_SEP
| <WORKING_UNLINK:            "--unlink">                : NODE_NAME_SEP
| <WORKING_ADD_SECONDARY:     "--add-secondary">         : NODE_NAME_SEP
| <WORKING_REMOVE_SECONDARY:  "--remove-secondary">      : NODE_NAME_SEP
| <WORKING_RENAME:            "--rename">                : NODE_NAME_SEP
| <WORKING_RENUMBER:          "--renumber">              : NODE_NAME_SEP
| <WORKING_EDIT:              "--edit">                  : NODE_NAME_SEP
| <WORKING_SUBMIT_JOBS:       "--submit-jobs">           : NODE_NAME_SEP
| <WORKING_REMOVE_FILES:      "--remove-files">          : NODE_NAME_SEP
| <WORKING_VIEWS_CONTAINING:  "--views-containing">      : NODE_NAME_SEP
| <WORKING_VIEWS_EDITING:     "--views-editing">         : NODE_NAME_SEP
| <AE37:                      ["\0"]>   
| <UNKNOWN_OPTION14:          "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN14:                 ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}

/* checked-in command options */ 
<CHECKED_IN_OPTS> 
TOKEN :
{
  <CHECKED_IN_GET_INFO:       "--get-info">              : NODE_NAME_SEP
| <CHECKED_IN_HISTORY:        "--history">               : NODE_NAME_SEP
| <CHECKED_IN_VIEW:           "--view">                  : NODE_NAME_SEP
| <AE38:                      ["\0"]>   
| <UNKNOWN_OPTION15:          "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN15:                 ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}

/* node command options */ 
<NODE_OPTS> 
TOKEN :
{
  <NODE_STATUS:            "--status">                : NODE_NAME_SEP
| <NODE_CHECK_IN:          "--check-in">              : NODE_NAME_SEP
| <NODE_CHECK_OUT:         "--check-out">             : NODE_NAME_SEP
| <NODE_EVOLVE:            "--evolve">                : NODE_NAME_SEP
| <NODE_GET_EVENTS:        "--get-events">            : OPTIONS
| <AE39:                   ["\0"]>   
| <UNKNOWN_OPTION16:       "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN16:              ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}

/* job group command options */ 
<JOB_GROUP_OPTS> 
TOKEN :
{
  <JOB_GROUP_STATUS:       "--status">                : JOB_GROUP_ID_SEP
| <JOB_GROUP_KILL:         "--kill">                  : JOB_GROUP_ID_SEP
| <JOB_GROUP_PAUSE:        "--pause">                 : JOB_GROUP_ID_SEP
| <JOB_GROUP_RESUME:       "--resume">                : JOB_GROUP_ID_SEP
| <JOB_GROUP_REMOVE:       "--remove">                : JOB_GROUP_ID_SEP
| <JOB_GROUP_REMOVE_ALL:   "--remove-all">            : OPTIONS
| <AE40:                   ["\0"]>   
| <UNKNOWN_OPTION17:       "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN17:              ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}

/* job command options */ 
<JOB_OPTS> 
TOKEN :
{
  <JOB_STATUS:         "--status">                : JOB_ID_SEP
| <JOB_KILL:           "--kill">                  : JOB_ID_SEP
| <JOB_PAUSE:          "--pause">                 : JOB_ID_SEP
| <JOB_RESUME:         "--resume">                : JOB_ID_SEP
| <AE41:               ["\0"]>   
| <UNKNOWN_OPTION18:   "-" ("-")? (~["\0","="])*> : IGNORE_STATE
| <UNKNOWN18:          ~["-","\0"] (~["\0"])*>    : IGNORE_STATE         
}




/*------------------------------------------------------------------------------------------*/
/*   T O P   L E V E L                                                                      */
/*------------------------------------------------------------------------------------------*/

void
CommandLine() 
  throws PipelineException :
{
  init();
}
{
  (InformationOpts() | ((GlobalOpts() AE())* (Batch() | Commands()))) <EOF>
  {}
}


void 
Commands() 
  throws PipelineException :
{
  /* initialize the plugins */ 
  PluginMgrClient.init(true);

  /* setup the log files */ 
  if(pLogFile != null) {
    try {
      LogMgr.getInstance().logToFile(pLogFile, pLogBackups, 10485760L);
    }
    catch(Exception ex) {
      System.out.print("Unable to setup log file: " + ex.getMessage());
      System.exit(1);
    }
  }
  
  /* create the network clients */ 
  pMasterMgrClient = new MasterMgrClient();
  pQueueMgrClient  = new QueueMgrClient();
}
{
  (UserCmds() | WorkGroupCmds() | PrivilegeCmds() | AdminCmds() | RuntimeCmds() | 
   ArchiveVolumeCmds() | DefaultToolsetCmds() | ActiveToolsetCmds() | ToolsetCmds() |
   LicenseKeyCmds() | SelectionKeyCmds() | JobServerCmds() | 
   EditorCmds() | ActionCmds() | ComparatorCmds() | ToolCmds() | ArchiverCmds() | 
   SuffixEditorCmds() | ViewCmds() | 
   WorkingCmds() | CheckedInCmds() | NodeCmds()) 
  {
    disconnect();
  }
}
    

/*------------------------------------------------------------------------------------------*/
/*   B A T C H   M O D E                                                                    */
/*------------------------------------------------------------------------------------------*/

void 
Batch() 
  throws PipelineException : 
{
  /* initialize the plugins */ 
  PluginMgrClient.init(true);

  /* setup the log files */ 
  if(pLogFile != null) {
    try {
      LogMgr.getInstance().logToFile(pLogFile, pLogBackups, 10485760L);
    }
    catch(Exception ex) {
      System.out.print("Unable to setup log file: " + ex.getMessage());
      System.exit(1);
    }
  }
  
  /* create the network clients */ 
  pMasterMgrClient = new MasterMgrClient();
  pQueueMgrClient  = new QueueMgrClient();
}
{
  (BatchOpt())
  {
    disconnect();
  }
}

void 
BatchOpt() 
  throws PipelineException : 
{
  Token t;
}
{
  <BATCH> EQ() t=<PATH_ARG2> AE()
  {
    /* process the batch file */ 
    File canon = null;
    {
      File file = new File(t.image);
      try {
	canon = file.getCanonicalFile();
      }
      catch(IOException ex) {
	throw new PipelineException
        ("Unable to determine the canonical filesystem path to the batch " + 
	 "file (" + file + ")!");
      }
    }

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Processing Batch File: " + canon);

    if(pBatchFiles.contains(canon)) {
      StringBuffer buf = new StringBuffer();
      buf.append("Circular Batch Files:\n");

      Iterator iter = pBatchFiles.iterator();
      while(iter.hasNext()) {
	File file = (File) iter.next();
	buf.append("  " + file + " -> ");
      }
      buf.append("  " + canon);

      throw new PipelineException(buf.toString());
    }
    pBatchFiles.push(canon);

    ArrayList lines = pApp.packageFile(canon);
    Iterator iter = lines.iterator();
    while(iter.hasNext()) {
      String line = (String) iter.next();

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "\n" + 
       pApp.repeat('*', 80) + "\n" +
       "  BATCH: " + line.replace('\0',' ') + "\n" +
       pApp.repeat('*', 80) + "\n");
      
      ScriptOptsParser parser = new ScriptOptsParser(new StringReader(line));
      parser.init(this);
      parser.BatchCommand();
    }

    pBatchFiles.pop();
  }
}

void 
BatchCommand() 
  throws PipelineException : 
{}
{
  (UserCmds() | WorkGroupCmds() | PrivilegeCmds() | AdminCmds() | RuntimeCmds() | 
   ArchiveVolumeCmds() | DefaultToolsetCmds() | ActiveToolsetCmds() | ToolsetCmds() |
   LicenseKeyCmds() | SelectionKeyCmds() | JobServerCmds() | 
   EditorCmds() | ActionCmds() | ComparatorCmds() | ToolCmds() | ArchiverCmds() | 
   SuffixEditorCmds() | ViewCmds() | 
   WorkingCmds() | CheckedInCmds() | NodeCmds()
   
   ) (AE())* <EOF>
  {}
}



/*------------------------------------------------------------------------------------------*/
/*   I N F O R M A T I O N   O P T I O N S                                                  */
/*------------------------------------------------------------------------------------------*/

void
InformationOpts() :
{}
{
  (Help() | HtmlHelp() | Version() | ReleaseDate() | Copyright() | License())
  {}
}

void
Help() : 
{}
{
  <HELP> AE()
  { 
    pApp.help(); 
  }
}

void
HtmlHelp() : 
{}
{
  <HTML_HELP> AE()
  { 
    pApp.htmlHelp(); 
  }
}

void
Version() :
{}
{
  <VERSION1> AE()
  { 
    pApp.version(); 
  }
}

void
ReleaseDate() :
{}
{
  <RELEASE_DATE> AE()
  { 
    pApp.releaseDate(); 
  }
}

void
Copyright() :
{}
{
  <COPYRIGHT> AE() 
  { 
    pApp.copyright(); 
  }
}

void
License() :
{}
{
  <LICENSE> AE() 
  { 
    pApp.license(); 
  }
}



/*------------------------------------------------------------------------------------------*/
/*   G L O B A L   O P T I O N S                                                            */
/*------------------------------------------------------------------------------------------*/

void
GlobalOpts()
  throws PipelineException :
{}
{
  (Log() | LogFile() | StandardLogFile() | LogBackups())
  {}
}

void LogFile() : 
{
  Token t;
}
{
  <LOG_FILE> EQ() t=<PATH_ARG2>
  { 
    pLogFile = new Path(t.image);
  }
}

void StandardLogFile() : 
{}
{
  <STANDARD_LOG_FILE>
  { 
    pLogFile = new Path(PackageInfo.sHomePath, PackageInfo.sUser + "/plscript.log");
  }
}

void LogBackups() : 
{
  Token t;
}
{
  <LOG_BACKUPS> EQ() t=<INTEGER2>
  { 
    pLogBackups = Integer.parseInt(t.image);
  }
}

void Log() : 
{}
{
  (<LOG> EQ() LoggerArg() (COMMA() LoggerArg())*) 
  {}
}

void RemoteLog() : 
{
  pLogControls = new LogControls();
}
{
  <REMOTE_LOG> EQ() LoggerArg() (COMMA() LoggerArg())* AE() 
  {}
}

  

void LoggerArg() : 
{}
{
  (LoggerAll() | LoggerPair()) 
  {}
}


void LoggerAll() : 
{
  LogMgr.Level v;
}
{
  ((<LOG_ALL> | <REMOTE_LOG_ALL>) COLON() v=LogLevel())
  {
    if(pLogControls != null) 
      pLogControls.setLevels(v);
    else
      LogMgr.getInstance().setLevels(v);
  }
}

void LoggerPair() : 
{
  LogMgr.Kind k;
  LogMgr.Level v;
}
{
  (k=LogKind() COLON() v=LogLevel())
  {
    if(pLogControls != null) 
      pLogControls.setLevel(k, v);
    else
      LogMgr.getInstance().setLevel(k, v);
  }
}

LogMgr.Kind LogKind() : 
{
  LogMgr.Kind g;
}
{
  (g=ArgKind() | g=SumKind() | g=GluKind() | g=JobKind() | g=MemKind() | g=NetKind() | 
   g=OpsKind() | g=PlgKind() | g=SubKind() | g=TexKind() | g=DspKind() | g=ColKind() | 
   g=SchKind() | g=ExtKind())
  {
    return g;
  }
}

LogMgr.Kind ArgKind() : 
{}
{
  (<LOG_ARG> | <REMOTE_LOG_ARG>)
  {
    return LogMgr.Kind.Arg;
  }
}

LogMgr.Kind SumKind() : 
{}
{
  (<LOG_SUM> | <REMOTE_LOG_SUM>)
  {
    return LogMgr.Kind.Sum;
  }
}

LogMgr.Kind GluKind() : 
{}
{
  (<LOG_GLU> | <REMOTE_LOG_GLU>)
  {
    return LogMgr.Kind.Glu;
  }
}

LogMgr.Kind JobKind() : 
{}
{
  (<LOG_JOB> | <REMOTE_LOG_JOB>)
  {
    return LogMgr.Kind.Job;
  }
}

LogMgr.Kind MemKind() : 
{}
{
  (<LOG_MEM> | <REMOTE_LOG_MEM>)
  {
    return LogMgr.Kind.Mem;
  }
}

LogMgr.Kind NetKind() : 
{}
{
  (<LOG_NET> | <REMOTE_LOG_NET>)
  {
    return LogMgr.Kind.Net;
  }
}

LogMgr.Kind OpsKind() : 
{}
{
  (<LOG_OPS> | <REMOTE_LOG_OPS>)
  {
    return LogMgr.Kind.Ops;
  }
}

LogMgr.Kind PlgKind() : 
{}
{
  (<LOG_PLG> | <REMOTE_LOG_PLG>)
  {
    return LogMgr.Kind.Plg;
  }
}

LogMgr.Kind SubKind() : 
{}
{
  (<LOG_SUB> | <REMOTE_LOG_SUB>)
  {
    return LogMgr.Kind.Sub;
  }
}

LogMgr.Kind TexKind() : 
{}
{
  (<LOG_TEX> | <REMOTE_LOG_TEX>)
  {
    return LogMgr.Kind.Tex;
  }
}

LogMgr.Kind DspKind() : 
{}
{
  (<LOG_DSP> | <REMOTE_LOG_DSP>)
  {
    return LogMgr.Kind.Dsp;
  }
}

LogMgr.Kind ColKind() : 
{}
{
  (<LOG_COL> | <REMOTE_LOG_COL>)
  {
    return LogMgr.Kind.Col;
  }
}

LogMgr.Kind SchKind() : 
{}
{
  (<LOG_SCH> | <REMOTE_LOG_SCH>)
  {
    return LogMgr.Kind.Sch;
  }
}

LogMgr.Kind ExtKind() : 
{}
{
  (<LOG_EXT> | <REMOTE_LOG_EXT>)
  {
    return LogMgr.Kind.Ext;
  }
}

LogMgr.Level LogLevel() : 
{
  LogMgr.Level v;
}
{
  (v=SevereLevel() | v=WarningLevel() | v=InfoLevel() | 
   v=FineLevel() | v=FinerLevel() | v=FinestLevel()) 
  {
    return v;
  }
}

LogMgr.Level SevereLevel() :
{
  LogMgr.Level v;
}
{
  (<SEVERE> | <REMOTE_SEVERE>) 
  {
    return LogMgr.Level.Severe;
  }
}

LogMgr.Level WarningLevel() :
{
  LogMgr.Level v;
}
{
  (<WARNING> | <REMOTE_WARNING>) 
  {
    return LogMgr.Level.Warning;
  }
}

LogMgr.Level InfoLevel() :
{
  LogMgr.Level v;
}
{
  (<INFO> | <REMOTE_INFO>) 
  {
    return LogMgr.Level.Info;
  }
}

LogMgr.Level FineLevel() :
{
  LogMgr.Level v;
}
{
  (<FINE> | <REMOTE_FINE>) 
  {
    return LogMgr.Level.Fine;
  }
}

LogMgr.Level FinerLevel() :
{
  LogMgr.Level v;
}
{
  (<FINER> | <REMOTE_FINER>) 
  {
    return LogMgr.Level.Finer;
  }
}

LogMgr.Level FinestLevel() :
{
  LogMgr.Level v;
}
{
  (<FINEST> | <REMOTE_FINEST>) 
  {
    return LogMgr.Level.Finest;
  }
}

/*------------------------------------------------------------------------------------------*/
/*   U S E R   C O M M A N D S                                                              */
/*------------------------------------------------------------------------------------------*/

void 
UserCmds() 
  throws PipelineException : 
{}
{
  <USER> AE() (UserGet() | UserAdd() | UserRemove()) 
  {}
}

void 
UserGet() 
  throws PipelineException : 
{}
{
  <USER_GET> AE()
  {
    WorkGroups wgroups = pMasterMgrClient.getWorkGroups();
    Set users = wgroups.getUsers();
    Iterator iter = users.iterator();
    while(iter.hasNext()) {
      String user = (String) iter.next();
      LogMgr.getInstance().log
	(LogMgr.Kind.Ops, LogMgr.Level.Info,
	 user);
    }
    LogMgr.getInstance().flush();
  }
}

void 
UserAdd() 
  throws PipelineException : 
{
  String user = null;
}
{
  <USER_ADD> EQ() user=UserName() AE()
  {
    WorkGroups wgroups = pMasterMgrClient.getWorkGroups();
    wgroups.addUser(user);
    pMasterMgrClient.setWorkGroups(wgroups);
  }
}

void 
UserRemove() 
  throws PipelineException : 
{
  String user = null;
}
{
  <USER_REMOVE> EQ() user=UserName() AE()
  {
    WorkGroups wgroups = pMasterMgrClient.getWorkGroups();
    wgroups.removeUser(user);
    pMasterMgrClient.setWorkGroups(wgroups);
  }
}


/*------------------------------------------------------------------------------------------*/
/*   W O R K   G R O U P   C O M M A N D S                                                  */
/*------------------------------------------------------------------------------------------*/

void 
WorkGroupCmds() 
  throws PipelineException : 
{}
{
  <WORK_GROUP> AE() (WorkGroupGet() | WorkGroupGetInfo() | WorkGroupGetInfoAll() | 
		     WorkGroupAdd() | WorkGroupRemove() | WorkGroupSet())
  {}
}

void 
WorkGroupGet() 
  throws PipelineException : 
{}
{
  <WORK_GROUP_GET> AE()
  {
    WorkGroups wgroups = pMasterMgrClient.getWorkGroups();
    Set groups = wgroups.getGroups();
    Iterator iter = groups.iterator();
    while(iter.hasNext()) {
      String group = (String) iter.next();
      LogMgr.getInstance().log
	(LogMgr.Kind.Ops, LogMgr.Level.Info,
	 group);
    }
    LogMgr.getInstance().flush();
  }
}

void 
WorkGroupGetInfo() 
  throws PipelineException : 
{
  String group = null;
}
{
  <WORK_GROUP_GET_INFO> EQ() group=WorkGroupName() AE()
  {
    pApp.printWorkGroupMembers(group, pMasterMgrClient);
  }
}

void 
WorkGroupGetInfoAll() 
  throws PipelineException : 
{}
{
  <WORK_GROUP_GET_INFO_ALL> AE()
  {
    pApp.printWorkGroupMembers(pMasterMgrClient);
  }
}

void 
WorkGroupAdd() 
  throws PipelineException : 
{
  String group = null;
}
{
  <WORK_GROUP_ADD> EQ() group=WorkGroupName() AE()
  {
    WorkGroups wgroups = pMasterMgrClient.getWorkGroups();
    wgroups.addGroup(group);
    pMasterMgrClient.setWorkGroups(wgroups);
  }
}

void 
WorkGroupRemove() 
  throws PipelineException : 
{
  String group = null;
}
{
  <WORK_GROUP_REMOVE> EQ() group=WorkGroupName() AE()
  {
    WorkGroups wgroups = pMasterMgrClient.getWorkGroups();
    wgroups.removeGroup(group);
    pMasterMgrClient.setWorkGroups(wgroups);
  }
}

void 
WorkGroupSet() 
  throws PipelineException : 
{
  String group = null;
  pWorkGroupUsers = new TreeSet();
}
{
  <WORK_GROUP_SET> EQ() group=WorkGroupName() AE() 
     (Manager() | Member() | NotMember()) (WorkGroupSetOpts())* 
  {
    WorkGroups wgroups = pMasterMgrClient.getWorkGroups();
    Iterator iter = pWorkGroupUsers.iterator();
    while(iter.hasNext()) {
      String user = (String) iter.next();
      wgroups.setMemberOrManager(user, group, pWorkGroupMembership);
    }
    pMasterMgrClient.setWorkGroups(wgroups);
  }
}

void 
Manager() : 
{}
{
  <MANAGER> AE() 
  {
    pWorkGroupMembership = new Boolean(true);
  }
}

void 
Member() : 
{}
{
  <MEMBER> AE() 
  {
    pWorkGroupMembership = new Boolean(false);
  }
}

void 
NotMember() : 
{}
{
  <NOT_MEMBER> AE() 
  {
    pWorkGroupMembership = null;
  }
}
  
void
WorkGroupSetOpts() 
  throws PipelineException : 
{}
{
  (WorkGroupUser()) 
  {}
}

void 
WorkGroupUser() 
  throws PipelineException : 
{
  String user = null;
}
{
  <USER2> EQ() user=UserName() AE()
  {
    pWorkGroupUsers.add(user);
  }
}


/*------------------------------------------------------------------------------------------*/
/*   P R I V I L E G E   C O M M A N D S                                                    */
/*------------------------------------------------------------------------------------------*/

void 
PrivilegeCmds() 
  throws PipelineException : 
{}
{
  <PRIVILEGE> AE() (PrivilegeGetInfo() | PrivilegeGetInfoAll() | 
		    PrivilegeGrant() | PrivilegeRevoke())
  {}
}

void 
PrivilegeGetInfo() 
  throws PipelineException : 
{
  String user = null;
}
{
  <PRIVILEGE_GET_INFO> EQ() user=UserName() AE()
  {
    pApp.printUserPrivileges(user, pMasterMgrClient);
  }
}

void 
PrivilegeGetInfoAll() 
  throws PipelineException :
{}
{
  <PRIVILEGE_GET_INFO_ALL> AE()
  {
    pApp.printUserPrivileges(pMasterMgrClient);
  }
}

void 
PrivilegeGrant() 
  throws PipelineException : 
{
  String user = null;

  pIsMasterAdmin  = null;
  pIsDeveloper    = null; 
  pIsQueueAdmin   = null; 
  pIsQueueManager = null; 
  pIsNodeManager  = null; 
}
{
  <PRIVILEGE_GRANT> EQ() user=UserName() AE() (PrivilegeGrantOpts())* 
  {
    pApp.editPrivileges(user, 
			pIsMasterAdmin, pIsDeveloper, 
			pIsQueueAdmin, pIsQueueManager, pIsNodeManager, 
			pMasterMgrClient);
  }
}

void
PrivilegeGrantOpts() 
  throws PipelineException : 
{}
{
  (GrantMasterAdmin() | GrantDeveloper() | 
   GrantQueueAdmin() | GrantQueueManager() | GrantNodeManager())
  {}
}

void 
GrantMasterAdmin() : 
{}
{
  <MASTER_ADMIN> AE() 
  {
    pIsMasterAdmin = new Boolean(true);
  }
}

void 
GrantDeveloper() : 
{}
{
  <DEVELOPER> AE() 
  {
    pIsDeveloper = new Boolean(true);
  }
}

void 
GrantQueueAdmin() : 
{}
{
  <QUEUE_ADMIN> AE() 
  {
    pIsQueueAdmin = new Boolean(true);
  }
}

void 
GrantQueueManager() : 
{}
{
  <QUEUE_MANAGER> AE() 
  {
    pIsQueueManager = new Boolean(true);
  }
}

void 
GrantNodeManager() : 
{}
{
  <NODE_MANAGER> AE() 
  {
    pIsNodeManager = new Boolean(true);
  }
}

void 
PrivilegeRevoke() 
  throws PipelineException : 
{
  String user = null;

  pIsMasterAdmin  = null;
  pIsDeveloper    = null; 
  pIsQueueAdmin   = null; 
  pIsQueueManager = null; 
  pIsNodeManager  = null; 
}
{
  <PRIVILEGE_REVOKE> EQ() user=UserName() AE() (PrivilegeRevokeOpts())* 
  {
    pApp.editPrivileges(user, 
			pIsMasterAdmin, pIsDeveloper, 
			pIsQueueAdmin, pIsQueueManager, pIsNodeManager, 
			pMasterMgrClient);
  }
}

void
PrivilegeRevokeOpts() 
  throws PipelineException : 
{}
{
  (RevokeMasterAdmin() | RevokeDeveloper() | 
   RevokeQueueAdmin() | RevokeQueueManager() | RevokeNodeManager())
  {}
}

void 
RevokeMasterAdmin() : 
{}
{
  <MASTER_ADMIN> AE() 
  {
    pIsMasterAdmin = new Boolean(false);
  }
}

void 
RevokeDeveloper() : 
{}
{
  <DEVELOPER> AE() 
  {
    pIsDeveloper = new Boolean(false);
  }
}

void 
RevokeQueueAdmin() : 
{}
{
  <QUEUE_ADMIN> AE() 
  {
    pIsQueueAdmin = new Boolean(false);
  }
}

void 
RevokeQueueManager() : 
{}
{
  <QUEUE_MANAGER> AE() 
  {
    pIsQueueManager = new Boolean(false);
  }
}

void 
RevokeNodeManager() : 
{}
{
  <NODE_MANAGER> AE() 
  {
    pIsNodeManager = new Boolean(false);
  }
}



/*------------------------------------------------------------------------------------------*/
/*   A D M I N   C O M M A N D S                                                            */
/*------------------------------------------------------------------------------------------*/

void 
AdminCmds() 
  throws PipelineException : 
{}
{
  <ADMIN> AE() (AdminShutdown() | AdminBackup() | 
		AdminArchive() | AdminOffline() | AdminRestore())
  {}
}

void 
AdminShutdown() 
  throws PipelineException : 
{
  pShutdownJobMgrs   = false;
  pShutdownPluginMgr = false;
}
{
  Shutdown() AE() (ShutdownOpts())* 
  {
    if(pQueueMgrClient != null) 
      pQueueMgrClient.disconnect();

    if(pShutdownJobMgrs || pShutdownPluginMgr) 
      pMasterMgrClient.shutdown(pShutdownJobMgrs, pShutdownPluginMgr);
    else 
      pMasterMgrClient.shutdown();

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Shutting Down...");
    LogMgr.getInstance().flush();

    /* give the sockets time to disconnect cleanly */ 
    try {
      Thread.sleep(1000);
    }
    catch(InterruptedException ex) {
    }

    System.exit(0);
  }
}

void 
ShutdownOpts() : 
{}
{
  (ShutdownJobMgrs() | ShutdownPluginMgr())
  {}
}

void 
ShutdownJobMgrs() :
{}
{
  <SHUTDOWN_JOBMGRS> AE()
  {
    pShutdownJobMgrs = true;
  }
}

void 
ShutdownPluginMgr() : 
{}
{
  <SHUTDOWN_PLUGINMGR> AE()
  {
    pShutdownPluginMgr = true;
  }
}


/*------------------------------------------------------------------------------------------*/

void 
AdminBackup() 
  throws PipelineException : 
{
  Token t;
}
{
  <BACKUP> EQ() t=<PATH_ARG> AE()
  {
    File dir = new File(t.image);
    if(!dir.isDirectory()) 
    throw new PipelineException
      ("The backup directory (" + t.image + ") is not valid!");

    SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd.HHmmss");
    File file = new File(dir, "pipeline-db." + format.format(new Date()) + ".tgz");
    
    pMasterMgrClient.backupDatabase(file);
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Database Saved: " + file);
    LogMgr.getInstance().flush();
  }
}


/*------------------------------------------------------------------------------------------*/

void 
AdminArchive() 
  throws PipelineException : 
{
  Token t;

  pArchivePattern    = null;
  pMaxArchives       = 2;
  pMinSize           = 1073741824L;
  pArchiverName      = null; 
  pArchiverVersionID = null; 
  pArchiverVendor    = null;
  pParams            = new TreeMap();
  pAutoStart         = false;
  pToolset           = null; 
}
{
  <ARCHIVE> EQ() t=<ARCHIVE_PREFIX> AE() (AdminArchiveOpts())*
  {
    String prefix = t.image;

    if(pArchiverName == null) 
      throw new PipelineException
        ("The --archiver option is required!");
    
    if(pMaxArchives < 1) 
      throw new PipelineException
        ("The --max-archives must be at least (1)!"); 
    
    if(pMinSize < 0L) 
      throw new PipelineException
        ("The --min-size cannot be negative!"); 
    
    pApp.archive(prefix, pArchivePattern, pMaxArchives, pMinSize, 
		 pArchiverName, pArchiverVersionID, pArchiverVendor, pParams, 
		 pAutoStart, pToolset,
		 pMasterMgrClient);
  }
}

void
AdminArchiveOpts() 
  throws PipelineException : 
{}
{
  (Pattern() | MaxArchives() | MinSize() | Archiver() | Param() | AutoStart() | Toolset()) 
  {}
}

void 
Pattern() : 
{
  String p;
}
{
  <PATTERN> EQ() p=StringLiteral() AE()
  {
    if((p != null) && (p.length() > 0))
      pArchivePattern = p;
  }
}

void 
MaxArchives()
  throws PipelineException : 
{
  int i; 
}
{
  <MAX_ARCHIVES> EQ() i=IntegerLiteral() AE()
  {
    pMaxArchives = i;
  }
}

void 
MinSize()
  throws PipelineException : 
{
  long size;
}
{
  <MIN_SIZE> EQ() size=ByteSize() AE()
  {
    pMinSize = size;
  }
}

void
Archiver()
  throws PipelineException : 
{
  String aname  = null;
  VersionID vid = null;
  String vendor = null;
}
{
  <ARCHIVER2> EQ() aname=ArchiverName() 
    (COLON() vid=RevisionNumber())? (COMMA() vendor=VendorName())? AE()
  {
    pArchiverName      = aname; 
    pArchiverVersionID = vid; 
    pArchiverVendor    = vendor; 
  }
}

void 
AutoStart() : 
{}
{
  <AUTO_START> AE()
  {
    pAutoStart = true;
  }
}


/*------------------------------------------------------------------------------------------*/

void 
AdminOffline() 
  throws PipelineException : 
{
  pArchivePattern    = null;
  pExcludeLatest     = 0; 
  pMinArchives       = 2; 
}
{
  <OFFLINE> AE() (AdminOfflineOpts())*
  {
    if(pExcludeLatest < 0) 
      throw new PipelineException
        ("The --exclude-latest cannot be negative!");

    if(pMinArchives < 0) 
      throw new PipelineException
        ("The --min-archives cannot be negative!");

    pApp.offline(pArchivePattern, pExcludeLatest, pMinArchives, pMasterMgrClient);
  }
}

void
AdminOfflineOpts() 
  throws PipelineException : 
{}
{
  (Pattern() | ExcludeLatest() | MinArchives()) 
  {}
}

void 
ExcludeLatest()
  throws PipelineException : 
{
  int i; 
}
{
  <EXCLUDE_LATEST> EQ() i=IntegerLiteral() AE()
  {
    pExcludeLatest = i;
  }
}

void 
MinArchives()
  throws PipelineException : 
{
  int i; 
}
{
  <MIN_ARCHIVES> EQ() i=IntegerLiteral() AE()
  {
    pMinArchives = i;
  }
}


/*------------------------------------------------------------------------------------------*/

void 
AdminRestore() 
  throws PipelineException : 
{
  Token t;

  pParams            = new TreeMap();
  pCheckedInVersions = new TreeMap(); 
  pToolset           = null; 
}
{
  <RESTORE> EQ() t=<ARCHIVE_PREFIX> AE() (AdminRestoreOpts())*
  {
    String prefix = t.image;
    pApp.restore(prefix, pParams, pCheckedInVersions, pToolset, pMasterMgrClient);
  }
}

void
AdminRestoreOpts() 
  throws PipelineException : 
{}
{
  (Param() | CheckedInVersion() | Toolset()) 
  {}
}

void
CheckedInVersion() 
  throws PipelineException : 
{
  String vname; 
  VersionID vid; 
}
{
  <CHECKED_IN_VSN> EQ() vname=VersionName() COLON() vid=RevisionNumber() AE()
  {
    TreeSet versions = (TreeSet) pCheckedInVersions.get(vname);
    if(versions == null) {
      versions = new TreeSet();
      pCheckedInVersions.put(vname, versions);
    }
    versions.add(vid);
  }
}

String
VersionName() : 
{
  Token t; 
}
{
  t=<VSN_NAME> 
  {
    return t.image;
  }
}


/*------------------------------------------------------------------------------------------*/
/*   R U N T I M E   C O M M A N D S                                                        */
/*------------------------------------------------------------------------------------------*/

void 
RuntimeCmds() 
  throws PipelineException : 
{}
{
  <RUNTIME> AE() (SetRuntimeMaster() | SetRuntimeQueue() | 
		  GetRuntimeMaster() | GetRuntimeQueue())
  {}
}

void 
SetRuntimeMaster() 
  throws PipelineException : 
{
  pLogControls = null;
  pNodeGCInterval = null;
  pMinOverhead = null;
  pMaxOverhead = null;
  pAvgNodeSize = null;
  pRestoreCleanupInterval = null;
}
{
  <SET_MASTER_RT> AE() (RuntimeMasterOpts())* 
  {
    boolean noOpts = true;
    if(pLogControls != null) {
      pMasterMgrClient.setLogControls(pLogControls);
      noOpts = false;
    }

    if((pNodeGCInterval != null) || (pMinOverhead != null) || (pMaxOverhead != null) || 
       (pAvgNodeSize != null) || (pRestoreCleanupInterval != null)) {
      MasterControls controls =
	new MasterControls(pAvgNodeSize, pMinOverhead, pMaxOverhead, 
			   pNodeGCInterval, pRestoreCleanupInterval);
      pMasterMgrClient.setRuntimeControls(controls);
      noOpts = false;
    }

    if(noOpts)
      throw new PipelineException
	("No runtime parameters specified for the Master Manager server!");
  }
}

void 
GetRuntimeMaster() 
  throws PipelineException : 
{}
{
  <GET_MASTER_RT> AE()
  {
    pApp.printRuntimeMaster(pMasterMgrClient); 
  }
}

void 
RuntimeMasterOpts() 
  throws PipelineException : 
{}
{
  (RemoteLog() | NodeGCInterval() | MinOverhead() | MaxOverhead() | AvgNodeSize() | 
   RestoreCleanupInterval())
  {}
}

void NodeGCInterval()
  throws PipelineException : 
{
  Token t;
}
{
  <NODE_GC_INTERVAL> EQ() t=<INTEGER> AE()
  {
    Long msec = Long.parseLong(t.image);
    if(msec <= 0) 
      throw new PipelineException
        ("The node garbage collection interval (" + msec + ") must be positive!");
    pNodeGCInterval = msec;
  }
}

void MinOverhead()
  throws PipelineException : 
{
  Token t;
}
{
  <MIN_OVERHEAD> EQ() t=<INTEGER> AE()
  {
    Long size = Long.parseLong(t.image);
    if(size <= 0) 
      throw new PipelineException
        ("The minimum overhead (" + size + ") must be positive!");
    pMinOverhead = size;
  }
}

void MaxOverhead()
  throws PipelineException : 
{
  Token t;
}
{
  <MAX_OVERHEAD> EQ() t=<INTEGER> AE()
  {
    Long size = Long.parseLong(t.image);
    if(size <= 0) 
      throw new PipelineException
        ("The maximum overhead (" + size + ") must be positive!");
    pMaxOverhead = size;
  }
}

void AvgNodeSize()
  throws PipelineException : 
{
  Token t;
}
{
  <AVG_NODE_SIZE> EQ() t=<INTEGER> AE()
  {
    Long size = Long.parseLong(t.image);
    if(size <= 0) 
      throw new PipelineException
        ("The average node size (" + size + ") must be positive!");
    pAvgNodeSize = size;
  }
}


void RestoreCleanupInterval()
  throws PipelineException : 
{
  Token t;
}
{
  <RESTORE_CLEANUP_INTERVAL> EQ() t=<INTEGER> AE()
  {
    Long msec = Long.parseLong(t.image);
    if(msec <= 0) 
      throw new PipelineException
        ("The restore cleanup interval (" + msec + ") must be positive!");
    pRestoreCleanupInterval = msec;
  }
}



/*------------------------------------------------------------------------------------------*/

void 
SetRuntimeQueue() 
  throws PipelineException : 
{
  pLogControls = null;
  pCollectorBatchSize = null;
  pDispatcherInterval = null;
}
{
  <SET_QUEUE_RT> AE() (RuntimeQueueOpts())* 
  {
    boolean noOpts = true;
    if(pLogControls != null) {
      pQueueMgrClient.setLogControls(pLogControls);
      noOpts = false;
    }
    
    if((pCollectorBatchSize != null) || (pDispatcherInterval != null)) {
      QueueControls controls = new QueueControls(pCollectorBatchSize, pDispatcherInterval);
      pQueueMgrClient.setRuntimeControls(controls);
      noOpts = false;
    }
      
    if(noOpts)
      throw new PipelineException
	("No runtime parameters specified for the Queue Manager server!");
  }
}

void 
GetRuntimeQueue() 
  throws PipelineException : 
{}
{
  <GET_QUEUE_RT> AE()
  {
    pApp.printRuntimeQueue(pQueueMgrClient); 
  }
}

void 
RuntimeQueueOpts() 
  throws PipelineException : 
{}
{
  (RemoteLog() | CollectorBatchSize() | DispatcherInterval()) 
  {}
}

void CollectorBatchSize() 
  throws PipelineException : 
{
  Token t;
}
{
  <COLLECTOR_BATCH_SIZE> EQ() t=<INTEGER> AE()
  {
    Integer num = Integer.parseInt(t.image);
    if(num <= 0) 
      throw new PipelineException
        ("The collector batch size (" + num + ") must be positive!");
    pCollectorBatchSize = num;
  }
}

void DispatcherInterval()
  throws PipelineException : 
{
  Token t;
}
{
  <DISPATCHER_INTERVAL> EQ() t=<INTEGER> AE()
  {
    Long msec = Long.parseLong(t.image);
    if(msec <= 0) 
      throw new PipelineException
        ("The dispatcher interval (" + msec + ") must be positive!");
    pDispatcherInterval = msec; 
  }
}


/*------------------------------------------------------------------------------------------*/
/*   A R C H I V E   V O L U M E    C O M M A N D S                                         */
/*------------------------------------------------------------------------------------------*/

void 
ArchiveVolumeCmds() 
  throws PipelineException : 
{}
{
  <ARCHIVE_VOLUME> AE() (ArchiveVolumeGet() |  ArchiveVolumeGetInfo())
  {}
}

void 
ArchiveVolumeGet() 
  throws PipelineException : 
{}
{
  <ARCHIVE_VOLUME_GET> AE()
  {
    pApp.printArchiveVolumeNames(pMasterMgrClient);
  }
}

void 
ArchiveVolumeGetInfo()
  throws PipelineException : 
{
  Token t;

  pSections = new TreeSet();
}
{
  <ARCHIVE_VOLUME_GET_INFO> EQ() t=<ARCHIVE_PREFIX> AE() (ArchiveVolumeGetInfoOpts())*
  {
    pApp.printArchiveVolume(t.image, pSections, pMasterMgrClient);
  }
}

void
ArchiveVolumeGetInfoOpts() :
{}
{
  (ArchiveVolumeGetInfoShow() | ArchiveVolumeGetInfoHide()) 
  {}
}

void 
ArchiveVolumeGetInfoShow() : 
{}
{
  <SHOW> EQ() ArchiveVolumeGetInfoShowSections() 
    (COMMA() ArchiveVolumeGetInfoShowSections())* AE()  
  {}
}

void 
ArchiveVolumeGetInfoShowSections() : 
{}
{
  (ArchiveVolumeGetInfoShowAll() | 
  ShowArch() | ShowVsn() | ShowFile()) 
  {}
}

void 
ArchiveVolumeGetInfoShowAll() : 
{}
{
  <ALL>
  {
    pSections.add("arch");
    pSections.add("vsn");
    pSections.add("file");
  }
}

void 
ArchiveVolumeGetInfoHide() : 
{}
{
  <HIDE> EQ() ArchiveVolumeGetInfoHideSections() 
    (COMMA() ArchiveVolumeGetInfoHideSections())* AE()  
  {}
}

void 
ArchiveVolumeGetInfoHideSections() : 
{}
{
  (ArchiveVolumeGetInfoHideAll() | 
   HideArch() | HideVsn() | HideFile())
  {}
}

void 
ArchiveVolumeGetInfoHideAll() : 
{}
{
  <ALL>
  {
    pSections.clear(); 
  }
}



/*------------------------------------------------------------------------------------------*/
/*   T O O L S E T   C O M M A N D S                                                        */
/*------------------------------------------------------------------------------------------*/

void 
DefaultToolsetCmds() 
  throws PipelineException : 
{}
{
  <DEFAULT_TOOLSET> AE() (DefaultToolsetGet() |  DefaultToolsetSet())
  {}
}

void 
DefaultToolsetGet() 
  throws PipelineException : 
{}
{
  <TOOLSET_GET> AE()
  {
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       pMasterMgrClient.getDefaultToolsetName());
    LogMgr.getInstance().flush();
  }
}

void 
DefaultToolsetSet() 
  throws PipelineException : 
{
  String tname = null;
}
{
  <TOOLSET_SET> EQ() tname=ToolsetName() AE()
  {
    pMasterMgrClient.setDefaultToolsetName(tname);
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Default toolset set to (" + tname + ").");
    LogMgr.getInstance().flush();
  }
}


/*------------------------------------------------------------------------------------------*/

void 
ActiveToolsetCmds() 
  throws PipelineException : 
{}
{
  <ACTIVE_TOOLSET> AE() (ActiveToolsetGet() | ActiveToolsetAdd() | ActiveToolsetRemove())
  {}
}

void 
ActiveToolsetGet() 
  throws PipelineException : 
{}
{
  <TOOLSET_GET> AE()
  {
    TreeSet tnames = pMasterMgrClient.getActiveToolsetNames(); 
    Iterator iter = tnames.iterator();
    while(iter.hasNext()) {
      String tname = (String) iter.next();
      LogMgr.getInstance().log
	(LogMgr.Kind.Ops, LogMgr.Level.Info,
	 tname);
    }
    LogMgr.getInstance().flush();
  }
}

void 
ActiveToolsetAdd() 
  throws PipelineException : 
{
  String tname = null;
}
{
  <TOOLSET_ADD> EQ() tname=ToolsetName() AE()
  {
    pMasterMgrClient.setToolsetActive(tname, true);
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Toolset (" + tname + ") is now active.");
    LogMgr.getInstance().flush();
  }
}

void 
ActiveToolsetRemove() 
  throws PipelineException : 
{
  String tname = null;
}
{
  <TOOLSET_REMOVE> EQ() tname=ToolsetName() AE()
  {
    pMasterMgrClient.setToolsetActive(tname, false);
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Toolset (" + tname + ") is now inactive.");
    LogMgr.getInstance().flush();
  }
}


/*------------------------------------------------------------------------------------------*/

void 
ToolsetCmds() 
  throws PipelineException : 
{}
{
  <TOOLSET1> AE() (ToolsetGet() | ToolsetGetInfo() | ToolsetGetInfoAll() |  ToolsetExport())
  {}
}

void 
ToolsetGet() 
  throws PipelineException : 
{}
{
  <TOOLSET_GET> AE()
  {
    TreeSet tnames = pMasterMgrClient.getToolsetNames(); 
    Iterator iter = tnames.iterator();
    while(iter.hasNext()) {
      String tname = (String) iter.next();
      LogMgr.getInstance().log
	(LogMgr.Kind.Ops, LogMgr.Level.Info,
	 tname);
    }
    LogMgr.getInstance().flush();
  }
}

void 
ToolsetGetInfo() 
  throws PipelineException : 
{
  String tname = null;
}
{
  <TOOLSET_GET_INFO> EQ() tname=ToolsetName() AE()
  {
    pApp.printToolset(tname, pMasterMgrClient);
  }
}

void 
ToolsetGetInfoAll() 
  throws PipelineException : 
{}
{
  <TOOLSET_GET_INFO_ALL> AE()
  {
    pApp.printToolset(null, pMasterMgrClient);
  }
}

void 
ToolsetExport() 
  throws PipelineException : 
{
  String tname = null;
}
{
  <TOOLSET_EXPORT> EQ() tname=ToolsetName() AE()
  {
    pApp.exportToolset(tname, pMasterMgrClient);
  }
}


/*------------------------------------------------------------------------------------------*/
/*   Q U E U E   A D M I N I S T R A T I O N   C O M M A N D S                              */
/*------------------------------------------------------------------------------------------*/

void 
LicenseKeyCmds() 
  throws PipelineException : 
{}
{
  <LICENSE_KEY1> AE() 
     (LicenseKeyGet() | LicenseKeyGetInfo() | LicenseKeyGetInfoAll() | 
      LicenseKeyAdd() | LicenseKeySet() | LicenseKeyRemove())
  {}
}

void 
LicenseKeyGet() 
  throws PipelineException : 
{}
{
  <KEY_GET> AE()
  {
    TreeSet knames = pQueueMgrClient.getLicenseKeyNames();
    Iterator iter = knames.iterator();
    while(iter.hasNext()) {
      String kname = (String) iter.next();
      LogMgr.getInstance().log
	(LogMgr.Kind.Ops, LogMgr.Level.Info,
	 kname);
    }
    LogMgr.getInstance().flush();    
  }
}

void 
LicenseKeyGetInfo() 
  throws PipelineException : 
{
  String kname = null;
}
{
  <KEY_GET_INFO> EQ() kname=KeyName() AE()
  {
    pApp.printLicenseKey(kname, pQueueMgrClient);
  }
}

void 
LicenseKeyGetInfoAll() 
  throws PipelineException : 
{}
{
  <KEY_GET_INFO_ALL> AE()
  {
    pApp.printLicenseKey(null, pQueueMgrClient);
  }
}

void 
LicenseKeyAdd() 
  throws PipelineException : 
{
  String kname   = null;
  pMessage       = null;
  pLicenseScheme = null;
  pMaxSlots      = null;
  pMaxHosts      = null;
  pMaxHostSlots  = null;
}
{
  <KEY_ADD> EQ() kname=KeyName() AE() (LicenseKeyAddOpts())* 
  {
    pApp.addLicenseKey(kname, pMessage, pLicenseScheme, pMaxSlots, pMaxHosts, pMaxHostSlots,
		       pQueueMgrClient);
  }
}
 
void
LicenseKeyAddOpts() 
  throws PipelineException : 
{}
{
  (Msg() | PerSlot() | PerHost() | PerHostSlot() | MaxSlots() | MaxHosts() | MaxHostSlots())
  {}
}

void 
LicenseKeySet() 
  throws PipelineException : 
{
  String kname   = null;
  pLicenseScheme = null;
  pMaxSlots      = null;
  pMaxHosts      = null;
  pMaxHostSlots  = null;
}
{
  <KEY_SET> EQ() kname=KeyName() AE() (LicenseKeyAddOpts())* 
  {
    pApp.setLicenseKey(kname, pLicenseScheme, pMaxSlots, pMaxHosts, pMaxHostSlots,
		       pQueueMgrClient);
  }
}
 
void
LicenseKeySetOpts() 
  throws PipelineException : 
{}
{
  (PerSlot() | PerHost() | PerHostSlot() | MaxSlots() | MaxHosts() | MaxHostSlots())
  {}
}

void 
LicenseKeyRemove() 
  throws PipelineException : 
{
  String kname = null;
}
{
  <KEY_REMOVE> EQ() kname=KeyName() AE()
  {
    pQueueMgrClient.removeLicenseKey(kname);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Removed license key (" + kname + ").");
    LogMgr.getInstance().flush();
  }
}


/*------------------------------------------------------------------------------------------*/

void 
SelectionKeyCmds() 
  throws PipelineException : 
{}
{
  <SELECTION_KEY1> AE() 
     (SelectionKeyGet() | SelectionKeyGetInfo() | SelectionKeyGetInfoAll() | 
      SelectionKeyAdd() | SelectionKeyRemove())
  {}
}

void 
SelectionKeyGet() 
  throws PipelineException : 
{}
{
  <KEY_GET> AE()
  {
    TreeSet knames = pQueueMgrClient.getSelectionKeyNames();
    Iterator iter = knames.iterator();
    while(iter.hasNext()) {
      String kname = (String) iter.next();
      LogMgr.getInstance().log
	(LogMgr.Kind.Ops, LogMgr.Level.Info,
	 kname);
    }
    LogMgr.getInstance().flush();    
  }
}

void 
SelectionKeyGetInfo() 
  throws PipelineException : 
{
  String kname = null;
}
{
  <KEY_GET_INFO> EQ() kname=KeyName() AE()
  {
    pApp.printSelectionKey(kname, pQueueMgrClient);
  }
}

void 
SelectionKeyGetInfoAll() 
  throws PipelineException : 
{}
{
  <KEY_GET_INFO_ALL> AE()
  {
    pApp.printSelectionKey(null, pQueueMgrClient);
  }
}

void 
SelectionKeyAdd() 
  throws PipelineException : 
{
  String kname = null;
  pMessage     = null;
}
{
  <KEY_ADD> EQ() kname=KeyName() AE() Msg()
  {
    if(pMessage == null) 
      throw new PipelineException("The --msg option is required!");

    SelectionKey key = new SelectionKey(kname, pMessage);
    pQueueMgrClient.addSelectionKey(key);
    
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Added selection key (" + kname + ").");
    LogMgr.getInstance().flush();
  }
}
 
void 
SelectionKeyRemove() 
  throws PipelineException : 
{
  String kname = null;
}
{
  <KEY_REMOVE> EQ() kname=KeyName() AE()
  {
    pQueueMgrClient.removeSelectionKey(kname);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Removed selection key (" + kname + ").");
    LogMgr.getInstance().flush();
  }
}


/*------------------------------------------------------------------------------------------*/

void 
JobServerCmds() 
  throws PipelineException : 
{}
{
  <JOB_SERVER> AE() 
     (JobServerGet() | JobServerGetInfo() | JobServerGetInfoAll() | JobServerGetHistograms() |
      JobServerAdd() | JobServerSet() | JobServerRemove())
  {}
}

void 
JobServerGet() 
  throws PipelineException : 
{}
{
  <JOB_GET> AE()
  {
    TreeMap hosts = pQueueMgrClient.getHosts();
    Iterator iter = hosts.keySet().iterator();
    while(iter.hasNext()) {
      String hname = (String) iter.next();
      LogMgr.getInstance().log
	(LogMgr.Kind.Ops, LogMgr.Level.Info,
	 hname);
    }
    LogMgr.getInstance().flush();    
  }
}

void 
JobServerGetInfo() 
  throws PipelineException : 
{
  String hname = null;
}
{
  <JOB_GET_INFO> EQ() hname=HostName() AE()
  {
    pApp.printHosts(hname, pQueueMgrClient);
  }
}

void 
JobServerGetInfoAll() 
  throws PipelineException : 
{}
{
  <JOB_GET_INFO_ALL> AE()
  {
    pApp.printHosts(null, pQueueMgrClient);
  }
}

void 
JobServerGetHistograms() 
  throws PipelineException : 
{}
{
  <JOB_GET_HISTOGRAMS> AE()
  {
    pApp.printHistograms(pQueueMgrClient);
  }
}

void 
JobServerAdd() 
  throws PipelineException : 
{
  String hname = null;
}
{
  <JOB_ADD> EQ() hname=HostName() AE()
  {
    pQueueMgrClient.addHost(hname);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Added job server (" + hname + ").");
    LogMgr.getInstance().flush();
  }
}

void 
JobServerSet() 
  throws PipelineException : 
{
  String hname = null;

  pJobStatus              = null;
  pJobReserve             = null;
  pSetJobReserve          = false;
  pJobOrder               = null;
  pJobSlots               = null;
  pJobSelectionSchedule   = null;
  pJobNoSelectionSchedule = false;
  pJobSelectionGroup      = null;
  pJobNoSelectionGroup    = false;
}
{
  <JOB_SET> EQ() hname=HostName() AE() (JobServerSetOption())+
  {
    if((pJobSelectionSchedule != null) && pJobNoSelectionSchedule) 
      throw new PipelineException
        ("The --selection-schedule and --no-selection-schedule options are " + 
	 "mutually exclusive!");
    
    if((pJobSelectionGroup != null) && pJobNoSelectionGroup) 
      throw new PipelineException
        ("The --selection-group and --no-selection-group options are mutually exclusive!");
    
    pApp.editHost(hname, 
		  pJobStatus, pJobReserve, pSetJobReserve, pJobOrder, pJobSlots,
		  pJobSelectionSchedule, pJobNoSelectionSchedule, 
		  pJobSelectionGroup, pJobNoSelectionGroup, 
		  pQueueMgrClient);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Modified properties of job server (" + hname + ").");
    LogMgr.getInstance().flush();
  }
}

void 
JobServerSetOption()
  throws PipelineException :
{}
{
  (JobServerShutdown() | JobServerEnable() | JobServerDisable() | 
   JobServerReserve() | JobServerOrder() | JobServerSlots() | 
   JobServerSelectionSchedule() | JobServerNoSelectionSchedule() |
   JobServerSelectionGroup() | JobServerNoSelectionGroup())
  {}
}

void 
JobServerShutdown() :
{}
{
  Shutdown() AE()
  {
    if(pJobStatus != null) 
      throw new ParseException
	("The --shutdown, --enable and --disable options are mutually exclusive!");
    pJobStatus = QueueHostStatusChange.Terminate;
  }
}

void 
JobServerEnable() :
{}
{
  <ENABLE> AE()
  {
    if(pJobStatus != null) 
      throw new ParseException
	("The --shutdown, --enable and --disable options are mutually exclusive!");
    pJobStatus = QueueHostStatusChange.Enable;
  }
}

void 
JobServerDisable() :
{}
{
  <DISABLE> AE()
  {
    if(pJobStatus != null) 
      throw new ParseException
	("The --shutdown, --enable and --disable options are mutually exclusive!");
    pJobStatus = QueueHostStatusChange.Disable;
  }
}

void 
JobServerReserve() :
{
  String name    = null;
  pSetJobReserve = true;
}
{
  ((<RESERVE> EQ() name=UserName()) | <OPEN>) AE()
  {
    pJobReserve = name;
  }
}

void
JobServerOrder()
  throws PipelineException : 
{
  Integer order = null;
}
{
  <ORDER> EQ() order=IntegerLiteral() AE()
  {
    pJobOrder = order;
  }
}

void
JobServerSlots()
  throws PipelineException : 
{
  Integer slots = null;
}
{
  <SLOTS> EQ() slots=IntegerLiteral() AE()
  {
    pJobSlots = slots;
  }
}

void 
JobServerSelectionSchedule()
  throws PipelineException : 
{
  String sname;
}
{
  <SEL_SCHEDULE> EQ() sname=SelectionScheduleName() AE()
  {
    pJobSelectionSchedule = sname; 
  }  
}

void 
JobServerNoSelectionSchedule() : 
{}
{
  <NO_SEL_SCHEDULE> AE()
  {
    pJobNoSelectionSchedule = true; 
  }
}
  
void 
JobServerSelectionGroup()
  throws PipelineException : 
{
  String sname;
}
{
  <SEL_GROUP> EQ() sname=SelectionGroupName() AE()
  {
    pJobSelectionGroup = sname; 
  }  
}

void 
JobServerNoSelectionGroup() : 
{}
{
  <NO_SEL_GROUP> AE()
  {
    pJobNoSelectionGroup = true; 
  }
}
  

void 
JobServerRemove() 
  throws PipelineException : 
{
  String hname = null;
}
{
  <JOB_REMOVE> EQ() hname=KeyName() AE()
  {
    pApp.removeHost(hname, pQueueMgrClient);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Removed job server (" + hname + ").");
    LogMgr.getInstance().flush();
  }
}


/*------------------------------------------------------------------------------------------*/
/*   P L U G I N S                                                                          */
/*------------------------------------------------------------------------------------------*/

void 
EditorCmds() 
  throws PipelineException : 
{}
{
  <EDITOR1> AE() 
     (EditorGet() | EditorGetInfo() | EditorGetInfoAll())
  {}
}

void 
EditorGet() 
  throws PipelineException : 
{}
{
  <EDITOR_GET> AE()
  {
    TreeMap table = PluginMgrClient.getInstance().getEditors();
    Iterator iter = table.keySet().iterator();
    while(iter.hasNext()) {
      String name      = (String) iter.next();
      TreeSet versions = (TreeSet) table.get(name);
      
      Iterator viter = versions.iterator();
      while(viter.hasNext()) {
	VersionID vid = (VersionID) viter.next();
	LogMgr.getInstance().log
	  (LogMgr.Kind.Ops, LogMgr.Level.Info,
	   name + " (v" + vid + ")");
      }
    }
    
    LogMgr.getInstance().flush();
  }
}

void 
EditorGetInfo() 
  throws PipelineException : 
{
  String name = null;
  VersionID vid = null;
  String vendor = null;
}
{
  <EDITOR_GET_INFO> EQ() name=EditorName() 
    (COLON() vid=RevisionNumber())? (COMMA() vendor=VendorName())? AE()
  {
    BaseEditor plg = PluginMgrClient.getInstance().newEditor(name, vid, vendor);
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       plg.toString());
    LogMgr.getInstance().flush();
  }
}

void 
EditorGetInfoAll() 
  throws PipelineException : 
{}
{
  <EDITOR_GET_INFO_ALL> AE()
  {
    pApp.editorGetInfoAll();
  }
}


/*------------------------------------------------------------------------------------------*/

void 
ActionCmds() 
  throws PipelineException : 
{}
{
  <ACTION1> AE() 
     (ActionGet() | ActionGetInfo() | ActionGetInfoAll())
  {}
}

void 
ActionGet() 
  throws PipelineException : 
{}
{
  <ACTION_GET> AE()
  {
    TreeMap table = PluginMgrClient.getInstance().getActions();
    Iterator iter = table.keySet().iterator();
    while(iter.hasNext()) {
      String name      = (String) iter.next();
      TreeSet versions = (TreeSet) table.get(name);
      
      Iterator viter = versions.iterator();
      while(viter.hasNext()) {
	VersionID vid = (VersionID) viter.next();
	LogMgr.getInstance().log
	  (LogMgr.Kind.Ops, LogMgr.Level.Info,
	   name + " (v" + vid + ")");
      }
    }
    
    LogMgr.getInstance().flush();
  }
}

void 
ActionGetInfo() 
  throws PipelineException : 
{
  String name = null;
  VersionID vid = null;
  String vendor = null;
}
{
  <ACTION_GET_INFO> EQ() name=ActionName()
    (COLON() vid=RevisionNumber())? (COMMA() vendor=VendorName())? AE()
  {
    BaseAction plg = PluginMgrClient.getInstance().newAction(name, vid, vendor);
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       plg.toString());
    LogMgr.getInstance().flush();
  }
}

void 
ActionGetInfoAll() 
  throws PipelineException : 
{}
{
  <ACTION_GET_INFO_ALL> AE()
  {
    pApp.actionGetInfoAll();
  }
}


/*------------------------------------------------------------------------------------------*/

void 
ComparatorCmds() 
  throws PipelineException : 
{}
{
  <COMPARATOR> AE() 
     (ComparatorGet() | ComparatorGetInfo() | ComparatorGetInfoAll())
  {}
}

void 
ComparatorGet() 
  throws PipelineException : 
{}
{
  <COMPARATOR_GET> AE()
  {
    TreeMap table = PluginMgrClient.getInstance().getComparators();
    Iterator iter = table.keySet().iterator();
    while(iter.hasNext()) {
      String name      = (String) iter.next();
      TreeSet versions = (TreeSet) table.get(name);
      
      Iterator viter = versions.iterator();
      while(viter.hasNext()) {
	VersionID vid = (VersionID) viter.next();
	LogMgr.getInstance().log
	  (LogMgr.Kind.Ops, LogMgr.Level.Info,
	   name + " (v" + vid + ")");
      }
    }
    
    LogMgr.getInstance().flush();
  }
}

void 
ComparatorGetInfo() 
  throws PipelineException : 
{
  String name = null;
  VersionID vid = null;
  String vendor = null;
}
{
  <COMPARATOR_GET_INFO> EQ() name=ComparatorName() 
    (COLON() vid=RevisionNumber())? (COMMA() vendor=VendorName())? AE()
  {
    BaseComparator plg = PluginMgrClient.getInstance().newComparator(name, vid, vendor);
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       plg.toString());
    LogMgr.getInstance().flush();
  }
}

void 
ComparatorGetInfoAll() 
  throws PipelineException : 
{}
{
  <COMPARATOR_GET_INFO_ALL> AE()
  {
    pApp.comparatorGetInfoAll();
  }
}


/*------------------------------------------------------------------------------------------*/

void 
ToolCmds() 
  throws PipelineException : 
{}
{
  <TOOL> AE() 
     (ToolGet() | ToolGetInfo() | ToolGetInfoAll())
  {}
}

void 
ToolGet() 
  throws PipelineException : 
{}
{
  <TOOL_GET> AE()
  {
    TreeMap table = PluginMgrClient.getInstance().getTools();
    Iterator iter = table.keySet().iterator();
    while(iter.hasNext()) {
      String name      = (String) iter.next();
      TreeSet versions = (TreeSet) table.get(name);
      
      Iterator viter = versions.iterator();
      while(viter.hasNext()) {
	VersionID vid = (VersionID) viter.next();
	LogMgr.getInstance().log
	  (LogMgr.Kind.Ops, LogMgr.Level.Info,
	   name + " (v" + vid + ")");
      }
    }
    
    LogMgr.getInstance().flush();
  }
}

void 
ToolGetInfo() 
  throws PipelineException : 
{
  String name = null;
  VersionID vid = null;
  String vendor = null;
}
{
  <TOOL_GET_INFO> EQ() name=ToolName() 
    (COLON() vid=RevisionNumber())? (COMMA() vendor=VendorName())? AE()
  {
    BaseTool plg = PluginMgrClient.getInstance().newTool(name, vid, vendor);
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       plg.toString());
    LogMgr.getInstance().flush();
  }
}

void 
ToolGetInfoAll() 
  throws PipelineException : 
{}
{
  <TOOL_GET_INFO_ALL> AE()
  {
    pApp.toolGetInfoAll();
  }
}


/*------------------------------------------------------------------------------------------*/

void 
ArchiverCmds() 
  throws PipelineException : 
{}
{
  <ARCHIVER> AE() 
     (ArchiverGet() | ArchiverGetInfo() | ArchiverGetInfoAll())
  {}
}

void 
ArchiverGet() 
  throws PipelineException : 
{}
{
  <ARCHIVER_GET> AE()
  {
    TreeMap table = PluginMgrClient.getInstance().getArchivers();
    Iterator iter = table.keySet().iterator();
    while(iter.hasNext()) {
      String name      = (String) iter.next();
      TreeSet versions = (TreeSet) table.get(name);
      
      Iterator viter = versions.iterator();
      while(viter.hasNext()) {
	VersionID vid = (VersionID) viter.next();
	LogMgr.getInstance().log
	  (LogMgr.Kind.Ops, LogMgr.Level.Info,
	   name + " (v" + vid + ")");
      }
    }
    
    LogMgr.getInstance().flush();
  }
}

void 
ArchiverGetInfo() 
  throws PipelineException : 
{
  String name = null;
  VersionID vid = null;
  String vendor = null;
}
{
  <ARCHIVER_GET_INFO> EQ() name=ArchiverName() 
    (COLON() vid=RevisionNumber())? (COMMA() vendor=VendorName())? AE()
  {
    BaseArchiver plg = PluginMgrClient.getInstance().newArchiver(name, vid, vendor);
    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       plg.toString());
    LogMgr.getInstance().flush();
  }
}

void 
ArchiverGetInfoAll() 
  throws PipelineException : 
{}
{
  <ARCHIVER_GET_INFO_ALL> AE()
  {
    pApp.archiverGetInfoAll();
  }
}



/*------------------------------------------------------------------------------------------*/
/*   U S E R    P R E F E R E N C E S                                                       */
/*------------------------------------------------------------------------------------------*/

void 
SuffixEditorCmds() 
  throws PipelineException : 
{}
{
  <SUFFIX_EDITOR> AE() 
     (SuffixEditorGet() | SuffixEditorGetInfo() | SuffixEditorGetInfoAll() | 
      SuffixEditorSet() | SuffixEditorRemove() | SuffixEditorReset())
  {}
}

void 
SuffixEditorGet() 
  throws PipelineException : 
{}
{
  <SUFFIX_EDITOR_GET> AE()
  {
    TreeSet editors = pMasterMgrClient.getSuffixEditors();
    Iterator iter = editors.iterator();
    while(iter.hasNext()) {
      SuffixEditor se = (SuffixEditor) iter.next();
      LogMgr.getInstance().log
	(LogMgr.Kind.Ops, LogMgr.Level.Info,
	 se.getSuffix());
    }
    LogMgr.getInstance().flush();    
  }
}

void 
SuffixEditorGetInfo() 
  throws PipelineException : 
{
  String suffix = null;
}
{
  <SUFFIX_EDITOR_GET_INFO> EQ() suffix=Suffix() AE()
  {
    pApp.printSuffixEditor(suffix, pMasterMgrClient);
  }
}

void 
SuffixEditorGetInfoAll() 
  throws PipelineException : 
{}
{
  <SUFFIX_EDITOR_GET_INFO_ALL> AE()
  {
    pApp.printSuffixEditor(null, pMasterMgrClient);
  }
}

void 
SuffixEditorSet() 
  throws PipelineException : 
{
  String suffix = null;

  pEditorName      = null;
  pEditorVersionID = null;
  pEditorVendor    = null; 
  pMessage         = null; 
}
{
  <SUFFIX_EDITOR_SET> EQ() suffix=Suffix() AE() (SuffixEditorSetOpts())* 
  {
    if(pEditorName == null) 
      throw new PipelineException("The --editor option is required!");

    if(pMessage == null) 
      throw new PipelineException("The --msg option is required!");

    pApp.addSuffixEditor(suffix, pMessage, 
			 pEditorName, pEditorVersionID, pEditorVendor, 
			 pMasterMgrClient);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Added default editor for suffix (" + suffix + ").");
    LogMgr.getInstance().flush();
  }
}

void
SuffixEditorSetOpts() 
  throws PipelineException : 
{}
{
  (Msg() | Editor())
  {}
}
  
void 
SuffixEditorRemove() 
  throws PipelineException : 
{
  String suffix = null;
}
{
  <SUFFIX_EDITOR_REMOVE> EQ() suffix=Suffix() AE() 
  {
    pApp.removeSuffixEditor(suffix, pMasterMgrClient);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Removed default editor for suffix (" + suffix + ").");
    LogMgr.getInstance().flush();
  }
}

void 
SuffixEditorReset() 
  throws PipelineException : 
{}
{
  <SUFFIX_EDITOR_RESET> AE() 
  {
    pApp.resetSuffixEditors(pMasterMgrClient);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Reset suffix editors to site defaults.");
    LogMgr.getInstance().flush();
  }
}


  
/*------------------------------------------------------------------------------------------*/
/*   V I E W   C O M M A N D S                                                              */
/*------------------------------------------------------------------------------------------*/

void 
ViewCmds() 
  throws PipelineException : 
{}
{
  <VIEW1> AE() 
     (ViewGet() | ViewCreate() | ViewRelease()) 
  {}
}


void 
ViewGet() 
  throws PipelineException : 
{
  pAuthor = PackageInfo.sUser;
}
{
  <VIEW_GET> AE() (ViewGetOpts())*
  {
    TreeMap table = pMasterMgrClient.getWorkingAreas();
    TreeSet views = (TreeSet) table.get(pAuthor);
    Iterator iter = views.iterator();
    while(iter.hasNext()) {
      String vname = (String) iter.next();
      LogMgr.getInstance().log
	(LogMgr.Kind.Ops, LogMgr.Level.Info,
	 vname);
    }
    LogMgr.getInstance().flush();    
  }
}

void
ViewGetOpts() :
{}
{
  (Author()) 
  {}
}


void 
ViewCreate() 
  throws PipelineException : 
{
  String vname = null;
  pAuthor = PackageInfo.sUser;
}
{
  <VIEW_CREATE> EQ() vname=ViewName() AE() (ViewCreateOpts())*
  {
    pMasterMgrClient.createWorkingArea(pAuthor, vname);
  }
}

void
ViewCreateOpts() :
{}
{
  (Author()) 
  {}
}


void 
ViewRelease() 
  throws PipelineException : 
{
  String vname = null;

  pAuthor      = PackageInfo.sUser;
  pViewPattern = null;
  pRemoveFiles = false;
  pRemoveArea  = false; 
}
{
  <VIEW_RELEASE> EQ() vname=ViewName() AE() (ViewReleaseOpts())*
  {
    pApp.releaseView(pAuthor, vname, pViewPattern, pRemoveFiles, pRemoveArea, 
		     pMasterMgrClient);
  }
}

void
ViewReleaseOpts() :
{}
{
  (Author() | ViewPattern() | RemoveFiles() | RemoveArea())
  {}
}


void 
ViewPattern() : 
{
  String p;
}
{
  <PATTERN> EQ() p=StringLiteral() AE()
  {
    if((p != null) && (p.length() > 0))
      pViewPattern = p;
  }
}



/*------------------------------------------------------------------------------------------*/
/*   W O R K I N G   N O D E   V E R S I O N   C O M M A N D S                              */
/*------------------------------------------------------------------------------------------*/

void 
WorkingCmds() 
  throws PipelineException : 
{}
{
  <WORKING> AE() 
     (WorkingGetInfo() | WorkingRegister() | WorkingClone() | WorkingRelease() | 
      WorkingSet() | WorkingLink() | WorkingUnlink() | WorkingAddSecondary() | 
      WorkingRemoveSecondary() | WorkingRename() | WorkingRenumber() | WorkingEdit() | 
      WorkingSubmitJobs() | WorkingRemoveFiles() | WorkingViewsContaining() | 
      WorkingViewsEditing())
  {}
}

/*------------------------------------------------------------------------------------------*/

void 
WorkingGetInfo() 
  throws PipelineException : 
{
  String name = null;

  pAuthor   = PackageInfo.sUser;
  pView     = "default";
  pSections = new TreeSet();
}
{
  <WORKING_GET_INFO> EQ() name=NodeName() AE() (WorkingGetInfoOpts())*
  {
    pApp.printWorkingVersion(new NodeID(pAuthor, pView, name), pSections, 
			     pMasterMgrClient, pQueueMgrClient);
  }
}

void
WorkingGetInfoOpts() :
{}
{
  (Author() | View() | WorkingGetInfoShow() | WorkingGetInfoHide()) 
  {}
}

void 
WorkingGetInfoShow() : 
{}
{
  <SHOW> EQ() WorkingGetInfoShowSections() (COMMA() WorkingGetInfoShowSections())* AE()  
  {}
}

void 
WorkingGetInfoShowSections() : 
{}
{
  (WorkingGetInfoShowAll() | 
   ShowVsn() | ShowProp() |  ShowAct() | ShowJReq() | ShowKey() | ShowLink()) 
  {}
}

void 
WorkingGetInfoShowAll() : 
{}
{
  <ALL>
  {
    pSections.add("vsn");
    pSections.add("prop");
    pSections.add("act");
    pSections.add("jreq");
    pSections.add("key");
    pSections.add("link");
  }
}

void 
WorkingGetInfoHide() : 
{}
{
  <HIDE> EQ() WorkingGetInfoHideSections() (COMMA() WorkingGetInfoHideSections())* AE()  
  {}
}

void 
WorkingGetInfoHideSections() : 
{}
{
  (WorkingGetInfoHideAll() | 
   HideVsn() | HideProp() | HideAct() | HideJReq() | HideKey() | HideLink()) 
  {}
}

void 
WorkingGetInfoHideAll() : 
{}
{
  <ALL>
  {
    pSections.clear(); 
  }
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingRegister() 
  throws PipelineException : 
{
  String name = null;

  pAuthor     = PackageInfo.sUser;
  pView       = "default";
  pFileSeq    = null;
  pToolset    = null;

  pEditorName      = null;
  pEditorVersionID = null;
  pEditorVendor    = null;
  pNoAction        = null;
  pActionName      = null;
  pActionVersionID = null; 
  pActionVendor    = null; 
  pActionEnabled   = null;
  pParams          = new TreeMap();
  pSourceParams    = new TreeMap();
  pOverflowPolicy  = null;
  pExecutionMethod = null;
  pBatchSize       = null;
  pPriority        = null;
  pRampUp          = null;
  pMaxLoad         = null;
  pMinMemory       = null;
  pMinDisk         = null;
  pLicenseKeys     = new TreeMap();
  pSelectionKeys   = new TreeMap();
}
{
  <WORKING_REGISTER> EQ() name=NodeName() AE() (WorkingRegisterOpts())*
  {
    if(pFileSeq == null) 
      throw new PipelineException
        ("The --fseq option is required!");

    pApp.workingVersionRegister
     (new NodeID(pAuthor, pView, name), pFileSeq, pToolset, 
      pEditorName, pEditorVersionID, pEditorVendor, 
      pNoAction, pActionName, pActionVersionID, pActionVendor, 
      pActionEnabled, pParams, pSourceParams, 
      pOverflowPolicy, pExecutionMethod, pBatchSize, 
      pPriority, pRampUp, pMaxLoad, pMinMemory, pMinDisk, 
      pLicenseKeys, pSelectionKeys,
      pMasterMgrClient);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Registered Node: " + name);
    LogMgr.getInstance().flush();
  }
}

void
WorkingRegisterOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | FSeq() | Toolset() | Editor() | 
   Action() | ActionEnabled() | Param() | SourceParam() | 
   Ignore() | Abort() | Serial() | Subdivided() | Parallel() | BatchSize() | 
   Priority() | RampUp() | MaxLoad() | MinMemory() | MinDisk() | 
   LicenseKey() | SelectionKey()) 
  {}
}

/*------------------------------------------------------------------------------------------*/

void 
WorkingClone() 
  throws PipelineException : 
{
  String name = null;

  pAuthor      = PackageInfo.sUser;
  pView        = "default";
  pCloneSource = null;
}
{
  <WORKING_CLONE> EQ() name=NodeName() AE() (WorkingCloneOpts())*
  {
    if(pCloneSource == null) 
      throw new PipelineException
        ("The --clone-source option is required!");

    pMasterMgrClient.clone(pAuthor, pView, pCloneSource, name); 

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Cloned Node: " + name);
    LogMgr.getInstance().flush();
  }
}

void
WorkingCloneOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | CloneSource()) 
  {}
}

void
CloneSource() : 
{
  String sname = null;
}
{
  <CLONE_SOURCE> EQ() sname=NodeName() AE()
  {
    pCloneSource = sname;
  }
}





/*------------------------------------------------------------------------------------------*/

void 
WorkingRelease() 
  throws PipelineException : 
{
  String name = null;
  
  pAuthor      = PackageInfo.sUser;
  pView        = "default";
  pRemoveFiles = false;
}
{
  <WORKING_RELEASE> EQ() name=NodeName() AE() (WorkingReleaseOpts())* 
  {
    pMasterMgrClient.release(new NodeID(pAuthor, pView, name), pRemoveFiles);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Released Node: " + name);
    LogMgr.getInstance().flush();
  }
}

void
WorkingReleaseOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | RemoveFiles()) 
  {}
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingSet() 
  throws PipelineException : 
{
  String name = null;

  pAuthor      = PackageInfo.sUser;
  pView        = "default";
  pToolset     = null;

  pEditorName      = null;
  pEditorVersionID = null;
  pEditorVendor    = null;
  pNoAction        = null;
  pActionName      = null;
  pActionVersionID = null; 
  pActionVendor    = null;
  pActionEnabled   = null;
  pParams          = new TreeMap();
  pSourceParams    = new TreeMap();
  pOverflowPolicy  = null;
  pExecutionMethod = null;
  pBatchSize       = null;
  pPriority        = null;
  pRampUp          = null;
  pMaxLoad         = null;
  pMinMemory       = null;
  pMinDisk         = null;
  pLicenseKeys     = new TreeMap();
  pSelectionKeys   = new TreeMap();
}
{
  <WORKING_SET> EQ() name=NodeName() AE() (WorkingSetOpts())*
  {
    pApp.workingVersionSet
      (new NodeID(pAuthor, pView, name), pToolset, 
       pEditorName, pEditorVersionID, pEditorVendor, 
       pNoAction, pActionName, pActionVersionID, pActionVendor, 
       pActionEnabled, pParams, pSourceParams, 
       pOverflowPolicy, pExecutionMethod, pBatchSize, 
       pPriority, pRampUp, pMaxLoad, pMinMemory, pMinDisk, 
       pLicenseKeys, pSelectionKeys,
       pMasterMgrClient);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Node Properties Set: " + name);
    LogMgr.getInstance().flush();
  }
}

void
WorkingSetOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | Toolset() | Editor() | 
   NoAction() | Action() | ActionEnabled() | Param() | NoParam() | SourceParam() | 
   Ignore() | Abort() | Serial() | Subdivided() | Parallel() | BatchSize() | 
   Priority() | RampUp() | MaxLoad() | MinMemory() | MinDisk() | 
   LicenseKey() | SelectionKey()) 
  {}
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingLink() 
  throws PipelineException : 
{
  String name = null;
  
  pAuthor  = PackageInfo.sUser;
  pView    = "default";

  pLinkSourceName = null;
}
{
  <WORKING_LINK> EQ() name=NodeName() AE() (WorkingLinkOpts())* 
  {
    if(pLinkSourceName == null) 
      throw new PipelineException
        ("No link source node was specified with a --ref or --depend option!");

    pMasterMgrClient.link(pAuthor, pView, name, 
			  pLinkSourceName, pLinkPolicy, pLinkRelationship, pLinkFrameOffset);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Linked Nodes: " + pLinkSourceName + " to " + name);
    LogMgr.getInstance().flush();
  }
}

void
WorkingLinkOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | Ref() | Depend()) 
  {}
}

void
Ref()
  throws PipelineException : 
{
  String sname = null;

  pLinkRelationship = LinkRelationship.All;
  pLinkFrameOffset  = null;
}
{
  <REF> EQ() sname=LinkName() (COMMA() (LinkAll() | LinkFrameOffset()))? AE()
  {
    if(pLinkSourceName != null) 
      throw new PipelineException
        ("The --ref and --depend options are mutually exclusive!");

    pLinkSourceName = sname;
    pLinkPolicy     = LinkPolicy.Reference; 
  }
}

void
Depend()
  throws PipelineException : 
{
  String sname = null;

  pLinkRelationship = LinkRelationship.All;
  pLinkFrameOffset  = null;
}
{
  <DEPEND> EQ() sname=LinkName() (COMMA() (LinkAll() | LinkFrameOffset()))? AE() 
  {
    if(pLinkSourceName != null) 
      throw new PipelineException
        ("The --ref and --depend options are mutually exclusive!");

    pLinkSourceName = sname;
    pLinkPolicy     = LinkPolicy.Dependency;
  }
}

void 
LinkAll() : 
{}
{
  <LINK_ALL>
  {
    pLinkRelationship = LinkRelationship.All;
  }
}

void 
LinkFrameOffset()
  throws PipelineException :  
{
  Token t;
}
{
  t=<OFFSET> 
  {
    try {
      pLinkFrameOffset = new Integer(t.image);
      pLinkRelationship = LinkRelationship.OneToOne;
    }
    catch(NumberFormatException ex) {
      throw new PipelineException(ex.getMessage());
    }
  }
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingUnlink() 
  throws PipelineException : 
{
  String name = null;
  
  pAuthor  = PackageInfo.sUser;
  pView    = "default";

  pLinkSourceName = null;
}
{
  <WORKING_UNLINK> EQ() name=NodeName() AE() (WorkingUnlinkOpts())* 
  {
    if(pLinkSourceName == null) 
      throw new PipelineException
        ("No link source node was specified with the --source option!");

    pMasterMgrClient.unlink(pAuthor, pView, name, pLinkSourceName);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Unlinked Nodes: " + pLinkSourceName + " from " + name);
    LogMgr.getInstance().flush();
  }
}

void
WorkingUnlinkOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | LinkSource()) 
  {}
}

void
LinkSource() : 
{
  String sname = null;
}
{
  <SOURCE> EQ() sname=LinkName() AE()
  {
    pLinkSourceName = sname;
  }
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingAddSecondary() 
  throws PipelineException : 
{
  String name = null;
  
  pAuthor  = PackageInfo.sUser;
  pView    = "default";
  pFileSeq = null; 
}
{
  <WORKING_ADD_SECONDARY> EQ() name=NodeName() AE() (WorkingSecondaryOpts())* 
  {
    if(pFileSeq == null) 
      throw new PipelineException
        ("The --fseq option is required!");

    pMasterMgrClient.addSecondary(new NodeID(pAuthor, pView, name), pFileSeq);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Added Secondary: " + pFileSeq + " to " + name);
    LogMgr.getInstance().flush();
  }
}

void 
WorkingRemoveSecondary() 
  throws PipelineException : 
{
  String name = null;
  
  pAuthor  = PackageInfo.sUser;
  pView    = "default";
  pFileSeq = null; 
}
{
  <WORKING_REMOVE_SECONDARY> EQ() name=NodeName() AE() (WorkingSecondaryOpts())* 
  {
    if(pFileSeq == null) 
      throw new PipelineException
        ("The --fseq option is required!");

    pMasterMgrClient.removeSecondary(new NodeID(pAuthor, pView, name), pFileSeq);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Removed Secondary: " + pFileSeq + " from " + name);
    LogMgr.getInstance().flush();
  }
}

void
WorkingSecondaryOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | FSeq()) 
  {}
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingRename() 
  throws PipelineException : 
{
  String name = null;
  
  pAuthor         = PackageInfo.sUser;
  pView           = "default";
  pNewFilePattern = null; 
  pRenameFiles    = false;
}
{
  <WORKING_RENAME> EQ() name=NodeName() AE() (WorkingRenameOpts())* 
  {
    if(pNewFilePattern == null) 
      throw new PipelineException
        ("The --file-pattern option is required!");

    pMasterMgrClient.rename(new NodeID(pAuthor, pView, name), pNewFilePattern, pRenameFiles);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Renamed: " + name + " to " + pNewFilePattern);
    LogMgr.getInstance().flush();    
  }
}

void
WorkingRenameOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | FilePattern() | RenameFiles())
  {}
}

void 
FilePattern() : 
{
  String prefix = null;
  String suffix = null;
}
{
  <FILE_PATTERN> EQ() prefix=FilePatPrefix() 
     (DOT() ((Padding() (DOT() suffix=FilePatSuffix())?) | suffix=FilePatSuffix()))? AE()
  {
    if(pPadding == null) 
      pNewFilePattern = new FilePattern(prefix, suffix);
    else 
      pNewFilePattern = new FilePattern(prefix, pPadding, suffix);
  }
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingRenumber() 
  throws PipelineException : 
{
  String name = null;
  
  pAuthor      = PackageInfo.sUser;
  pView        = "default";
  pFrameRange  = null;
  pRemoveFiles = false;
}
{
  <WORKING_RENUMBER> EQ() name=NodeName() AE() (WorkingRenumberOpts())* 
  {
    if(pFrameRange == null) 
      throw new PipelineException
        ("The --range option is required!");

    pMasterMgrClient.renumber(new NodeID(pAuthor, pView, name), pFrameRange, pRemoveFiles);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Renumbered: " + name);
    LogMgr.getInstance().flush();    
  }
}

void
WorkingRenumberOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | Range() | RemoveFiles())
  {}
}

void 
Range()
  throws PipelineException : 
{
  Integer start = null;
  Integer end   = null;
  Integer by    = 1;
}
{
  <RANGE> EQ() start=FrameNumber() (DASH() end=FrameNumber() (<BY> by=FrameNumber())?)? AE()
  {
    try {
      if(end == null) 
        pFrameRange = new FrameRange(start);
      else 
        pFrameRange = new FrameRange(start, end, by);
    }
    catch(IllegalArgumentException ex) {
      throw new PipelineException(ex.getMessage());
    }
  }
}

/*------------------------------------------------------------------------------------------*/

void 
WorkingEdit() 
  throws PipelineException : 
{
  String name = null;
  
  pAuthor     = PackageInfo.sUser;
  pView       = "default";

  pEditorName      = null;
  pEditorVersionID = null;
  pEditorVendor    = null;

  pFrames     = new ArrayList();
  pIndices    = new ArrayList();
  pFileSeq    = null;  
  pWait       = false;
}
{
  <WORKING_EDIT> EQ() name=NodeName() AE() (WorkingEditOpts())* 
  {
    if((!pFrames.isEmpty() && !pIndices.isEmpty()) || 
       (pFileSeq != null) && ((!pFrames.isEmpty() || !pIndices.isEmpty())))
      throw new PipelineException
        ("The --frame, --index and --fseq options are mutually exclusive!");

     pApp.workingEdit(new NodeID(pAuthor, pView, name), 
		      pEditorName, pEditorVersionID, pEditorVendor, 
		      pFrames, pIndices, pFileSeq, pWait, pMasterMgrClient);
  }
}

void
WorkingEditOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | Editor() | Frame() | Index() | FSeq() | Wait())
  {}
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingSubmitJobs() 
  throws PipelineException : 
{
  String name = null;
  
  pAuthor   = PackageInfo.sUser;
  pView     = "default";
  pFrames   = new ArrayList();
  pIndices  = new ArrayList();
  pWait     = false;
}
{
  <WORKING_SUBMIT_JOBS> EQ() name=NodeName() AE() (WorkingSubmitJobsOpts())* 
  {
    if(!pFrames.isEmpty() && !pIndices.isEmpty())
      throw new PipelineException
        ("The --frame and --index options are mutually exclusive!");

    pApp.workingSubmitJobs(new NodeID(pAuthor, pView, name), 
			   pFrames, pIndices, pWait, 
			   pMasterMgrClient, pQueueMgrClient);
  }
}

void
WorkingSubmitJobsOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | Frame() | Index() | Wait())
  {}
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingRemoveFiles() 
  throws PipelineException : 
{
  String name = null;
  
  pAuthor          = PackageInfo.sUser;
  pView            = "default";
  pFrames          = new ArrayList();
  pIndices         = new ArrayList();
}
{
  <WORKING_REMOVE_FILES> EQ() name=NodeName() AE() (WorkingRemoveFilesOpts())* 
  {
    if(!pFrames.isEmpty() && !pIndices.isEmpty())
      throw new PipelineException
        ("The --frame and --index options are mutually exclusive!");

    pApp.workingRemoveFiles(new NodeID(pAuthor, pView, name), 
			    pFrames, pIndices, pMasterMgrClient);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Removed Files: " + name);
    LogMgr.getInstance().flush();    
  }
}

void
WorkingRemoveFilesOpts()
  throws PipelineException : 
{}
{
  (Author() | View() | Frame() | Index())
  {}
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingViewsContaining() 
  throws PipelineException : 
{
  String name = null;
}
{
  <WORKING_VIEWS_CONTAINING> EQ() name=NodeName() AE()
  {
    pApp.viewsContaining(name, pMasterMgrClient); 
  }
}


/*------------------------------------------------------------------------------------------*/

void 
WorkingViewsEditing() 
  throws PipelineException : 
{
  String name = null;
}
{
  <WORKING_VIEWS_EDITING> EQ() name=NodeName() AE()
  {
    pApp.viewsEditing(name, pMasterMgrClient); 
  }
}


/*------------------------------------------------------------------------------------------*/
/*   C H E C K E D - I N   N O D E   V E R S I O N   C O M M A N D S                        */
/*------------------------------------------------------------------------------------------*/

void 
CheckedInCmds() 
  throws PipelineException : 
{}
{
  <CHECKED_IN> AE() 
     (CheckedInGetInfo() | CheckedInHistory() | CheckedInView()) 
  {}
}

/*------------------------------------------------------------------------------------------*/

void 
CheckedInGetInfo() 
  throws PipelineException : 
{
  String name = null;

  pSections   = new TreeSet();
  pVersionIDs = new TreeSet();
  pLatest     = false;
}
{
  <CHECKED_IN_GET_INFO> EQ() name=NodeName() AE() (CheckedInGetInfoOpts())*
  {
    pApp.printCheckedInVersion(name, pVersionIDs, pLatest, pSections, 
			       pMasterMgrClient, pQueueMgrClient);
  }
}

void
CheckedInGetInfoOpts() 
  throws PipelineException : 
{}
{
  (VersionOption() | Latest() | CheckedInGetInfoShow() | CheckedInGetInfoHide()) 
  {}
}

void 
CheckedInGetInfoShow() : 
{}
{
  <SHOW> EQ() CheckedInGetInfoShowSections() (COMMA() CheckedInGetInfoShowSections())* AE()  
  {}
}

void 
CheckedInGetInfoShowSections() : 
{}
{
  (CheckedInGetInfoShowAll() | 
   ShowVsn() | ShowProp() |  ShowAct() | ShowJReq() | ShowKey() | ShowLink() | ShowDLink()) 
  {}
}

void 
CheckedInGetInfoShowAll() : 
{}
{
  <ALL>
  {
    pSections.add("vsn");
    pSections.add("prop");
    pSections.add("act");
    pSections.add("jreq");
    pSections.add("key");
    pSections.add("link");
    pSections.add("dlink");
  }
}

void 
CheckedInGetInfoHide() : 
{}
{
  <HIDE> EQ() CheckedInGetInfoHideSections() (COMMA() CheckedInGetInfoHideSections())* AE()  
  {}
}

void 
CheckedInGetInfoHideSections() : 
{}
{
  (CheckedInGetInfoHideAll() | 
   HideVsn() | HideProp() | HideAct() | HideJReq() | HideKey() | HideLink() | HideDLink()) 
  {}
}

void 
CheckedInGetInfoHideAll() : 
{}
{
  <ALL>
  {
    pSections.clear(); 
  }
}


/*------------------------------------------------------------------------------------------*/

void 
CheckedInHistory() 
  throws PipelineException : 
{
  String name = null;

  pVersionIDs = new TreeSet();
  pLatest     = false;
}
{
  <CHECKED_IN_HISTORY> EQ() name=NodeName() AE() (CheckedInHistoryOpts())*
  {
    pApp.printCheckedInHistory(name, pVersionIDs, pLatest, pMasterMgrClient);
  }
}

void
CheckedInHistoryOpts() 
  throws PipelineException : 
{}
{
  (VersionOption() | Latest()) 
  {}
}


/*------------------------------------------------------------------------------------------*/

void 
CheckedInView() 
  throws PipelineException : 
{
  String name = null;
  
  pVersionIDs = new TreeSet();
  
  pEditorName      = null;
  pEditorVersionID = null;
  pEditorVendor    = null;

  pFrames     = new ArrayList();
  pIndices    = new ArrayList();
  pFileSeq    = null;  
  pWait       = false;
}
{
  <CHECKED_IN_VIEW> EQ() name=NodeName() AE() (CheckedInViewOpts())* 
  {
    if((!pFrames.isEmpty() && !pIndices.isEmpty()) || 
       (pFileSeq != null) && ((!pFrames.isEmpty() || !pIndices.isEmpty())))
      throw new PipelineException
        ("The --frame, --index and --fseq options are mutually exclusive!");

    VersionID vid = null;
    if(!pVersionIDs.isEmpty()) {
      if((pVersionIDs.size() > 1))
	throw new PipelineException
	  ("Only one version of a node may viewed by the --view option!");
	
      vid = (VersionID) pVersionIDs.first();
    }

    pApp.checkedInView(name, vid, 
		       pEditorName, pEditorVersionID, pEditorVendor, 
		       pFrames, pIndices, pFileSeq, pWait, pMasterMgrClient);
  }
}

void
CheckedInViewOpts()
  throws PipelineException : 
{}
{
  (VersionOption() | Editor() | Frame() | Index() | FSeq() | Wait())
  {}
}



/*------------------------------------------------------------------------------------------*/
/*   N O D E   O P E R A T I O N   C O M M A N D S                                          */
/*------------------------------------------------------------------------------------------*/

void 
NodeCmds() 
  throws PipelineException : 
{}
{
  <NODE> AE() 
     (NodeStatus() | NodeCheckIn() | NodeCheckOut() | NodeEvolve() | NodeGetEvents())
  {}
}


/*------------------------------------------------------------------------------------------*/

void 
NodeStatus() 
  throws PipelineException : 
{
  String name = null;

  pAuthor    = PackageInfo.sUser;
  pView      = "default";
  pBrief     = false;
  pUpstream  = false;
  pLight     = false;
  pLinkGraph = false;
  pGlue      = false;
  pSections  = new TreeSet();
}
{
  <NODE_STATUS> EQ() name=NodeName() AE() (NodeStatusOpts())*
  {
    if(pBrief && !pSections.isEmpty()) 
      throw new PipelineException
        ("The --brief and --show options are mutually exclusive!");

    pApp.printNodeStatus(new NodeID(pAuthor, pView, name), 
			 pBrief, pUpstream, pLight, pLinkGraph, pGlue, pSections, 
			 pMasterMgrClient, pQueueMgrClient);
  }
}

void
NodeStatusOpts() :
{}
{
  (Author() | View() | Brief() | Upstream() | Light() | LinkGraph() | 
   NodeStatusShow() | NodeStatusHide() | Glue()) 
  {}
}

void 
Brief() : 
{}
{
  <BRIEF> AE() 
  {
    pBrief = true;
  }
}

void 
Upstream() : 
{}
{
  <UPSTREAM> AE() 
  {
    pUpstream = true;
  }
}
 
void 
Light() : 
{}
{
  <LIGHT> AE() 
  {
    pLight = true;
  }
}

void 
LinkGraph() : 
{}
{
  <LINK_GRAPH> AE() 
  {
    pLinkGraph = true;
  }
}

void 
Glue() : 
{}
{
  <GLUE> AE() 
  {
    pGlue = true;
  }
}

void 
NodeStatusShow() : 
{}
{
  <SHOW> EQ() NodeStatusShowSections() (COMMA() NodeStatusShowSections())* AE()  
  {}
}

void 
NodeStatusShowSections() : 
{}
{
  (NodeStatusShowAll() | 
   ShowVsn() | ShowProp() |  ShowAct() | ShowJReq() | ShowKey() | ShowLink() | ShowFile()) 
  {}
}

void 
NodeStatusShowAll() : 
{}
{
  <ALL>
  {
    pSections.add("vsn");
    pSections.add("prop");
    pSections.add("act");
    pSections.add("jreq");
    pSections.add("key");
    pSections.add("link");
    pSections.add("file");
  }
}

void 
NodeStatusHide() : 
{}
{
  <HIDE> EQ() NodeStatusHideSections() (COMMA() NodeStatusHideSections())* AE()  
  {}
}

void 
NodeStatusHideSections() : 
{}
{
  (NodeStatusHideAll() | 
   HideVsn() | HideProp() | HideAct() | HideJReq() | HideKey() | HideLink() | HideFile()) 
  {}
}

void 
NodeStatusHideAll() : 
{}
{
  <ALL>
  {
    pSections.clear(); 
  }
}

/*------------------------------------------------------------------------------------------*/

void 
NodeCheckIn() 
  throws PipelineException : 
{
  String name = null;

  pAuthor  = PackageInfo.sUser;
  pView    = "default";
  pMessage = null;
  pLevel   = null;
}
{
  <NODE_CHECK_IN> EQ() name=NodeName() AE() (NodeCheckInOpts())*
  {
    if(pMessage == null) 
      throw new PipelineException
        ("The --msg option is required!");

    if(pLevel == null) 
      pLevel = VersionID.Level.Minor;

    pMasterMgrClient.checkIn(new NodeID(pAuthor, pView, name), pMessage, pLevel);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Checked-In: " + name);
    LogMgr.getInstance().flush();
  }
}

void
NodeCheckInOpts() 
  throws PipelineException : 
{}
{
  (Author() | View() | Msg() | Major() | Minor() | Micro()) 
  {}
}

void
Major() 
  throws PipelineException : 
{}
{
  <MAJOR> AE()
  {
    if(pLevel != null) 
      throw new PipelineException
	("The --major, --minor and --micro options are mutually exclusive!");

    pLevel = VersionID.Level.Major;
  }
}

void
Minor() 
  throws PipelineException : 
{}
{
  <MINOR> AE()
  {
    if(pLevel != null) 
      throw new PipelineException
	("The --major, --minor and --micro options are mutually exclusive!");

    pLevel = VersionID.Level.Minor;
  }
}

void
Micro() 
  throws PipelineException : 
{}
{
  <MICRO> AE()
  {
    if(pLevel != null) 
      throw new PipelineException
	("The --major, --minor and --micro options are mutually exclusive!");

    pLevel = VersionID.Level.Micro;
  }
}
      
/*------------------------------------------------------------------------------------------*/

void 
NodeCheckOut() 
  throws PipelineException : 
{
  String name = null;

  pAuthor         = PackageInfo.sUser;
  pView           = "default";
  pVersionIDs     = new TreeSet();
  pCheckOutMode   = CheckOutMode.KeepModified; 
  pCheckOutMethod = CheckOutMethod.Modifiable;
}
{
  <NODE_CHECK_OUT> EQ() name=NodeName() AE() (NodeCheckOutOpts())*
  {
    VersionID vid = null;
    if(!pVersionIDs.isEmpty()) {
      if((pVersionIDs.size() > 1))
	throw new PipelineException
	  ("Only one version of a node may checked-out!");
	
      vid = (VersionID) pVersionIDs.first();
    }

    pMasterMgrClient.checkOut(new NodeID(pAuthor, pView, name), vid, 
			      pCheckOutMode, pCheckOutMethod);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Checked-Out: " + name);
    LogMgr.getInstance().flush();
  }
}

void
NodeCheckOutOpts() 
  throws PipelineException : 
{}
{
  (Author() | View() | VersionOption() | 
   OverwriteAll() | KeepModified() | 
   Modifiable() | FrozenUpstream() | AllFrozen())
  {}
}


void
OverwriteAll() : 
{}
{
  <OVERWRITE_ALL> AE()
  {
    pCheckOutMode = CheckOutMode.OverwriteAll; 
  }
}

void
KeepModified() : 
{}
{
  <KEEP_MODIFIED> AE()
  {
    pCheckOutMode = CheckOutMode.KeepModified; 
  }
}


void
Modifiable() : 
{}
{
  <MODIFIABLE> AE()
  {
    pCheckOutMethod = CheckOutMethod.Modifiable;
  }
}

void
FrozenUpstream() : 
{}
{
  <FROZEN_UPSTREAM> AE()
  {
    pCheckOutMethod = CheckOutMethod.FrozenUpstream;
  }
}

void
AllFrozen() : 
{}
{
  <ALL_FROZEN> AE()
  {
    pCheckOutMethod = CheckOutMethod.AllFrozen;
  }
}


/*------------------------------------------------------------------------------------------*/

void 
NodeEvolve() 
  throws PipelineException : 
{
  String name = null;

  pAuthor     = PackageInfo.sUser;
  pView       = "default";
  pVersionIDs = new TreeSet();
}
{
  <NODE_EVOLVE> EQ() name=NodeName() AE() (NodeEvolveOpts())*
  {
    VersionID vid = null;
    if(!pVersionIDs.isEmpty()) {
      if((pVersionIDs.size() > 1))
	throw new PipelineException
	  ("Only one version of a node may evolved!");
	
      vid = (VersionID) pVersionIDs.first();
    }

    pMasterMgrClient.evolve(new NodeID(pAuthor, pView, name), vid);

    LogMgr.getInstance().log
      (LogMgr.Kind.Ops, LogMgr.Level.Info,
       "Evolved: " + name);
    LogMgr.getInstance().flush();
  }
}

void
NodeEvolveOpts() 
  throws PipelineException : 
{}
{
  (Author() | View() | VersionOption()) 
  {}
}


/*------------------------------------------------------------------------------------------*/

void 
NodeGetEvents() 
  throws PipelineException : 
{
  pEventNames = new TreeSet();
  pEventUsers = new TreeSet();
}
{
  <NODE_GET_EVENTS> AE() (NodeGetEventsOpts())*
  {
    pApp.printNodeEvents
      (pEventNames, pEventUsers, pEventStart, pEventFinish, pMasterMgrClient);
  }
}

void
NodeGetEventsOpts() 
  throws PipelineException : 
{}
{
  (Node() | Author() | From() | Until()) 
  {}
}

void 
Node() :
{
  String name = null;
}
{
  <NODE_OPT> EQ() name=NodeName() AE()
  {
    if(pEventNames != null) 
      pEventNames.add(name); 
  }
}

void 
From() 
  throws PipelineException : 
{ 
  long stamp; 
}
{
  <FROM> EQ() stamp=TimeStamp() AE()
  {
    pEventStart = stamp;
  }
}

void 
Until() 
  throws PipelineException : 
{ 
  long stamp; 
}
{
  <UNTIL> EQ() stamp=TimeStamp() AE()
  {
    pEventFinish = stamp; 
  }
}

long
TimeStamp() 
  throws PipelineException : 
{ 
  Token year  = null;
  Token month = null; 
  Token day   = null; 
  Token hour;
  Token minute; 
  Token second;
}
{
  (year=<STAMP_FOUR> DASH() month=<STAMP_TWO> DASH() day=<STAMP_TWO> COMMA())? 
   hour=<STAMP_TWO> COLON() minute=<STAMP_TWO> COLON() second=<STAMP_TWO> 
  {
    try {      
      int h = Integer.parseInt(hour.image);
      if((h < 0) || (h > 23)) 
      throw new PipelineException
        ("Illegal hour of the day (" + h + ") given!");

      int n = Integer.parseInt(minute.image);
      if((n < 0) || (n > 59)) 
      throw new PipelineException
        ("Illegal minute (" + n + ") given!");

      int s = Integer.parseInt(second.image);
      if((s < 0) || (s > 59)) 
      throw new PipelineException
        ("Illegal second (" + s + ") given!");

      GregorianCalendar calendar = new GregorianCalendar();
      if((year != null) && (month != null) && (day != null)) {
	int m = Integer.parseInt(month.image);
	if((m < 1) || (m > 12)) 
	  throw new PipelineException
	    ("Illegal month of the year (" + m + ") given!");
	
	int d = Integer.parseInt(day.image);
	if((d < 1) || (d > 31)) 
	  throw new PipelineException
	    ("Illegal day of the month (" + d + ") given!");
	
	calendar.clear();
	calendar.set(Integer.parseInt(year.image), m-1, d, h, n, s);
      }
      else {
	calendar.setTimeInMillis(System.currentTimeMillis());
	calendar.set(Calendar.HOUR,   h);
	calendar.set(Calendar.MINUTE, n);
	calendar.set(Calendar.SECOND, s);
      }
      
      return calendar.getTimeInMillis();
    }
    catch(NumberFormatException ex) {
      throw new PipelineException("Illegal Date Specification!"); 
    }
  }
}



/*------------------------------------------------------------------------------------------*/
/*   S H O W   H I D E   S E C T I O N S                                                    */
/*------------------------------------------------------------------------------------------*/

void
ShowVsn() : 
{}
{
  <VSN> 
  {
    pSections.add("vsn");    
  }
}

void
ShowProp() : 
{}
{
  <PROP> 
  {
    pSections.add("prop");    
  }
}

void
ShowAct() : 
{}
{
  <ACT>  
  {
    pSections.add("act");    
  }
}

void
ShowArch() : 
{}
{
  <ARCH>  
  {
    pSections.add("arch");    
  }
}

void
ShowJReq() : 
{}
{
  <JREQ> 
  {
    pSections.add("jreq");    
  }
}

void
ShowKey() : 
{}
{
  <KEY> 
  {
    pSections.add("key");    
  }
}

void
ShowLink() : 
{}
{
  <LINK> 
  {
    pSections.add("link");    
  }
}

void
ShowDLink() : 
{}
{
  <DLINK> 
  {
    pSections.add("dlink");    
  }
}

void
ShowTime() : 
{}
{
  <TIME> 
  {
    pSections.add("time");    
  }
}

void
ShowProc() : 
{}
{
  <PROC> 
  {
    pSections.add("proc");    
  }
}

void
ShowWkdir() : 
{}
{
  <WKDIR> 
  {
    pSections.add("wkdir");    
  }
}

void
ShowCmd() : 
{}
{
  <CMD> 
  {
    pSections.add("cmd");    
  }
}

void
ShowEnv() : 
{}
{
  <ENV> 
  {
    pSections.add("env");    
  }
}

void
ShowOut() : 
{}
{
  <OUT> 
  {
    pSections.add("out");    
  }
}

void
ShowErr() : 
{}
{
  <ERR> 
  {
    pSections.add("err");    
  }
}

void
ShowFile() : 
{}
{
  <FILE> 
  {
    pSections.add("file");    
  }
}



void
HideVsn() : 
{}
{
  <VSN> 
  {
    pSections.remove("vsn");    
  }
}

void
HideProp() : 
{}
{
  <PROP> 
  {
    pSections.remove("prop");    
  }
}

void
HideAct() : 
{}
{
  <ACT>  
  {
    pSections.remove("act");    
  }
}

void
HideArch() : 
{}
{
  <ARCH>  
  {
    pSections.remove("arch");    
  }
}

void
HideJReq() : 
{}
{
  <JREQ> 
  {
    pSections.remove("jreq");    
  }
}

void
HideKey() : 
{}
{
  <KEY> 
  {
    pSections.remove("key");    
  }
}

void
HideLink() : 
{}
{
  <LINK> 
  {
    pSections.remove("link");    
  }
}

void
HideDLink() : 
{}
{
  <DLINK> 
  {
    pSections.remove("dlink");    
  }
}

void
HideTime() : 
{}
{
  <TIME> 
  {
    pSections.remove("time");    
  }
}

void
HideProc() : 
{}
{
  <PROC> 
  {
    pSections.remove("proc");    
  }
}

void
HideWkdir() : 
{}
{
  <WKDIR> 
  {
    pSections.remove("wkdir");    
  }
}

void
HideCmd() : 
{}
{
  <CMD> 
  {
    pSections.remove("cmd");    
  }
}

void
HideEnv() : 
{}
{
  <ENV> 
  {
    pSections.remove("env");    
  }
}

void
HideOut() : 
{}
{
  <OUT> 
  {
    pSections.remove("out");    
  }
}

void
HideErr() : 
{}
{
  <ERR> 
  {
    pSections.remove("err");    
  }
}

void
HideFile() : 
{}
{
  <FILE> 
  {
    pSections.remove("file");    
  }
}


/*------------------------------------------------------------------------------------------*/
/*   S H A R E D   O P T I O N S                                                            */
/*------------------------------------------------------------------------------------------*/

void 
Msg() : 
{
  String msg; 
}
{
  <MSG> EQ() msg=StringLiteral() AE()
  {
    pMessage = msg;
  }
}

void
PerSlot() : 
{}
{
  <PER_SLOT> AE()
  {
    pLicenseScheme = LicenseScheme.PerSlot;
  }
}

void
PerHost() : 
{}
{
  <PER_HOST> AE()
  {
    pLicenseScheme = LicenseScheme.PerHost;
  }
}

void
PerHostSlot() : 
{}
{
  <PER_HOST_SLOT> AE()
  {
    pLicenseScheme = LicenseScheme.PerHostSlot;
  }
}

void  
MaxSlots()
  throws PipelineException : 
{
  int maxSlots; 
}
{
  <MAX_SLOTS> EQ() maxSlots=IntegerLiteral() AE()
  {
    pMaxSlots = maxSlots; 
  }
}
     
void  
MaxHosts()
  throws PipelineException : 
{
  int maxHosts; 
}
{
  <MAX_HOSTS> EQ() maxHosts=IntegerLiteral() AE()
  {
    pMaxHosts = maxHosts; 
  }
}
      
void  
MaxHostSlots()
  throws PipelineException : 
{
  int maxHostSlots; 
}
{
  <MAX_HOST_SLOTS> EQ() maxHostSlots=IntegerLiteral() AE()
  {
    pMaxHostSlots = maxHostSlots; 
  }
}
     
void
Author() : 
{
  String uname = null;
}
{
  <AUTHOR> EQ() uname=UserName() AE()
  {
    pAuthor = uname;

    if(pEventUsers != null) 
      pEventUsers.add(uname);
  }
}

void
View() : 
{
  String vname = null;
}
{
  <VIEW2> EQ() vname=ViewName() AE()
  {
    pView = vname;
  }
}

void
FSeq()
  throws PipelineException : 
{
  String prefix = null;
  String suffix = null;
  Integer start = null;
  Integer end   = null;
  Integer by    = 1;
}
{
  <FSEQ> EQ() prefix=Prefix() 
     (DOT() ((Padding() (DOT() suffix=FileSeqSuffix())?) | suffix=FileSeqSuffix()))? 
    (COMMA() start=FrameNumber() (DASH() end=FrameNumber() (<BY> by=FrameNumber())?)?)? AE()
  {
    try {
      FrameRange range = null;
      if(start != null) {
	if(end == null) 
	  range = new FrameRange(start);
	else 
	  range = new FrameRange(start, end, by);
      }

      FilePattern fpat = null;
      if(pPadding == null) 
        fpat = new FilePattern(prefix, suffix);
      else 
        fpat = new FilePattern(prefix, pPadding, suffix);
      
      pFileSeq = new FileSeq(fpat, range);
    }
    catch(IllegalArgumentException ex) {
      throw new PipelineException(ex.getMessage());
    }
  }
}

void
Padding() : 
{
  pPadding = 0;
}
{
  (PaddingSingle())+ | PaddingFour() 
  {}
}

void
PaddingSingle() : 
{}
{
  AT()
  {
    pPadding++;
  }
}

void
PaddingFour() : 
{}
{
  POUND()
  {
    pPadding = 4;
  }
}

void 
Frame() 
  throws PipelineException : 
{}
{
  <FRAME> EQ() FrameNumbers() (COMMA() FrameNumbers())* AE()
  {}
}

void 
FrameNumbers() 
  throws PipelineException : 
{
  Token s;
  Token e = null;
}
{
  s=<FRAME_NUMBER2> (DASH() e=<FRAME_NUMBER2>)?
  {
    try {
      if(e == null) {
	int[] single = new int[1];
	single[0] = Integer.parseInt(s.image);
	pFrames.add(single);
      }
      else {
	int[] range = new int[2];
	range[0] = Integer.parseInt(s.image);
	range[1] = Integer.parseInt(e.image);

	if(range[0] > range[1])
	  throw new PipelineException
	    ("The start frame (" + range[0] + ") cannot be greater than the " + 
	     "end frame (" + range[1] + ")!");

	pFrames.add(range);	
      } 
    }
    catch(NumberFormatException ex) {
      throw new PipelineException(ex.getMessage());
    }    
  }
}

void 
Index() 
  throws PipelineException : 
{}
{
  <INDEX> EQ() FrameIndices() (COMMA() FrameIndices())* AE()
  {}
}

void 
FrameIndices() 
  throws PipelineException : 
{
  Token s;
  Token e = null;
}
{
  s=<FRAME_INDEX> (DASH() e=<FRAME_INDEX>)?
  {
    try {
      if(e == null) {
	int[] single = new int[1];
	single[0] = Integer.parseInt(s.image);
	pIndices.add(single);
      }
      else {
	int[] range = new int[2];
	range[0] = Integer.parseInt(s.image);
	range[1] = Integer.parseInt(e.image);

	if(range[0] > range[1])
	  throw new PipelineException
	    ("The start index (" + range[0] + ") cannot be greater than the " + 
	     "end index (" + range[1] + ")!");

	pIndices.add(range);	
      } 
    }
    catch(NumberFormatException ex) {
      throw new PipelineException(ex.getMessage());
    }    
  }
}

void
Wait() : 
{}
{
  <WAIT> AE()
  {
    pWait = true;
  }
}

void
Toolset() : 
{
  String tname = null;
}
{
  <TOOLSET2> EQ() tname=ToolsetName() AE()
  {
    pToolset = tname;
  }
}

void
Editor()
  throws PipelineException : 
{
  String name   = null;
  VersionID vid = null;
  String vendor = null;
}
{
  <EDITOR2> EQ() name=EditorName() 
   (COLON() vid=RevisionNumber())? (COMMA() vendor=VendorName())? AE()
  {
    pEditorName      = name; 
    pEditorVersionID = vid; 
    pEditorVendor    = vendor; 
  }
}

void
NoAction() :
{}
{
  <NO_ACTION> AE()
  {
    pNoAction        = true;

    pActionName      = null;
    pActionVersionID = null; 
    pActionVendor    = null; 
    pActionEnabled   = null;
    pParams          = new TreeMap();
    pSourceParams    = new TreeMap();
    pOverflowPolicy  = null;
    pExecutionMethod = null;
    pBatchSize       = null;
    pPriority        = null;
    pRampUp          = null;
    pMaxLoad         = null;
    pMinMemory       = null;
    pMinDisk         = null;
    pLicenseKeys     = new TreeMap();
    pSelectionKeys   = new TreeMap();
  }
}

void
Action()
  throws PipelineException : 
{
  String aname  = null;
  VersionID vid = null;
  String vendor = null;
}
{
  <ACTION2> EQ() aname=ActionName() 
    (COLON() vid=RevisionNumber())? (COMMA() vendor=VendorName())? AE()
  {
    pActionName      = aname; 
    pActionVersionID = vid; 
    pActionVendor    = vendor; 
  }
}
  
void 
ActionEnabled() : 
{
  boolean enabled;
}
{
  <ACTION_ENABLED> EQ() enabled=BooleanLiteral() AE()
  {
    pActionEnabled = enabled;
  }
}

void 
Param() : 
{
  String pname  = null;
  String pvalue = null;
}
{
  <PARAM> EQ() pname=ParamName() COLON() pvalue=ParamValue() AE() 
  {
    pParams.put(pname, pvalue);
  }
}

void 
NoParam() : 
{
  String sname  = null;
}
{
  <NO_PARAM> EQ() sname=LinkName() AE() 
  {
    pSourceParams.put(sname, null);
  }
}

void 
SourceParam() : 
{
  String sname  = null;
  String pname  = null;
  String pvalue = null;
}
{
  <SOURCE_PARAM> EQ() sname=SourceName() COMMA() 
     pname=ParamName() COLON() pvalue=ParamValue() AE() 
  {
    TreeMap params = (TreeMap) pSourceParams.get(sname);
    if(params == null) {
      params = new TreeMap();
      pSourceParams.put(sname, params);
    }
    params.put(pname, pvalue);
  }
}

void 
Ignore() : 
{}
{
  <IGNORE> AE() 
  {
    pOverflowPolicy = pOverflowPolicy.Ignore;
  }
}

void 
Abort() : 
{}
{
  <ABORT> AE() 
  {
    pOverflowPolicy = pOverflowPolicy.Abort;
  }
}

void 
Serial() : 
{}
{
  <SERIAL> AE() 
  {
    pExecutionMethod = pExecutionMethod.Serial;
  }
}

void 
Subdivided() :
{}
{
  <SUBDIVIDED> AE() 
  {
    pExecutionMethod = pExecutionMethod.Subdivided;
  }
}

void 
Parallel() : 
{}
{
  <PARALLEL> AE() 
  {
    pExecutionMethod = pExecutionMethod.Parallel;
  }
}

void 
BatchSize()
  throws PipelineException : 
{
  int size;
}
{
  <BATCH_SIZE> EQ() size=IntegerLiteral() AE()
  {
    pBatchSize = size;
  }
}

void 
Priority()
  throws PipelineException : 
{
  int p; 
}
{
  <PRIORITY> EQ() p=IntegerLiteral() AE()
  {
    pPriority = p;
  }
}

void 
RampUp()
  throws PipelineException : 
{
  int i; 
}
{
  <RAMP_UP> EQ() i=IntegerLiteral() AE()
  {
    pRampUp = i; 
  }
}

void 
MaxLoad()
  throws PipelineException : 
{
  double load;
}
{
  <MAX_LOAD> EQ() load=RealLiteral() AE()
  {
    pMaxLoad = (float) load;
  }
}

void 
MinMemory()
  throws PipelineException : 
{
  long size; 
}
{
  <MIN_MEMORY> EQ() size=ByteSize() AE()
  {
    pMinMemory = size; 
  }
}

void 
MinDisk()
  throws PipelineException : 
{
  long size; 
}
{
  <MIN_DISK> EQ() size=ByteSize() AE()
  {
    pMinDisk = size; 
  }
}

void
LicenseKey() : 
{
  String kname; 
  Boolean add = true;
}
{
  <LICENSE_KEY2> EQ() kname=KeyName() (COLON() add=BooleanLiteral())? AE()
  {
    pLicenseKeys.put(kname, add);
  }
}

void
SelectionKey() : 
{
  String kname; 
  Boolean add = true;
}
{
  <SELECTION_KEY2> EQ() kname=KeyName() (COLON() add=BooleanLiteral())? AE()
  {
    pSelectionKeys.put(kname, add);
  }
}

void 
RemoveFiles() : 
{}
{
  <REMOVE_FILES> AE() 
  {
    pRemoveFiles = true;
  }
}

void 
RemoveArea() : 
{}
{
  <REMOVE_AREA> AE() 
  {
    pRemoveArea = true;
  }
}

void 
RenameFiles() : 
{}
{
  <RENAME_FILES> AE() 
  {
    pRenameFiles = true;
  }
}

void 
VersionOption() 
  throws PipelineException : 
{
  VersionID vid = null; 
}
{
  <VERSION2> EQ() vid=RevisionNumber() AE()
  {
    pVersionIDs.add(vid);
  }
}

void 
Latest() :
{}
{
  <LATEST> AE()
  {
    pLatest = true;
  }
}


/*------------------------------------------------------------------------------------------*/
/*   S H A R E D   T O K E N S                                                              */
/*------------------------------------------------------------------------------------------*/

boolean 
BooleanLiteral() :
{
  boolean tf;
}
{
  (tf=True() | tf=False())
  {
    return tf;
  }
}

boolean
True() : 
{}
{
  <TRUE>
  {
    return true;
  }
}

boolean
False() : 
{}
{
  <FALSE>
  {
    return false;
  }
}

String
Name() : 
{
  Token t;
}
{
  t=<USER_NAME>
  {
    return t.image;
  }
}

String
HostName() : 
{
  Token t;
}
{
  (t=<HOST_NAME> | t=<HOST_NAME2>)
  {
    return t.image;
  }
}

String
UserName() : 
{
  Token t;
}
{
  t=<USER_NAME>
  {
    return t.image;
  }
}

String
WorkGroupName() : 
{
  Token t;
}
{
  t=<WORK_GROUP_NAME>
  {
    return t.image;
  }
}

String
ToolsetName() : 
{
  Token t;
}
{
  t=<TOOLSET_NAME>
  {
    return t.image;
  }
}

String
KeyName() : 
{
  Token t;
}
{
  (t=<KEY_NAME2>)
  {
    return t.image;
  }
}

String
SelectionScheduleName() : 
{
  Token t;
}
{
  t=<SCHEDULE_NAME>
  {
    return t.image;
  }
}

String
SelectionGroupName() : 
{
  Token t;
}
{
  t=<GROUP_NAME>
  {
    return t.image;
  }
}

String
Prefix() : 
{
  Token t;
}
{
  t=<PREFIX>
  {
    return t.image;
  }
}

String
Suffix() : 
{
  Token t;
}
{
  t=<SUFFIX1>
  {
    return t.image;
  }
}

String
FileSeqSuffix() : 
{
  Token t;
}
{
  t=<SUFFIX2>
  {
    return t.image;
  }
}

String
FilePatPrefix() : 
{
  Token t;
}
{
  t=<FILE_PAT_PREFIX>
  {
    return t.image;
  }
}

String
FilePatSuffix() : 
{
  Token t;
}
{
  t=<FILE_PAT_SUFFIX>
  {
    return t.image;
  }
}

String
VendorName() : 
{
  Token t;
}
{
  t=<VENDOR_NAME>
  {
    return t.image;
  }
}

String
EditorName() : 
{
  Token t;
}
{
  t=<EDITOR_NAME>
  {
    return t.image;
  }
}

String
ActionName() : 
{
  Token t;
}
{
  t=<ACTION_NAME>
  {
    return t.image;
  }
}

String
ComparatorName() : 
{
  Token t;
}
{
  t=<COMPARATOR_NAME>
  {
    return t.image;
  }
}

String
ToolName() : 
{
  Token t;
}
{
  t=<TOOL_NAME>
  {
    return t.image;
  }
}

String
ArchiverName() : 
{
  Token t;
}
{
  t=<ARCHIVER_NAME>
  {
    return t.image;
  }
}

String
ViewName() : 
{
  Token t;
}
{
  t=<VIEW_NAME>
  {
    return t.image;
  }
}

String
NodeName() : 
{
  Token t;
}
{
  t=<NODE_NAME> 
  {
    return t.image;
  }
}

String
LinkName() : 
{
  Token t;
}
{
  t=<LINK_NAME> 
  {
    return t.image;
  }
}

String
ParamName() : 
{
  Token t;
}
{
  t=<PARAM_NAME> 
  {
    return t.image;
  }
}

String
ParamValue() : 
{
  Token t;
}
{
  t=<PARAM_VALUE> 
  {
    return t.image;
  }
}

String
SourceName() : 
{
  Token t;
}
{
  t=<SOURCE_NAME> 
  {
    return t.image;
  }
}

int
IntegerLiteral()
  throws PipelineException :
{
  Token t;
}
{
  t=<INTEGER>
  { 
    try {
      return Integer.parseInt(t.image);
    }
    catch(NumberFormatException ex) {
      throw new PipelineException(ex.getMessage());
    }
  }
}

long
LongLiteral()
  throws PipelineException :
{
  Token t;
}
{
  t=<INTEGER> 
  { 
    try {
      return Long.parseLong(t.image);
    }
    catch(NumberFormatException ex) {
      throw new PipelineException(ex.getMessage());
    }
  }
}

int
FrameNumber()
  throws PipelineException :
{
  Token t;
}
{
  t=<FRAME_NUMBER>
  { 
    try {
      return Integer.parseInt(t.image);
    }
    catch(NumberFormatException ex) {
      throw new PipelineException(ex.getMessage());
    }
  }
}

long 
ByteSize()
  throws PipelineException : 
{
  Token t; 
  long scale = 1L;
}
{
  t=<BYTE_SIZE> (scale=Kilo() | scale=Mega() | scale=Giga())?
  {
    try {
      return Long.parseLong(t.image) * scale;
    }
    catch(NumberFormatException ex) {
      throw new PipelineException(ex.getMessage());
    }
  }
}

long 
Kilo() :
{}
{
  <KILO> 
  {
    return 1024L;
  }
}

long 
Mega() :
{}
{
  <MEGA> 
  {
    return 1048576L;
  }
}

long 
Giga() :
{}
{
  <GIGA> 
  {
    return 1073741824L;
  }
}


double
RealLiteral()
  throws PipelineException :
{
  Token t;
}
{
  t=<REAL>
  { 
    try {
      return Double.parseDouble(t.image);
    }
    catch(NumberFormatException ex) {
      throw new PipelineException(ex.getMessage());
    }
  }
}

String
StringLiteral() : 
{
  Token t;
}
{
  t=<STRING>
  { 
    if(t.image.length() > 0) 
      return t.image;
    return null;
  }
}

int
PortNumber()
  throws PipelineException :
{
  Token t;
}
{
  t=<PORT_NUMBER>
  { 
    try {
      return Integer.parseInt(t.image);
    }
    catch(NumberFormatException ex) {
      throw new PipelineException(ex.getMessage());
    }
  }
}

VersionID
RevisionNumber() 
  throws PipelineException : 
{
  Token t; 
}
{
  (t=<REVISION_NUMBER> | t=<REVISION_NUMBER2>)
  {
    try {
      return new VersionID(t.image);
    }
    catch(IllegalArgumentException ex) {
      throw new PipelineException(ex.getMessage());
    }
  }
}

Token
Shutdown() :
{
  Token t;
}
{
  (t=<SHUTDOWN1> | t=<SHUTDOWN2>)
  {
    return t;
  }
}


/*------------------------------------------------------------------------------------------*/
/*   S E P A R A T O R   T O K E N S                                                        */
/*------------------------------------------------------------------------------------------*/

Token
AE() :
{
  Token t;
}
{
  (t=<AE1>  | t=<AE2>  | t=<AE3>  | t=<AE4>  | t=<AE5>  | 
   t=<AE6>  | t=<AE7>  | t=<AE8>  | t=<AE9>  | t=<AE10> | 
   t=<AE11> | t=<AE12> | t=<AE13> | t=<AE14> | t=<AE15> | 
   t=<AE16> | t=<AE17> | t=<AE18> | t=<AE19> | t=<AE20> | 
   t=<AE21> | t=<AE22> | t=<AE23> | t=<AE24> | t=<AE25> | 
   t=<AE26> | t=<AE27> | t=<AE28> | t=<AE29> | t=<AE30> |
   t=<AE31> | t=<AE32> | t=<AE33> | t=<AE34> | t=<AE35> |
   t=<AE36> | t=<AE37> | t=<AE38> | t=<AE39> | t=<AE40> | 
   t=<AE41> | t=<AE42> | t=<AE43> | t=<AE44> | t=<AE45> | 
   t=<AE46> | t=<AE47> | t=<AE48> | t=<AE49> | t=<AE50> | 
   t=<AE51> | t=<AE52> | t=<AE53> | t=<AE54> | t=<AE55> | 
   t=<AE56> | t=<AE57>)
  { 
    return t; 
  }
}

Token
DOT() :
{
  Token t;
}
{
  (t=<DOT1> | t=<DOT2> | t=<DOT3> | t=<DOT4>)
  { 
    return t; 
  }
}

Token
AT() :
{
  Token t;
}
{
  (t=<AT1> | t=<AT2>)
  { 
    return t; 
  }
}

Token
POUND() :
{
  Token t;
}
{
  (t=<POUND1> | t=<POUND2>)
  { 
    return t; 
  }
}

Token
DASH() :
{
  Token t;
}
{
  (t=<DASH1> | t=<DASH2> | t=<DASH3> | t=<DASH4>)
  { 
    return t; 
  }
}

Token
COLON() :
{
  Token t;
}
{
  (t=<COLON1> | t=<COLON2>  | t=<COLON3>  | t=<COLON4>  | t=<COLON5>  | 
   t=<COLON6> | t=<COLON7>  | t=<COLON8>  | t=<COLON9>  | t=<COLON10> | 
   t=<COLON11>)
  { 
    return t; 
  }
}

Token
COMMA() :
{
  Token t;
}
{
  (t=<COMMA1>  | t=<COMMA2>  | t=<COMMA3>  | t=<COMMA4>  | t=<COMMA5>  | 
   t=<COMMA6>  | t=<COMMA7>  | t=<COMMA8>  | t=<COMMA9>  | t=<COMMA10> |
   t=<COMMA11> | t=<COMMA12> | t=<COMMA13> | t=<COMMA14> | t=<COMMA15> |
   t=<COMMA16> | t=<COMMA17> | t=<COMMA18>)
  { 
    return t; 
  }
}

Token
EQ() :
{
  Token t;
}
{
  (t=<EQ1>  | t=<EQ2>  | t=<EQ3>  | t=<EQ4>  | t=<EQ5>  | 
   t=<EQ6>  | t=<EQ7>  | t=<EQ8>  | t=<EQ9>  | t=<EQ10> | 
   t=<EQ11> | t=<EQ12> | t=<EQ13> | t=<EQ14> | t=<EQ15> |
   t=<EQ16> | t=<EQ17> | t=<EQ18> | t=<EQ19> | t=<EQ20> | 
   t=<EQ21> | t=<EQ22> | t=<EQ23> | t=<EQ24> | t=<EQ25> |
   t=<EQ26> | t=<EQ27> | t=<EQ28> | t=<EQ29> | t=<EQ30> | 
   t=<EQ31> | t=<EQ32> | t=<EQ33> | t=<EQ34> | t=<EQ35> | 
   t=<EQ36> | t=<EQ37> | t=<EQ38> | t=<EQ39> | t=<EQ40> | 
   t=<EQ41> | t=<EQ42> | t=<EQ43>)
  { 
    return t; 
  }
}

