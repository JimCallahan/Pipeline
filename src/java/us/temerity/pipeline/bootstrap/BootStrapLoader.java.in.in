// $Id: BootStrapLoader.java.in.in,v 1.10 2005/06/10 04:55:06 jim Exp $

package us.temerity.pipeline.bootstrap;

import java.io.*;
import java.net.*;
import java.util.*;
import java.math.*;
import java.security.*;
import java.security.spec.*;
import java.security.interfaces.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
import com.sun.crypto.provider.SunJCE;

/*------------------------------------------------------------------------------------------*/
/*   B O O T   S T R A P   L O A D E R                                                      */
/*------------------------------------------------------------------------------------------*/

/**
 * A class loader which can load classes from the vault.
 */
class BootStrapLoader
  extends ClassLoader
{   
  /*----------------------------------------------------------------------------------------*/
  /*   C O N S T R U C T O R                                                                */
  /*----------------------------------------------------------------------------------------*/
  
  /**
   * Decrypts and unpacks classes stored in the vault.
   */
  public 
  BootStrapLoader() 
    throws LicenseException
  {
    super();
    
    String opsys = null;
    try {
      opsys = System.getProperty("os.name");
    }
    catch(Exception ex) {
      throw new LicenseException("Unable to determine the host operating system!");
    }

    File rootDir = null;
    if(opsys.equals("Linux")) 
      rootDir = new File("@ROOT_INST_DIR@");
    else if (opsys.equals("Mac OS X")) 
      rootDir = new File("@MAC_ROOT_INST_DIR@");
    else 
      assert(false);

    File license = new File(rootDir, "plconfig/temerity-software.key");
    if(!license.isFile()) 
      throw new LicenseException("The license file (" + license + ") was missing!");

    File vault = new File(rootDir, "lib/vault");
    if(!vault.isFile()) 
      throw new LicenseException("The code vault (" + vault + ") was missing!");
    
    /* retrieve the customers private key 
         and the encrypted profile data attached to the key */ 
    PrivateKey privateKey = null;
    try {
      FileReader in = new FileReader(license);
      
      int keySize = 0;
      {
	char cs[] = new char[4];
	in.read(cs, 0, cs.length);
	keySize = Integer.valueOf(new String(cs));
      }
      
      if(keySize <= 0) 
	throw new IOException();
      
      try {
	char cs[] = new char[keySize];
	in.read(cs, 0, cs.length);
	
	BigInteger big = new BigInteger(new String(cs));
	byte bytes[] = big.toByteArray();
	
	KeyFactory factory = KeyFactory.getInstance("DH");
	PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(bytes);
	privateKey = factory.generatePrivate(spec);
      }
      catch(Exception ex) {
	throw new IOException();
      }
      
      in.close();
    }
    catch(IOException ex) {
      throw new LicenseException
	("The license file (" + license + ") has been corrupted!");
    }
    
    /* get the companies public key */ 
    PublicKey publicKey = null;
    try {
      BigInteger big = new BigInteger(sData);
      KeyFactory factory = KeyFactory.getInstance("DH");
      X509EncodedKeySpec spec = new X509EncodedKeySpec(big.toByteArray());
      publicKey = factory.generatePublic(spec);
    }
    catch(Exception ex) {
      throw new LicenseException
	("INTERNAL ERROR: Unable to authorize access to Pipeline...");
    }
    
    /* use the customers private key and the companies public key to create a DES key */ 
    SecretKey key = null;
    try {
      KeyAgreement keyAgree = KeyAgreement.getInstance("DH");
      keyAgree.init(privateKey);
      keyAgree.doPhase(publicKey, true);
      key = keyAgree.generateSecret("DES");
    }
    catch(Exception ex) {
      throw new LicenseException
	("The license file (" + license + ") has been corrupted!");
    }
    
    /* shared I/O byte buffer */ 
    byte buf[] = new byte[65536];

    /* verify the vault's integrity */ 
    {
      byte checksum[] = null;
      try {
	FileInputStream in = new FileInputStream(vault);
	MessageDigest digest = MessageDigest.getInstance("MD5");
	
	while(true) {
	  int num = in.read(buf);
	  if(num == -1) 
	    break;
	  digest.update(buf, 0, num);
	}
	
	checksum = digest.digest();
      }
      catch(Exception ex) {
	throw new LicenseException
	  ("The code vault (" + vault + ") has been corrupted!");
      }

      BigInteger bigA = new BigInteger(checksum);
      BigInteger bigB = new BigInteger(sCheckSum);
      
      if((bigA == null) || (bigB == null)) {
	throw new LicenseException
	  ("Internal Error!");
      }

      if(!bigA.equals(bigB)) {
	throw new LicenseException
	  ("The code vault (" + vault + ") has been corrupted!");
      }
    }
    
    /* decrypt the class entries */ 
    try {
      byte raw[] = null;
      {
	Cipher decipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
	decipher.init(Cipher.DECRYPT_MODE, key);
	CipherInputStream in =  
	  new CipherInputStream(new FileInputStream(vault), decipher);
	
	ByteArrayOutputStream bout = new ByteArrayOutputStream();
	
	while(true) {
	  int num = in.read(buf);
	  if(num == -1) 
	    break;
	  
	  bout.write(buf, 0, num);
	}
	
	in.close();
	
	raw = bout.toByteArray();
      }

      pClasses = new HashMap<String,byte[]>();

      int idx = 0;
      while(idx < raw.length) {
	String cname = null;
	{
	  int size = new Integer(new String(raw, idx, 9));
	  if(size <= 0) 
	    throw new IOException();
	  idx+=9;
	  
	  cname = new String(raw, idx, size); 
	  idx+=size;
	}
	
	byte cbytes[] = null;
	{
	  int size = new Integer(new String(raw, idx, 9));
	  if(size <= 0) 
	    throw new IOException();
	  idx+=9;
	
	  cbytes = new byte[size];
	  int wk;
	  for(wk=0; wk<cbytes.length; wk++, idx++) 
	    cbytes[wk] = raw[idx];
	}

// 	System.out.print("Loaded Class: " + cname + " [" + cbytes.length + "]\n");
// 	System.out.flush();

	pClasses.put(cname, cbytes);
      }
    }
    catch(Exception ex) {
      throw new LicenseException
	("The code vault (" + vault + ") has been corrupted!", ex);
    }
  }



  /*----------------------------------------------------------------------------------------*/
  /*   C L A S S   L O A D E R   O V E R R I D E S                                          */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Finds the specified class. 
   */
  protected Class 
  findClass
  (
   String cname
  ) 
    throws ClassNotFoundException
  {
    byte cbytes[] = pClasses.get(cname);

//     System.out.print("Found Class: " + cname + 
// 		     " [" + ((cbytes != null) ? cbytes.length : -1) + "]\n");
//     System.out.flush();

    if(cbytes == null) 
      throw new ClassNotFoundException(cname);
    
    return defineClass(cname, cbytes, 0, cbytes.length);
  }



  /*----------------------------------------------------------------------------------------*/
  /*   S T A T I C   I N T E R N A L S                                                      */
  /*----------------------------------------------------------------------------------------*/

  @BOOTSTRAP_FIELDS@


  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L S                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /**
   * The decrypted raw class bytes indexed by class name. 
   */ 
  private HashMap<String,byte[]>  pClasses;

}
