// $Id: FileMonitor.java,v 1.2 2006/05/07 21:20:48 jim Exp $

package us.temerity.pipeline;

import us.temerity.pipeline.message.*;
import us.temerity.pipeline.glue.*;

import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.util.*;

/*------------------------------------------------------------------------------------------*/
/*   F I L E   M O N I T O R                                                                */
/*------------------------------------------------------------------------------------------*/

/**
 * Monitors a text file for updates and provides random access to the lines of text. <P> 
 * 
 * The text file typically contains the STDOUT/STDERR output generated by running a  
 * {@link SubProcessHeavy SubProcessHeavy} instance.  This class provides a low memory
 * footprint and high throughput way of monitoring the progress of the subprocess.
 */
public
class FileMonitor
{  
  /*----------------------------------------------------------------------------------------*/
  /*   C O N S T R U C T O R                                                                */
  /*----------------------------------------------------------------------------------------*/

  /** 
   * Monitor the given text file.
   */
  public
  FileMonitor
  (
   File file
  ) 
  {
    if(file == null) 
      throw new IllegalArgumentException
	("The log file cannot be (null)!");
    pFile = file; 

    pLinePos = new ArrayList<Long>();
    pLinePos.add(0L);   

    pBuf = ByteBuffer.allocate(16384);
  }


  /*----------------------------------------------------------------------------------------*/
  /*   A C C E S S                                                                          */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Get the current number of lines in the file. <P> 
   * 
   * @throws IOException 
   *   If the file cannot be opened.
   */ 
  public int
  getNumLines() 
    throws IOException 
  {
    rescan();
    return pLinePos.size();
  }

  
  /*----------------------------------------------------------------------------------------*/
  /*   I / O                                                                                */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Get the contents of the given region of lines in the file. <P> 
   * 
   * If the last character of the last line is a newline (<CODE>\n</CODE>) is it ommited 
   * from the returned string.
   * 
   * @param start
   *   The line number of the first line of text.
   * 
   * @param lines
   *   The number of lines of text to retrieve. 
   * 
   * @throws IOException 
   *   If the file does not contain the given lines of text or cannot be read.
   */ 
  public String
  getLines
  (
   int start, 
   int lines
  ) 
    throws IOException 
  {
    if(start < 0) 
      throw new IOException
	("The start line number (" + start + ") must be non-negative!");

    if(lines < 1) 
      throw new IOException
	("The number of lines to text (" + lines + ") must be positive!");

    if((start+lines) > pLinePos.size())
      rescan();

    if(start >= pLinePos.size())
      throw new IOException
	("The start line (" + start + ") is outside the bounds of the file!");

    long spos = pLinePos.get(start);
    pChannel.position(spos);

    long epos = ((start+lines) < pLinePos.size()) ? pLinePos.get(start+lines) : pFileSize;
    long size = epos - spos;

    StringBuffer buf = new StringBuffer();
    int cnt = 0;
    while(cnt < size) {
      pBuf.clear();
      int num = pChannel.read(pBuf);
      if(num == -1) 
	break;
      
      pBuf.rewind();
      while(pBuf.hasRemaining() && (cnt < size)) {
	char c = (char) pBuf.get();
	if((cnt < (size-1)) || (c != '\n'))
	  buf.append(c);
	cnt++;
      }
    }

    return buf.toString();
  }

  /**
   * Close the file.
   */ 
  public void 
  close()
    throws IOException 
  {
    if(pChannel != null) 
      pChannel.close();
  }



  /*----------------------------------------------------------------------------------------*/
  /*   H E L P E R S                                                                        */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Scan the log file updating the start positions the lines in the file.
   */ 
  private void
  rescan() 
    throws IOException 
  {
    if(pChannel == null) {
      RandomAccessFile raf = new RandomAccessFile(pFile, "r");
      pChannel = raf.getChannel();
    }
    
    if(pFileSize < pChannel.size()) {
      long pos = pLinePos.get(pLinePos.size()-1);
      pChannel.position(pos);

      char c = '\0';
      while(true) {
	pBuf.clear();
	int num = pChannel.read(pBuf);
	if(num == -1) 
	  break;

	pBuf.rewind();
	int wk;
	for(wk=0; wk<num; wk++) {
	  c = (char) pBuf.get();
	  pos++;
	  if(c == '\n')
	    pLinePos.add(pos);
	}
      }

      pFileSize = pChannel.size();
    }
  }


  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L S                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /**
   * The log file being monitored.
   */
  private File pFile; 
    
  /**
   * The read-only channel connected to the log file.
   */ 
  private FileChannel pChannel; 

  /**
   * The buffer used to transfer bytes from the file.
   */ 
  private ByteBuffer  pBuf;

  /**
   * The last known size of the file (in bytes).
   */ 
  private long  pFileSize; 

  /**
   * The byte positions in the file of the start of each line.
   */ 
  private ArrayList<Long>   pLinePos;
}

