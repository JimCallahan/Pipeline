// $Id: NodeMod.java,v 1.2 2004/03/01 21:44:08 jim Exp $

package us.temerity.pipeline;

import java.util.*;

/*------------------------------------------------------------------------------------------*/
/*   N O D E   M O D                                                                        */
/*------------------------------------------------------------------------------------------*/

/**
 * A modifiable working version of a node. <P> 
 * 
 *
 */
public
class NodeMod
  extends NodeCommon
{  
  /*----------------------------------------------------------------------------------------*/
  /*   C O N S T R U C T O R                                                                */
  /*----------------------------------------------------------------------------------------*/

  public 
  NodeMod()
  {
    pSourceModDepends = new TreeMap<String,DependMod>();

    pTargetNames = new TreeSet<String>();
  }

  /**
   * Construct an inital working version of a new node. <P> 
   *  
   * The <CODE>secondary</CODE> argument may be <CODE>null</CODE> if there are no 
   * secondary file sequences associated with the node. <P> 
   * 
   * The <CODE>editor</CODE> argument may be <CODE>null</CODE> if there is no default 
   * editor associated with the node. <P> 
   * 
   * If there is no regeneration action for this node then the <CODE>action</CODE> and 
   * <CODE>jobReqs</CODE> must both be <CODE>null</CODE>.  If there is a regeneration
   * action, then both arguments must not be <CODE>null</CODE>. <P>
   * 
   * If the <CODE>batchSize</CODE> argument is zero, then the maximum number of frames
   * which can be assigned to a single job is equal to the number of frames in the 
   * primary file sequence.  The <CODE>batchSize</CODE> argument cannot be negative. <P> 
   * 
   * @param name [<B>in</B>]
   *   The fully resolved node name.
   * 
   * @param primary [<B>in</B>]
   *   The primary file sequence associated with the node.
   * 
   * @param secondary [<B>in</B>]
   *   The secondary file sequences associated with the node.
   * 
   * @param toolset [<B>in</B>]
   *   The named execution environment under which editor and action are run.
   * 
   * @param editor [<B>in</B>]
   *   The name of the editor plugin used to editing/viewing the files associated with 
   *   the node.
   * 
   * @param action [<B>in</B>]
   *   The action plugin instance used to regeneration the files associated the node. 
   * 
   * @param jobReqs [<B>in</B>]
   *   The requirements that a server must meet in order to be eligable to run jobs 
   *   the node.
   *
   * @param ignoreOverflow [<B>in</B>]
   *   Whether dependencies which overflow their frame ranges should be ignored when 
   *   generating jobs for the node?
   *
   * @param isSerial [<B>in</B>]
   *   Are all of the files associated with the node regenerated by a single job invocation?
   *
   * @param batchSize [<B>in</B>]
   *   For parallel jobs, this is the maximum number of frames assigned to each job.
   */
  public
  NodeMod
  (
   String name, 
   FileSeq primary,
   Set<FileSeq> secondary, 
   String toolset, 
   String editor, 
   BaseAction action, 
   JobReqs jobReqs,     
   boolean ignoreOverflow, 
   boolean isSerial, 
   int batchSize
  ) 
  {
    super(name, 
	  primary, secondary, 
	  toolset, editor, 
	  action, jobReqs, ignoreOverflow, isSerial, batchSize);
    
    pLastMod = new Date();

    pSourceModDepends = new TreeMap<String,DependMod>();

    pTargetNames = new TreeSet<String>();
  }

  /** 
   * Construct a new working version based on a checked-in version of the node.
   * 
   * @param vsn [<B>in</B>]
   *   The checked-in version of the node.
   */ 
  public 
  NodeMod
  (
   NodeVersion vsn
  ) 
  {
    super(vsn);

    pWorkingID = vsn.getVersionID();

    pLastMod = new Date();

    pSourceModDepends = new TreeMap<String,DependMod>();
    for(DependVersion dep : vsn.getSources()) 
      pSourceModDepends.put(dep.getName(), new DependMod(dep));

    pTargetNames = new TreeSet<String>();
  }



  /*----------------------------------------------------------------------------------------*/
  /*   A C C E S S                                                                          */
  /*----------------------------------------------------------------------------------------*/

  /**
   * The revision number of the <CODE>NodeVersion</CODE> upon which this <CODE>NodeMod</CODE> 
   * is based.  
   * 
   * @return 
   *   The revision number or <CODE>null</CODE> if this is an intial working version.
   */ 
  public VersionID
  getWorkingID()
  {
    return new VersionID(pWorkingID);
  }
  
  
  /** 
   * Get the timestamp of the last modification of this working version.
   */
  public Date
  getLastModification() 
  {
    return pLastMod;
  }

  
  /*----------------------------------------------------------------------------------------*/

  // rename primary file sequence

  // add and remove secondary file sequences

  // change frame range across all file sequences


  // setEditor()


  // setAction(), setJobReqs(), setIgnoreOverflow(), setIsSerial(), setBatchSize()


  
  /*----------------------------------------------------------------------------------------*/

  /** 
   * Get the fully resolved names of the upstream nodes.
   */
  public ArrayList<String>
  getSourceNames() 
  {
    return new ArrayList<String>(pSourceModDepends.keySet());
  }

  /** 
   * Get the dependency relationship information for the given upstream node.
   * 
   * @param name [<B>in</B>] 
   *   The fully resolved node name of the upstream node.
   * 
   * @return 
   *   The dependency relationship information or <CODE>null</CODE> if no upstream node
   *   exits with the given name.
   */
  public DependMod
  getSource
  (
   String name
  ) 
  {
    if(name == null) 
      throw new IllegalArgumentException("The upstream node name cannot be (null)!");

    return new DependMod(pSourceModDepends.get(name));
  }

  /** 
   * Get the dependency relationship information for all of the upstream nodes.
   */
  public ArrayList<DependMod>
  getSources() 
  {
    ArrayList<DependMod> deps = new ArrayList<DependMod>();
    for(DependMod dep : pSourceModDepends.values()) 
      deps.add(new DependMod(dep));
    return deps;
  }

  /** 
   * Set the dependency relationship information for the given upstream node.
   * 
   * @param dep [<B>in</B>] 
   *   The new dependency relationship information.
   */
  public void
  setSource
  (
   DependMod dep
  ) 
  {
    pSourceModDepends.put(dep.getName(), new DependMod(dep));
    pLastMod = new Date();
  }

  /** 
   * Remove the dependency relationship information for the given upstream node.
   * 
   * @param name [<B>in</B>] 
   *   The fully resolved node name of the upstream node.
   */
  public void
  removeSource
  (
   String name
  ) 
  {
    if(name == null) 
      throw new IllegalArgumentException("The upstream node name cannot be (null)!");

    if(!pSourceModDepends.containsKey(name)) 
      throw new IllegalArgumentException("No upstream node named (" + name + ") exists!");

    pSourceModDepends.remove(name);
    pLastMod = new Date();
  }
  
  /** 
   * Remove the dependency relationship information for all upstream nodes.
   */
  public void
  removeAllSources() 
  {
    pSourceModDepends.clear();
    pLastMod = new Date();
  }


  /*----------------------------------------------------------------------------------------*/
  
  /** 
   * Get the fully resolved names of the downstream nodes.
   */
  public ArrayList<String>
  getTargetNames() 
  {
    return new ArrayList<String>(pTargetNames);
  }
    
  /** 
   * Add the given node to the set of downstream nodes.
   * 
   * @param name [<B>in</B>] 
   *   The fully resolved node name of the downstream node.
   */
  public void
  addTarget
  (
   String name
  ) 
  {
    pTargetNames.add(name);
    pLastMod = new Date();
  }

  /** 
   * Remove given node from the set of downstream nodes.
   * 
   * @param name [<B>in</B>] 
   *   The fully resolved node name of the downstream node.
   */
  public void
  removeTarget
  (
   String name
  ) 
  {
    if(name == null) 
      throw new IllegalArgumentException("The downstream node name cannot be (null)!");

    if(!pTargetNames.contains(name)) 
      throw new IllegalArgumentException("No downstream node named (" + name + ") exists!");

    pTargetNames.remove(name);
    pLastMod = new Date();
  }
  
  /** 
   * Remove the dependency relationship information for all downstream nodes.
   */
  public void
  removeAllTargets()
  {
    pTargetNames.clear();
    pLastMod = new Date();
  }
  


  /*----------------------------------------------------------------------------------------*/
  /*   S T A T I C   I N T E R N A L S                                                      */
  /*----------------------------------------------------------------------------------------*/

  private static final long serialVersionUID = 3996510873376950488L;



  /*----------------------------------------------------------------------------------------*/
  /*   I N T E R N A L S                                                                    */
  /*----------------------------------------------------------------------------------------*/

  /**
   * The revision number of the <CODE>NodeVersion</CODE> upon which this <CODE>NodeMod</CODE> 
   * is based.  If <CODE>null</CODE>, then this is an intial working version of a node which
   * has never been checked-in.
   */ 
  private VersionID  pWorkingID;       

  /** 
   * The timestamp of the last modification of any field of this instance.  
   */
  private Date  pLastMod;


  /**
   * A table of dependency information associated with all nodes upstream of this 
   * node indexed by the fully resolved names of the upstream nodes.
   */ 
  private TreeMap<String,DependMod>  pSourceModDepends;
 
  /**
   * The fully resolved names of all downstream nodes which depend upon this node.
   */ 
  private TreeSet<String>  pTargetNames;
 
}

