// $Id: HfsOPLibsAction.java,v 1.1 2007/10/23 01:47:37 jim Exp $

package us.temerity.pipeline.plugin.HfsOPLibsAction.v2_3_14;

import us.temerity.pipeline.*; 
import us.temerity.pipeline.plugin.*; 

import java.lang.*;
import java.util.*;
import java.io.*;

/*------------------------------------------------------------------------------------------*/
/*   H F S   O P   L I B S   A C T I O N                                                    */
/*------------------------------------------------------------------------------------------*/

/** 
 * Generates an OPlibraries file which specifies the OTLs to be loaded by Houdini. <P>
 * 
 * Each Operator Type Library (.otl) which is the single member of the primary file sequence 
 * of one of the source nodes will be included in the generated OPlibraries file. <P> 
 * 
 * The operators loaded by Houdini are determined by the HOUDINI_OTL_PATH environmental 
 * variable.  In order to insure that Houdini related nodes use the proper OTLs when 
 * executing the actions of jobs and launching editors, a toolset package should be created 
 * which contains a definition of this HOUDINI_OTL_PATH variable.  The path should include 
 * the directories where the OPlibraries files generated by this action reside.  Toolsets 
 * can then be built which provide a specific set of OTLs required by a related set of 
 * Houdini nodes. <P> 
 * 
 * See the <A href="http://www.sidefx.com">Houdini</A> documentation for details on OTLs
 * and their usage with Houdini. <P> 
 * 
 * This action defines the following single valued parameters: <BR>
 * 
 * <DIV style="margin-left: 40px;">
 *   Relative Paths <BR>
 *   <DIV style="margin-left: 40px;">
 *     Whether to generate relative paths to the source OTL files instead of using absolute
 *     paths starting with $WORKING.<BR>
 *   </DIV> <BR>
 * 
 *   Strict Naming <BR>
 *   <DIV style="margin-left: 40px;"><BR>
 *     Whether to require that the generated target file be named (OPlibraries).
 *   </DIV> <BR>
 * </DIV>
 */
public
class HfsOPLibsAction
  extends CommonActionUtils
{  
  /*----------------------------------------------------------------------------------------*/
  /*   C O N S T R U C T O R                                                                */
  /*----------------------------------------------------------------------------------------*/
  
  public
  HfsOPLibsAction() 
  {
    super("HfsOPLibs", new VersionID("2.3.14"), "Temerity", 
	  "Generates an OPlibraries file which specifies the OTLs to be loaded by Houdini.");

    {
      ActionParam param = 
	new BooleanActionParam
	(aRelativePaths,
	 "Whether to generate relative paths to the source OTL files instead of using " + 
         "absolute paths starting with $WORKING.",
	 true);
      addSingleParam(param);
    }

    {
      ActionParam param = 
	new BooleanActionParam
	(aStrictNaming,
	 "Whether to require that the generated target file be named (OPlibraries).",
	 true);
      addSingleParam(param);
    }

    addSupport(OsType.Windows); 
  }


  /*----------------------------------------------------------------------------------------*/
  /*   A C T I O N                                                                          */
  /*----------------------------------------------------------------------------------------*/

  /**
   * Construct a {@link SubProcessHeavy SubProcessHeavy} instance which when executed will 
   * fulfill the given action agenda. <P> 
   * 
   * @param agenda
   *   The agenda to be accomplished by the action.
   * 
   * @param outFile 
   *   The file to which all STDOUT output is redirected.
   * 
   * @param errFile 
   *   The file to which all STDERR output is redirected.
   * 
   * @return 
   *   The SubProcess which will fulfill the agenda.
   * 
   * @throws PipelineException 
   *   If unable to prepare a SubProcess due to illegal, missing or imcompatable 
   *   information in the action agenda or a general failure of the prep method code.
   */
  public SubProcessHeavy
  prep
  (
   ActionAgenda agenda,
   File outFile, 
   File errFile 
  )
    throws PipelineException
  {
    NodeID nodeID = agenda.getNodeID();

    /* target file */ 
    Path target = getPrimaryTargetPath(agenda, "file");
    if(getSingleBooleanParamValue(aStrictNaming) && !target.getName().equals(aOPlibraries))
      throw new PipelineException
        ("The target primary file sequence (" + agenda.getPrimaryTarget() + ") must be " + 
         "a single file named (" + aOPlibraries + ").");

    /* source OTL files */ 
    TreeSet<Path> sources = new TreeSet<Path>(); 
    for(String sname : agenda.getSourceNames()) {
      NodeID snodeID = new NodeID(agenda.getNodeID(), sname);
      
      File sourceFile = null;
      {
        FileSeq fseq = agenda.getPrimarySource(sname);
        FilePattern fpat = fseq.getFilePattern();
        String suffix = fpat.getSuffix();
        if(!fseq.isSingle() || (suffix == null) || !suffix.equals("otl"))
          throw new PipelineException
            ("The source primary file sequence (" + fseq + ") must contain a single " + 
             "Operator Type Library (.otl) file.");

        if(getSingleBooleanParamValue(aRelativePaths)) {
          sources.add(new Path(snodeID.getParent(), fseq.getPath(0)));
        }
        else {
          Path spath = new Path(sname); 
          sources.add(new Path(spath.getParentPath(), fseq.getPath(0)));
        }          
      }
    }

    File temp = createTemp(agenda, "temp");
    try {      
      BufferedWriter out = new BufferedWriter(new FileWriter(temp));

      if(getSingleBooleanParamValue(aRelativePaths)) {
        String targetDir = nodeID.getParent().toFile().getPath();
        String tpath[] = targetDir.split("/");
      
        for(Path source : sources) {
          String spath[] = source.toString().split("/");
	
          int tk, sk;
          for(tk=0, sk=0; tk<tpath.length; tk++, sk++) {
            if((sk >= (spath.length-1)) || !spath[sk].equals(tpath[tk]))
              break;
          }

          for(; tk<tpath.length; tk++)
            out.write("../");

          for(; sk<(spath.length-1); sk++)
            out.write(spath[sk] + "/");
	
          out.write(spath[sk] + "\n");
        }
      }
      else {
        for(Path source : sources) 
          out.write("$WORKING" + source.toOsString() + "\n");
      }
      
      out.close();
    }
    catch(IOException ex) {
      throw new PipelineException
	("Unable to write temporary file (" + temp + ") for Job " + 
	 "(" + agenda.getJobID() + ")!\n" +
	 ex.getMessage());
    }
    
    /* create the process to run the action */ 
    return createTempCopySubProcess(agenda, temp, target, outFile, errFile);    
  }



  /*----------------------------------------------------------------------------------------*/
  /*   S T A T I C   I N T E R N A L S                                                      */
  /*----------------------------------------------------------------------------------------*/

  private static final long serialVersionUID = -2032288905717557806L;

  public static final String aRelativePaths = "RelativePaths";
  public static final String aStrictNaming  = "StrictNaming"; 
  public static final String aOPlibraries   = "OPlibraries";

}

