// $Id: FilterMissingPlugins.java,v 1.1 2009/11/24 05:04:18 jim Exp $

import java.io.*; 
import java.util.*; 
import java.math.*; 
import java.text.*;

import us.temerity.pipeline.*;
import us.temerity.pipeline.glue.*;
import us.temerity.pipeline.glue.io.*;

/*------------------------------------------------------------------------------------------*/
/*   F I L T E R   M I S S I N G   P L U G I N S                                            */
/*------------------------------------------------------------------------------------------*/

public 
class FilterMissingPlugins
{  
  public static void 
  main
  (
   String[] args  
  )
  {
    boolean success = false;
    try {
      if(args.length != 2) 
        usage(); 

      String dbFile = args[0];
      String missingFile = args[1];

      MappedSet<PluginType,PluginID> plugins = (MappedSet<PluginType,PluginID>)
        GlueDecoderImpl.decodeFile("RequredPlugins", new File(dbFile));
 
      {
        LogMgr.getInstance().logAndFlush
          (LogMgr.Kind.Ops, LogMgr.Level.Info, 
           "ORIGINAL:"); 
        long total = 0L;
        for(PluginType p : plugins.keySet()) {
          long count = plugins.get(p).size(); 
          total += count;
          LogMgr.getInstance().logAndFlush
            (LogMgr.Kind.Ops, LogMgr.Level.Info, 
             "  " + p + " = " + count);
        }
        LogMgr.getInstance().logAndFlush
          (LogMgr.Kind.Ops, LogMgr.Level.Info, 
           "  TOTAL = " + total);
      }

      String name = null;
      VersionID vid = null;
      String vendor = null; 
      PluginType ptype = null;

      BufferedReader in = new BufferedReader(new FileReader(missingFile));
      while(true) {
        String line = in.readLine();
        if(line == null) 
          break;

        if(line.startsWith("Name")) {
          name = line.substring(14, line.length());
        }
        else if(line.startsWith("Version")) {
          vid = new VersionID(line.substring(14, line.length()));
        }
        else if(line.startsWith("Vendor")) {
          vendor = line.substring(14, line.length());
        }
        else if(line.startsWith("PluginType")) {
          ptype = PluginType.valueOf(PluginType.class, line.substring(14, line.length()));
        }
        else if(line.startsWith("Version")) {
          vid = new VersionID(line.substring(14, line.length()));
        }
        else if(line.startsWith("Status")) {
          
          LogMgr.getInstance().logAndFlush
            (LogMgr.Kind.Ops, LogMgr.Level.Info, 
             "Removing: " + ptype + " " + name + " v" + vid + " from " + vendor); 

          PluginID pid = new PluginID(name, vid, vendor);
          plugins.remove(ptype, pid); 

          name = null;
          vid = null;
          vendor = null; 
          ptype = null;
        }
      }
        
      {
        LogMgr.getInstance().logAndFlush
          (LogMgr.Kind.Ops, LogMgr.Level.Info, 
           "FIXED:"); 
        long total = 0L;
        for(PluginType p : plugins.keySet()) {
          long count = plugins.get(p).size(); 
          total += count;
          LogMgr.getInstance().logAndFlush
            (LogMgr.Kind.Ops, LogMgr.Level.Info, 
             "  " + p + " = " + count);
        }
        LogMgr.getInstance().logAndFlush
          (LogMgr.Kind.Ops, LogMgr.Level.Info, 
           "  TOTAL = " + total);
      }

      GlueEncoderImpl.encodeFile("RequiredPlugins", plugins, new File(dbFile + ".FIXED"));

      success = true;
    }
    catch(PipelineException ex) {
      LogMgr.getInstance().logAndFlush
	(LogMgr.Kind.Ops, LogMgr.Level.Severe,
	 ex.getMessage());
    }
    catch(Exception ex) {
      LogMgr.getInstance().logAndFlush
	(LogMgr.Kind.Ops, LogMgr.Level.Severe,
	 Exceptions.getFullMessage(ex));
    }
    finally {
      LogMgr.getInstance().cleanup();
    }

    System.exit(success ? 0 : 1);
  }

  private static void 
  usage()
    throws PipelineException
  {
    throw new PipelineException
      ("usage: FilterMissingPlugins StudioRequiredDB MissingOutput\n" + 
       "\n" +
       "Edits the required plugins database file (StudioRequiredDB) for a studio to\n" + 
       "remove entries for a set of missing plugins (MissingOutput) generated by running:\n" + 
       "\n" +
       "  $ plplugin list --status=miss\n" + 
       "\n" + 
       "Generally, this would be a very bad idea since the missing plugins should be\n" + 
       "installed and removing them from the required list bypasses an important check.\n" + 
       "The reason this utility exists is to revert the required plugins database file\n" + 
       "after a failed attempt to upgrade has added additional plugins not really required\n" + 
       "by the previous version of Pipeline before the upgrade. Backing it up before the\n" + 
       "the upgrade would be a better idea than using this utility, but if you don't have\n" + 
       "a backup, this can come in handy."); 
  }
}
